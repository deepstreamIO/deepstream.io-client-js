(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("deepstream", [], factory);
	else if(typeof exports === 'object')
		exports["deepstream"] = factory();
	else
		root["deepstream"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./binary-protocol/src/constants.ts":
/*!******************************************!*\
  !*** ./binary-protocol/src/constants.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HEADER_LENGTH = 8;\nexports.META_PAYLOAD_OVERFLOW_LENGTH = Math.pow(2, 24) - 1;\n\n\n//# sourceURL=webpack://deepstream/./binary-protocol/src/constants.ts?");

/***/ }),

/***/ "./binary-protocol/src/message-builder.ts":
/*!************************************************!*\
  !*** ./binary-protocol/src/message-builder.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n/**\n * Functions for handling (de)serialization of the deepstream binary realtime protocol.\n *\n * In brief, a message is a variable length binary blob with the following structure:\n *\n *  0                   1                   2                   3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-+-------------+-+-------------+-------------------------------+\n * |F|  Message    |A|  Message    |             Meta              |\n * |I|   Topic     |C|  Action     |            Length             |\n * |N|    (7)      |K|   (7)       |             (24)              |\n * +-+-------------+-+-------------+-------------------------------+\n * | Meta Cont.    |              Payload Length (24)              |\n * +---------------+-----------------------------------------------+\n * :                     Meta Data (Meta Length * 8)               :\n * + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n * |                  Payload Data (Payload Length * 8)            :\n * +---------------------------------------------------------------+\n *\n * The first 6 bytes of the message are the header, and the rest of the message is the payload.\n *\n * CONT (1 bit): The continuation bit. If this is set, the following payload of the following\n *                message must be appended to this one. If this is not set, parsing may finish\n *                after the payload is read.\n * RSV{0..3} (1 bit): Reserved for extension.\n * Meta Length (24 bits, unsigned big-endian): The total length of Meta Data in bytes.\n *                If Meta Data can be no longer than 16 MB.\n * Payload Length (24 bits, unsigned big-endian): The total length of Payload in bytes.\n *                If Payload is longer than 16 MB, it must be split into chunks of\n *                less than 2^24 bytes with identical topic and action, setting the CONT bit\n *                in all but the final chunk.\n *\n */\n/* tslint:disable:no-bitwise */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ./message-constants */ \"./binary-protocol/src/message-constants.ts\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./binary-protocol/src/utils.ts\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"./binary-protocol/src/constants.ts\");\nconst message_validator_1 = __webpack_require__(/*! ./message-validator */ \"./binary-protocol/src/message-validator.ts\");\nfunction getMessage(msg, isAck) {\n    const message = msg;\n    let action = message.action;\n    // convert action to write ack if necessary\n    if (message.isWriteAck && !utils_1.isWriteAck(message.action)) {\n        action = utils_1.ACTION_TO_WRITE_ACK[message.action];\n    }\n    if (message.isAck || isAck) {\n        action |= 0x80;\n        if (message_constants_1.ACTIONS[message.topic][message.action] === undefined) {\n            throw new Error(`message ${message_constants_1.TOPIC[message.topic]} ${message.action} should not have an ack`);\n        }\n    }\n    const meta = Object.create(null);\n    for (const key in message_constants_1.META_KEYS) {\n        meta[message_constants_1.META_KEYS[key]] = message[key];\n    }\n    if (meta[message_constants_1.META_KEYS.payloadEncoding] === message_constants_1.PAYLOAD_ENCODING.JSON) {\n        delete meta[message_constants_1.META_KEYS.payloadEncoding];\n    }\n    const metaError = message_validator_1.validateMeta(message.topic, action, meta);\n    if (metaError) {\n        throw new Error(`invalid ${message_constants_1.TOPIC[message.topic]} ${message_constants_1.ACTIONS[message.topic][action] || action}: ${metaError}`);\n    }\n    const metaStr = JSON.stringify(meta);\n    const metaBuff = metaStr === '{}' ? null : Buffer.from(metaStr, 'utf8');\n    let payloadBuff;\n    if (message.data instanceof Buffer) {\n        payloadBuff = message.data;\n    }\n    else if (message.data !== undefined || message.parsedData !== undefined) {\n        let payloadStr = message.data;\n        if (payloadStr === undefined) {\n            payloadStr = JSON.stringify(message.parsedData);\n        }\n        payloadBuff = Buffer.from(payloadStr, 'utf8');\n    }\n    else {\n        payloadBuff = null;\n    }\n    if (payloadBuff && !message_validator_1.hasPayload(message.topic, action)) {\n        console.error(`invalid message ${message_constants_1.TOPIC[message.topic]} ${message.action}: should not have payload`);\n    }\n    const metaBuffLength = metaBuff ? metaBuff.length : 0;\n    const payloadBuffLength = payloadBuff ? payloadBuff.length : 0;\n    if (metaBuffLength <= constants_1.META_PAYLOAD_OVERFLOW_LENGTH\n        && payloadBuffLength <= constants_1.META_PAYLOAD_OVERFLOW_LENGTH) {\n        return buildRaw(true, message.topic, action, metaBuff, payloadBuff);\n    }\n    else {\n        return buildMultipart(message.topic, action, metaBuff, payloadBuff);\n    }\n}\nexports.getMessage = getMessage;\nfunction buildMultipart(topic, action, meta, payload) {\n    const metaLength = meta ? meta.length : 0;\n    const payloadLength = payload ? payload.length : 0;\n    const messageParts = [];\n    let metaSectionOffset = 0;\n    let payloadSectionOffset = 0;\n    let fin;\n    do {\n        const metaSectionLength = Math.min(metaLength - metaSectionOffset, constants_1.META_PAYLOAD_OVERFLOW_LENGTH);\n        const payloadSectionLength = Math.min(payloadLength - payloadSectionOffset, constants_1.META_PAYLOAD_OVERFLOW_LENGTH);\n        const metaSection = meta && meta.slice(metaSectionOffset, metaSectionOffset + metaSectionLength);\n        const payloadSection = payload && payload.slice(payloadSectionOffset, payloadSectionOffset + payloadSectionLength);\n        metaSectionOffset += metaSectionLength;\n        payloadSectionOffset += payloadSectionLength;\n        fin = metaSectionOffset === metaLength && payloadSectionOffset === payloadLength;\n        messageParts.push(buildRaw(fin, topic, action, metaSection, payloadSection));\n    } while (!fin);\n    return Buffer.concat(messageParts);\n}\nfunction buildRaw(fin, topic, action, meta, payload) {\n    const metaLength = meta ? meta.length : 0;\n    const payloadLength = payload ? payload.length : 0;\n    const messageBufferLength = constants_1.HEADER_LENGTH + metaLength + payloadLength;\n    const messageBuffer = Buffer.allocUnsafe(messageBufferLength);\n    messageBuffer[0] = (fin ? 0x80 : 0x00) | topic;\n    messageBuffer[1] = action;\n    messageBuffer.writeUIntBE(metaLength, 2, 3);\n    messageBuffer.writeUIntBE(payloadLength, 5, 3);\n    if (meta) {\n        meta.copy(messageBuffer, constants_1.HEADER_LENGTH);\n    }\n    if (payload) {\n        payload.copy(messageBuffer, constants_1.HEADER_LENGTH + metaLength);\n    }\n    return messageBuffer;\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://deepstream/./binary-protocol/src/message-builder.ts?");

/***/ }),

/***/ "./binary-protocol/src/message-constants.ts":
/*!**************************************************!*\
  !*** ./binary-protocol/src/message-constants.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar META_KEYS;\n(function (META_KEYS) {\n    META_KEYS[\"payloadEncoding\"] = \"e\";\n    META_KEYS[\"name\"] = \"n\";\n    META_KEYS[\"names\"] = \"m\";\n    META_KEYS[\"subscription\"] = \"s\";\n    META_KEYS[\"correlationId\"] = \"c\";\n    META_KEYS[\"version\"] = \"v\";\n    META_KEYS[\"path\"] = \"p\";\n    META_KEYS[\"reason\"] = \"r\";\n    META_KEYS[\"url\"] = \"u\";\n    META_KEYS[\"originalTopic\"] = \"t\";\n    META_KEYS[\"originalAction\"] = \"a\";\n    META_KEYS[\"protocolVersion\"] = \"x\";\n    META_KEYS[\"requestorName\"] = \"rn\";\n    META_KEYS[\"requestorData\"] = \"rd\";\n    META_KEYS[\"trustedSender\"] = \"ts\";\n    META_KEYS[\"registryTopic\"] = \"rt\";\n})(META_KEYS = exports.META_KEYS || (exports.META_KEYS = {}));\nvar PAYLOAD_ENCODING;\n(function (PAYLOAD_ENCODING) {\n    PAYLOAD_ENCODING[\"JSON\"] = \"j\";\n    PAYLOAD_ENCODING[\"BINARY\"] = \"b\";\n})(PAYLOAD_ENCODING = exports.PAYLOAD_ENCODING || (exports.PAYLOAD_ENCODING = {}));\nvar TOPIC;\n(function (TOPIC) {\n    TOPIC[TOPIC[\"ERROR\"] = 0] = \"ERROR\";\n    TOPIC[TOPIC[\"PARSER\"] = 1] = \"PARSER\";\n    TOPIC[TOPIC[\"CONNECTION\"] = 2] = \"CONNECTION\";\n    TOPIC[TOPIC[\"AUTH\"] = 3] = \"AUTH\";\n    TOPIC[TOPIC[\"EVENT\"] = 4] = \"EVENT\";\n    TOPIC[TOPIC[\"RECORD\"] = 5] = \"RECORD\";\n    TOPIC[TOPIC[\"RPC\"] = 6] = \"RPC\";\n    TOPIC[TOPIC[\"PRESENCE\"] = 7] = \"PRESENCE\";\n    TOPIC[TOPIC[\"SUBSCRIPTIONS\"] = 16] = \"SUBSCRIPTIONS\";\n    TOPIC[TOPIC[\"ONLINE_USERS\"] = 17] = \"ONLINE_USERS\";\n    TOPIC[TOPIC[\"EVENT_SUBSCRIPTIONS\"] = 32] = \"EVENT_SUBSCRIPTIONS\";\n    TOPIC[TOPIC[\"RECORD_SUBSCRIPTIONS\"] = 33] = \"RECORD_SUBSCRIPTIONS\";\n    TOPIC[TOPIC[\"RPC_SUBSCRIPTIONS\"] = 34] = \"RPC_SUBSCRIPTIONS\";\n    TOPIC[TOPIC[\"PRESENCE_SUBSCRIPTIONS\"] = 35] = \"PRESENCE_SUBSCRIPTIONS\";\n    TOPIC[TOPIC[\"RECORD_LISTEN_PATTERNS\"] = 36] = \"RECORD_LISTEN_PATTERNS\";\n    TOPIC[TOPIC[\"EVENT_LISTEN_PATTERNS\"] = 37] = \"EVENT_LISTEN_PATTERNS\";\n    TOPIC[TOPIC[\"RECORD_PUBLISHED_SUBSCRIPTIONS\"] = 38] = \"RECORD_PUBLISHED_SUBSCRIPTIONS\";\n    TOPIC[TOPIC[\"EVENT_PUBLISHED_SUBSCRIPTIONS\"] = 39] = \"EVENT_PUBLISHED_SUBSCRIPTIONS\";\n    TOPIC[TOPIC[\"RECORD_LISTENING\"] = 40] = \"RECORD_LISTENING\";\n    TOPIC[TOPIC[\"EVENT_LISTENING\"] = 41] = \"EVENT_LISTENING\";\n    TOPIC[TOPIC[\"STATE_REGISTRY\"] = 48] = \"STATE_REGISTRY\";\n    TOPIC[TOPIC[\"CLUSTER\"] = 49] = \"CLUSTER\";\n    TOPIC[TOPIC[\"LOCK\"] = 50] = \"LOCK\";\n})(TOPIC = exports.TOPIC || (exports.TOPIC = {}));\nvar PARSER_ACTIONS;\n(function (PARSER_ACTIONS) {\n    PARSER_ACTIONS[PARSER_ACTIONS[\"UNKNOWN_TOPIC\"] = 80] = \"UNKNOWN_TOPIC\";\n    PARSER_ACTIONS[PARSER_ACTIONS[\"UNKNOWN_ACTION\"] = 81] = \"UNKNOWN_ACTION\";\n    PARSER_ACTIONS[PARSER_ACTIONS[\"INVALID_MESSAGE\"] = 82] = \"INVALID_MESSAGE\";\n    PARSER_ACTIONS[PARSER_ACTIONS[\"MESSAGE_PARSE_ERROR\"] = 83] = \"MESSAGE_PARSE_ERROR\";\n    PARSER_ACTIONS[PARSER_ACTIONS[\"MAXIMUM_MESSAGE_SIZE_EXCEEDED\"] = 84] = \"MAXIMUM_MESSAGE_SIZE_EXCEEDED\";\n    PARSER_ACTIONS[PARSER_ACTIONS[\"ERROR\"] = 85] = \"ERROR\";\n    PARSER_ACTIONS[PARSER_ACTIONS[\"INVALID_META_PARAMS\"] = 86] = \"INVALID_META_PARAMS\";\n})(PARSER_ACTIONS = exports.PARSER_ACTIONS || (exports.PARSER_ACTIONS = {}));\nvar CONNECTION_ACTIONS;\n(function (CONNECTION_ACTIONS) {\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS[\"ERROR\"] = 0] = \"ERROR\";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS[\"PING\"] = 1] = \"PING\";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS[\"PONG\"] = 2] = \"PONG\";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS[\"ACCEPT\"] = 3] = \"ACCEPT\";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS[\"CHALLENGE\"] = 4] = \"CHALLENGE\";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS[\"REJECT\"] = 6] = \"REJECT\";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS[\"REDIRECT\"] = 7] = \"REDIRECT\";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS[\"CLOSING\"] = 8] = \"CLOSING\";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS[\"CLOSED\"] = 9] = \"CLOSED\";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS[\"AUTHENTICATION_TIMEOUT\"] = 80] = \"AUTHENTICATION_TIMEOUT\";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS[\"INVALID_MESSAGE\"] = 82] = \"INVALID_MESSAGE\";\n})(CONNECTION_ACTIONS = exports.CONNECTION_ACTIONS || (exports.CONNECTION_ACTIONS = {}));\nvar AUTH_ACTIONS;\n(function (AUTH_ACTIONS) {\n    AUTH_ACTIONS[AUTH_ACTIONS[\"ERROR\"] = 0] = \"ERROR\";\n    AUTH_ACTIONS[AUTH_ACTIONS[\"REQUEST\"] = 1] = \"REQUEST\";\n    AUTH_ACTIONS[AUTH_ACTIONS[\"AUTH_SUCCESSFUL\"] = 2] = \"AUTH_SUCCESSFUL\";\n    AUTH_ACTIONS[AUTH_ACTIONS[\"AUTH_UNSUCCESSFUL\"] = 3] = \"AUTH_UNSUCCESSFUL\";\n    AUTH_ACTIONS[AUTH_ACTIONS[\"TOO_MANY_AUTH_ATTEMPTS\"] = 80] = \"TOO_MANY_AUTH_ATTEMPTS\";\n    AUTH_ACTIONS[AUTH_ACTIONS[\"INVALID_MESSAGE\"] = 82] = \"INVALID_MESSAGE\";\n    AUTH_ACTIONS[AUTH_ACTIONS[\"INVALID_MESSAGE_DATA\"] = 98] = \"INVALID_MESSAGE_DATA\";\n})(AUTH_ACTIONS = exports.AUTH_ACTIONS || (exports.AUTH_ACTIONS = {}));\nvar EVENT_ACTIONS;\n(function (EVENT_ACTIONS) {\n    EVENT_ACTIONS[EVENT_ACTIONS[\"ERROR\"] = 0] = \"ERROR\";\n    EVENT_ACTIONS[EVENT_ACTIONS[\"EMIT\"] = 1] = \"EMIT\";\n    EVENT_ACTIONS[EVENT_ACTIONS[\"SUBSCRIBE\"] = 2] = \"SUBSCRIBE\";\n    EVENT_ACTIONS[EVENT_ACTIONS[\"SUBSCRIBE_ACK\"] = 130] = \"SUBSCRIBE_ACK\";\n    EVENT_ACTIONS[EVENT_ACTIONS[\"UNSUBSCRIBE\"] = 3] = \"UNSUBSCRIBE\";\n    EVENT_ACTIONS[EVENT_ACTIONS[\"UNSUBSCRIBE_ACK\"] = 131] = \"UNSUBSCRIBE_ACK\";\n    EVENT_ACTIONS[EVENT_ACTIONS[\"LISTEN\"] = 4] = \"LISTEN\";\n    EVENT_ACTIONS[EVENT_ACTIONS[\"LISTEN_ACK\"] = 132] = \"LISTEN_ACK\";\n    EVENT_ACTIONS[EVENT_ACTIONS[\"UNLISTEN\"] = 5] = \"UNLISTEN\";\n    EVENT_ACTIONS[EVENT_ACTIONS[\"UNLISTEN_ACK\"] = 133] = \"UNLISTEN_ACK\";\n    EVENT_ACTIONS[EVENT_ACTIONS[\"LISTEN_ACCEPT\"] = 6] = \"LISTEN_ACCEPT\";\n    EVENT_ACTIONS[EVENT_ACTIONS[\"LISTEN_REJECT\"] = 7] = \"LISTEN_REJECT\";\n    EVENT_ACTIONS[EVENT_ACTIONS[\"SUBSCRIPTION_FOR_PATTERN_FOUND\"] = 8] = \"SUBSCRIPTION_FOR_PATTERN_FOUND\";\n    EVENT_ACTIONS[EVENT_ACTIONS[\"SUBSCRIPTION_FOR_PATTERN_REMOVED\"] = 9] = \"SUBSCRIPTION_FOR_PATTERN_REMOVED\";\n    EVENT_ACTIONS[EVENT_ACTIONS[\"INVALID_LISTEN_REGEX\"] = 80] = \"INVALID_LISTEN_REGEX\";\n    EVENT_ACTIONS[EVENT_ACTIONS[\"MESSAGE_PERMISSION_ERROR\"] = 96] = \"MESSAGE_PERMISSION_ERROR\";\n    EVENT_ACTIONS[EVENT_ACTIONS[\"MESSAGE_DENIED\"] = 97] = \"MESSAGE_DENIED\";\n    EVENT_ACTIONS[EVENT_ACTIONS[\"INVALID_MESSAGE_DATA\"] = 98] = \"INVALID_MESSAGE_DATA\";\n    EVENT_ACTIONS[EVENT_ACTIONS[\"MULTIPLE_SUBSCRIPTIONS\"] = 99] = \"MULTIPLE_SUBSCRIPTIONS\";\n    EVENT_ACTIONS[EVENT_ACTIONS[\"NOT_SUBSCRIBED\"] = 100] = \"NOT_SUBSCRIBED\";\n})(EVENT_ACTIONS = exports.EVENT_ACTIONS || (exports.EVENT_ACTIONS = {}));\nvar RECORD_ACTIONS;\n(function (RECORD_ACTIONS) {\n    RECORD_ACTIONS[RECORD_ACTIONS[\"ERROR\"] = 0] = \"ERROR\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"READ\"] = 1] = \"READ\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"READ_RESPONSE\"] = 2] = \"READ_RESPONSE\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"HEAD\"] = 3] = \"HEAD\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"HEAD_RESPONSE\"] = 4] = \"HEAD_RESPONSE\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"DELETE\"] = 5] = \"DELETE\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"DELETE_SUCCESS\"] = 6] = \"DELETE_SUCCESS\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"DELETED\"] = 8] = \"DELETED\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"WRITE_ACKNOWLEDGEMENT\"] = 9] = \"WRITE_ACKNOWLEDGEMENT\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"CREATE\"] = 16] = \"CREATE\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"CREATEANDUPDATE\"] = 17] = \"CREATEANDUPDATE\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"CREATEANDUPDATE_WITH_WRITE_ACK\"] = 18] = \"CREATEANDUPDATE_WITH_WRITE_ACK\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"CREATEANDPATCH\"] = 19] = \"CREATEANDPATCH\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"CREATEANDPATCH_WITH_WRITE_ACK\"] = 20] = \"CREATEANDPATCH_WITH_WRITE_ACK\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"UPDATE\"] = 21] = \"UPDATE\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"UPDATE_WITH_WRITE_ACK\"] = 22] = \"UPDATE_WITH_WRITE_ACK\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"PATCH\"] = 23] = \"PATCH\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"PATCH_WITH_WRITE_ACK\"] = 24] = \"PATCH_WITH_WRITE_ACK\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"ERASE\"] = 25] = \"ERASE\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"ERASE_WITH_WRITE_ACK\"] = 26] = \"ERASE_WITH_WRITE_ACK\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"SUBSCRIBEANDHEAD\"] = 32] = \"SUBSCRIBEANDHEAD\";\n    // SUBSCRIBEANDHEAD_RESPONSE = 0x21,\n    RECORD_ACTIONS[RECORD_ACTIONS[\"SUBSCRIBEANDREAD\"] = 34] = \"SUBSCRIBEANDREAD\";\n    // SUBSCRIBEANDREAD_RESPONSE = 0x23,\n    RECORD_ACTIONS[RECORD_ACTIONS[\"SUBSCRIBECREATEANDREAD\"] = 36] = \"SUBSCRIBECREATEANDREAD\";\n    // SUBSCRIBECREATEANDREAD_RESPONSE = 0x25,\n    RECORD_ACTIONS[RECORD_ACTIONS[\"SUBSCRIBECREATEANDUPDATE\"] = 38] = \"SUBSCRIBECREATEANDUPDATE\";\n    // SUBSCRIBECREATEANDUPDATE_RESPONSE = 0x27,\n    RECORD_ACTIONS[RECORD_ACTIONS[\"SUBSCRIBE\"] = 40] = \"SUBSCRIBE\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"SUBSCRIBE_ACK\"] = 168] = \"SUBSCRIBE_ACK\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"UNSUBSCRIBE\"] = 41] = \"UNSUBSCRIBE\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"UNSUBSCRIBE_ACK\"] = 169] = \"UNSUBSCRIBE_ACK\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"LISTEN\"] = 48] = \"LISTEN\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"LISTEN_ACK\"] = 176] = \"LISTEN_ACK\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"UNLISTEN\"] = 49] = \"UNLISTEN\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"UNLISTEN_ACK\"] = 177] = \"UNLISTEN_ACK\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"LISTEN_ACCEPT\"] = 50] = \"LISTEN_ACCEPT\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"LISTEN_REJECT\"] = 51] = \"LISTEN_REJECT\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"SUBSCRIPTION_HAS_PROVIDER\"] = 52] = \"SUBSCRIPTION_HAS_PROVIDER\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"SUBSCRIPTION_HAS_NO_PROVIDER\"] = 53] = \"SUBSCRIPTION_HAS_NO_PROVIDER\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"SUBSCRIPTION_FOR_PATTERN_FOUND\"] = 54] = \"SUBSCRIPTION_FOR_PATTERN_FOUND\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"SUBSCRIPTION_FOR_PATTERN_REMOVED\"] = 55] = \"SUBSCRIPTION_FOR_PATTERN_REMOVED\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"CACHE_RETRIEVAL_TIMEOUT\"] = 80] = \"CACHE_RETRIEVAL_TIMEOUT\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"STORAGE_RETRIEVAL_TIMEOUT\"] = 81] = \"STORAGE_RETRIEVAL_TIMEOUT\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"VERSION_EXISTS\"] = 82] = \"VERSION_EXISTS\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"RECORD_LOAD_ERROR\"] = 83] = \"RECORD_LOAD_ERROR\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"RECORD_CREATE_ERROR\"] = 84] = \"RECORD_CREATE_ERROR\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"RECORD_UPDATE_ERROR\"] = 85] = \"RECORD_UPDATE_ERROR\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"RECORD_DELETE_ERROR\"] = 86] = \"RECORD_DELETE_ERROR\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"RECORD_NOT_FOUND\"] = 88] = \"RECORD_NOT_FOUND\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"INVALID_VERSION\"] = 89] = \"INVALID_VERSION\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"INVALID_PATCH_ON_HOTPATH\"] = 90] = \"INVALID_PATCH_ON_HOTPATH\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"INVALID_LISTEN_REGEX\"] = 91] = \"INVALID_LISTEN_REGEX\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"MESSAGE_PERMISSION_ERROR\"] = 96] = \"MESSAGE_PERMISSION_ERROR\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"MESSAGE_DENIED\"] = 97] = \"MESSAGE_DENIED\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"INVALID_MESSAGE_DATA\"] = 98] = \"INVALID_MESSAGE_DATA\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"MULTIPLE_SUBSCRIPTIONS\"] = 99] = \"MULTIPLE_SUBSCRIPTIONS\";\n    RECORD_ACTIONS[RECORD_ACTIONS[\"NOT_SUBSCRIBED\"] = 100] = \"NOT_SUBSCRIBED\";\n})(RECORD_ACTIONS = exports.RECORD_ACTIONS || (exports.RECORD_ACTIONS = {}));\nvar RPC_ACTIONS;\n(function (RPC_ACTIONS) {\n    RPC_ACTIONS[RPC_ACTIONS[\"ERROR\"] = 0] = \"ERROR\";\n    RPC_ACTIONS[RPC_ACTIONS[\"REQUEST\"] = 1] = \"REQUEST\";\n    RPC_ACTIONS[RPC_ACTIONS[\"ACCEPT\"] = 2] = \"ACCEPT\";\n    RPC_ACTIONS[RPC_ACTIONS[\"RESPONSE\"] = 3] = \"RESPONSE\";\n    RPC_ACTIONS[RPC_ACTIONS[\"REJECT\"] = 4] = \"REJECT\";\n    RPC_ACTIONS[RPC_ACTIONS[\"REQUEST_ERROR\"] = 5] = \"REQUEST_ERROR\";\n    RPC_ACTIONS[RPC_ACTIONS[\"PROVIDE\"] = 6] = \"PROVIDE\";\n    RPC_ACTIONS[RPC_ACTIONS[\"PROVIDE_ACK\"] = 134] = \"PROVIDE_ACK\";\n    RPC_ACTIONS[RPC_ACTIONS[\"UNPROVIDE\"] = 7] = \"UNPROVIDE\";\n    RPC_ACTIONS[RPC_ACTIONS[\"UNPROVIDE_ACK\"] = 135] = \"UNPROVIDE_ACK\";\n    RPC_ACTIONS[RPC_ACTIONS[\"NO_RPC_PROVIDER\"] = 80] = \"NO_RPC_PROVIDER\";\n    RPC_ACTIONS[RPC_ACTIONS[\"ACCEPT_TIMEOUT\"] = 82] = \"ACCEPT_TIMEOUT\";\n    RPC_ACTIONS[RPC_ACTIONS[\"MULTIPLE_ACCEPT\"] = 83] = \"MULTIPLE_ACCEPT\";\n    RPC_ACTIONS[RPC_ACTIONS[\"INVALID_RPC_CORRELATION_ID\"] = 84] = \"INVALID_RPC_CORRELATION_ID\";\n    RPC_ACTIONS[RPC_ACTIONS[\"RESPONSE_TIMEOUT\"] = 85] = \"RESPONSE_TIMEOUT\";\n    RPC_ACTIONS[RPC_ACTIONS[\"MULTIPLE_RESPONSE\"] = 86] = \"MULTIPLE_RESPONSE\";\n    RPC_ACTIONS[RPC_ACTIONS[\"MESSAGE_PERMISSION_ERROR\"] = 96] = \"MESSAGE_PERMISSION_ERROR\";\n    RPC_ACTIONS[RPC_ACTIONS[\"MESSAGE_DENIED\"] = 97] = \"MESSAGE_DENIED\";\n    RPC_ACTIONS[RPC_ACTIONS[\"INVALID_MESSAGE_DATA\"] = 98] = \"INVALID_MESSAGE_DATA\";\n    RPC_ACTIONS[RPC_ACTIONS[\"MULTIPLE_PROVIDERS\"] = 99] = \"MULTIPLE_PROVIDERS\";\n    RPC_ACTIONS[RPC_ACTIONS[\"NOT_PROVIDED\"] = 100] = \"NOT_PROVIDED\";\n})(RPC_ACTIONS = exports.RPC_ACTIONS || (exports.RPC_ACTIONS = {}));\nvar PRESENCE_ACTIONS;\n(function (PRESENCE_ACTIONS) {\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"ERROR\"] = 0] = \"ERROR\";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"QUERY_ALL\"] = 1] = \"QUERY_ALL\";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"QUERY_ALL_RESPONSE\"] = 2] = \"QUERY_ALL_RESPONSE\";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"QUERY\"] = 3] = \"QUERY\";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"QUERY_RESPONSE\"] = 4] = \"QUERY_RESPONSE\";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"PRESENCE_JOIN\"] = 5] = \"PRESENCE_JOIN\";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"PRESENCE_JOIN_ALL\"] = 6] = \"PRESENCE_JOIN_ALL\";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"PRESENCE_LEAVE\"] = 7] = \"PRESENCE_LEAVE\";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"PRESENCE_LEAVE_ALL\"] = 8] = \"PRESENCE_LEAVE_ALL\";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"SUBSCRIBE\"] = 9] = \"SUBSCRIBE\";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"SUBSCRIBE_ACK\"] = 137] = \"SUBSCRIBE_ACK\";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"UNSUBSCRIBE\"] = 10] = \"UNSUBSCRIBE\";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"UNSUBSCRIBE_ACK\"] = 138] = \"UNSUBSCRIBE_ACK\";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"SUBSCRIBE_ALL\"] = 11] = \"SUBSCRIBE_ALL\";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"SUBSCRIBE_ALL_ACK\"] = 139] = \"SUBSCRIBE_ALL_ACK\";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"UNSUBSCRIBE_ALL\"] = 12] = \"UNSUBSCRIBE_ALL\";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"UNSUBSCRIBE_ALL_ACK\"] = 140] = \"UNSUBSCRIBE_ALL_ACK\";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"INVALID_PRESENCE_USERS\"] = 80] = \"INVALID_PRESENCE_USERS\";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"MESSAGE_PERMISSION_ERROR\"] = 96] = \"MESSAGE_PERMISSION_ERROR\";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"MESSAGE_DENIED\"] = 97] = \"MESSAGE_DENIED\";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"MULTIPLE_SUBSCRIPTIONS\"] = 99] = \"MULTIPLE_SUBSCRIPTIONS\";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS[\"NOT_SUBSCRIBED\"] = 100] = \"NOT_SUBSCRIBED\";\n})(PRESENCE_ACTIONS = exports.PRESENCE_ACTIONS || (exports.PRESENCE_ACTIONS = {}));\nvar LOCK_ACTIONS;\n(function (LOCK_ACTIONS) {\n    LOCK_ACTIONS[LOCK_ACTIONS[\"ERROR\"] = 0] = \"ERROR\";\n    LOCK_ACTIONS[LOCK_ACTIONS[\"REQUEST\"] = 1] = \"REQUEST\";\n    LOCK_ACTIONS[LOCK_ACTIONS[\"RESPONSE\"] = 2] = \"RESPONSE\";\n    LOCK_ACTIONS[LOCK_ACTIONS[\"RELEASE\"] = 3] = \"RELEASE\";\n})(LOCK_ACTIONS = exports.LOCK_ACTIONS || (exports.LOCK_ACTIONS = {}));\nvar STATE_ACTIONS;\n(function (STATE_ACTIONS) {\n    STATE_ACTIONS[STATE_ACTIONS[\"ERROR\"] = 0] = \"ERROR\";\n    STATE_ACTIONS[STATE_ACTIONS[\"ADD\"] = 1] = \"ADD\";\n    STATE_ACTIONS[STATE_ACTIONS[\"REMOVE\"] = 2] = \"REMOVE\";\n    STATE_ACTIONS[STATE_ACTIONS[\"REQUEST_FULL_STATE\"] = 3] = \"REQUEST_FULL_STATE\";\n    STATE_ACTIONS[STATE_ACTIONS[\"FULL_STATE\"] = 4] = \"FULL_STATE\";\n})(STATE_ACTIONS = exports.STATE_ACTIONS || (exports.STATE_ACTIONS = {}));\nvar CLUSTER_ACTIONS;\n(function (CLUSTER_ACTIONS) {\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS[\"PING\"] = 0] = \"PING\";\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS[\"PONG\"] = 1] = \"PONG\";\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS[\"CLOSE\"] = 2] = \"CLOSE\";\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS[\"REJECT\"] = 3] = \"REJECT\";\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS[\"REJECT_DUPLICATE\"] = 4] = \"REJECT_DUPLICATE\";\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS[\"IDENTIFICATION_REQUEST\"] = 5] = \"IDENTIFICATION_REQUEST\";\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS[\"IDENTIFICATION_RESPONSE\"] = 6] = \"IDENTIFICATION_RESPONSE\";\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS[\"KNOWN_PEERS\"] = 7] = \"KNOWN_PEERS\";\n})(CLUSTER_ACTIONS = exports.CLUSTER_ACTIONS || (exports.CLUSTER_ACTIONS = {}));\nexports.ACTIONS = {\n    [TOPIC.PARSER]: PARSER_ACTIONS,\n    [TOPIC.CONNECTION]: CONNECTION_ACTIONS,\n    [TOPIC.AUTH]: AUTH_ACTIONS,\n    [TOPIC.EVENT]: EVENT_ACTIONS,\n    [TOPIC.RECORD]: RECORD_ACTIONS,\n    [TOPIC.RPC]: RPC_ACTIONS,\n    [TOPIC.PRESENCE]: PRESENCE_ACTIONS,\n    [TOPIC.LOCK]: LOCK_ACTIONS,\n    [TOPIC.STATE_REGISTRY]: STATE_ACTIONS,\n    [TOPIC.CLUSTER]: CLUSTER_ACTIONS\n};\nvar EVENT;\n(function (EVENT) {\n    EVENT[\"INFO\"] = \"INFO\";\n    EVENT[\"DEPRECATED\"] = \"DEPRECATED\";\n    EVENT[\"INCOMING_CONNECTION\"] = \"INCOMING_CONNECTION\";\n    EVENT[\"CLOSED_SOCKET_INTERACTION\"] = \"CLOSED_SOCKET_INTERACTION\";\n    EVENT[\"CLIENT_DISCONNECTED\"] = \"CLIENT_DISCONNECTED\";\n    EVENT[\"CONNECTION_ERROR\"] = \"CONNECTION_ERROR\";\n    EVENT[\"AUTH_ERROR\"] = \"AUTH_ERROR\";\n    EVENT[\"PLUGIN_ERROR\"] = \"PLUGIN_ERROR\";\n    EVENT[\"PLUGIN_INITIALIZATION_ERROR\"] = \"PLUGIN_INITIALIZATION_ERROR\";\n    EVENT[\"PLUGIN_INITIALIZATION_TIMEOUT\"] = \"PLUGIN_INITIALIZATION_TIMEOUT\";\n    EVENT[\"TIMEOUT\"] = \"TIMEOUT\";\n    EVENT[\"LEADING_LISTEN\"] = \"LEADING_LISTEN\";\n    EVENT[\"LOCAL_LISTEN\"] = \"LOCAL_LISTEN\";\n    EVENT[\"INVALID_CONFIG_DATA\"] = \"INVALID_CONFIG_DATA\";\n    EVENT[\"INVALID_STATE_TRANSITION\"] = \"INVALID_STATE_TRANSITION\";\n    EVENT[\"INVALID_LEADER_REQUEST\"] = \"INVALID_LEADER_REQUEST\";\n})(EVENT = exports.EVENT || (exports.EVENT = {}));\n\n\n//# sourceURL=webpack://deepstream/./binary-protocol/src/message-constants.ts?");

/***/ }),

/***/ "./binary-protocol/src/message-parser.ts":
/*!***********************************************!*\
  !*** ./binary-protocol/src/message-parser.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n/* tslint:disable:no-bitwise */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ./message-constants */ \"./binary-protocol/src/message-constants.ts\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"./binary-protocol/src/constants.ts\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./binary-protocol/src/utils.ts\");\nconst message_validator_1 = __webpack_require__(/*! ./message-validator */ \"./binary-protocol/src/message-validator.ts\");\nfunction isError(message) {\n    return (message.action >= 0x50 && message.action < 0x70) || message.topic === message_constants_1.TOPIC.PARSER;\n}\nexports.isError = isError;\nfunction parse(buffer, queue = []) {\n    let offset = 0;\n    const messages = [];\n    do {\n        const { bytesConsumed, rawMessage } = readBinary(buffer, offset);\n        if (!rawMessage) {\n            break;\n        }\n        queue.push(rawMessage);\n        offset += bytesConsumed;\n        if (rawMessage.fin) {\n            const joinedMessage = joinMessages(queue);\n            const message = parseMessage(joinedMessage);\n            queue.length = 0;\n            messages.push(message);\n        }\n    } while (offset < buffer.length);\n    return messages;\n}\nexports.parse = parse;\nfunction parseData(message) {\n    if (message.parsedData !== undefined || message.data === undefined) {\n        return true;\n    }\n    if (message.payloadEncoding && message.payloadEncoding !== message_constants_1.PAYLOAD_ENCODING.JSON) {\n        return new Error(`unable to parse data of type '${message.payloadEncoding}'`);\n    }\n    if (typeof message.data === 'string') {\n        return new Error('tried to parse string data with binary parser');\n    }\n    message.parsedData = parseJSON(message.data);\n    if (message.parsedData === undefined) {\n        return new Error(`unable to parse data ${message.data}`);\n    }\n    return true;\n}\nexports.parseData = parseData;\nfunction readBinary(buff, offset) {\n    if (buff.length < (offset + constants_1.HEADER_LENGTH)) {\n        return { bytesConsumed: 0 };\n    }\n    const fin = !!(buff[offset] & 0x80);\n    const topic = buff[offset] & 0x7F;\n    const action = buff[offset + 1];\n    const metaLength = buff.readUIntBE(offset + 2, 3);\n    const payloadLength = buff.readUIntBE(offset + 5, 3);\n    const messageLength = constants_1.HEADER_LENGTH + metaLength + payloadLength;\n    if (buff.length < (offset + messageLength)) {\n        return { bytesConsumed: 0 };\n    }\n    const rawHeader = buff.slice(offset, offset + constants_1.HEADER_LENGTH);\n    const rawMessage = { fin, topic, action, rawHeader };\n    if (metaLength > 0) {\n        rawMessage.meta = buff.slice(offset + constants_1.HEADER_LENGTH, offset + constants_1.HEADER_LENGTH + metaLength);\n    }\n    if (payloadLength > 0) {\n        rawMessage.payload = buff.slice(offset + constants_1.HEADER_LENGTH + metaLength, offset + messageLength);\n    }\n    return {\n        bytesConsumed: messageLength,\n        rawMessage,\n    };\n}\nfunction joinMessages(rawMessages) {\n    if (rawMessages.length === 0) {\n        throw new Error('parseMessage must not be called with an empty message queue');\n    }\n    if (rawMessages.length === 1) {\n        return rawMessages[0];\n    }\n    const { topic, action, rawHeader } = rawMessages[0];\n    const payloadSections = [];\n    const metaSections = [];\n    rawMessages.forEach(({ payload: payloadSection, meta: metaSection }) => {\n        if (payloadSection) {\n            payloadSections.push(payloadSection);\n        }\n        if (metaSection) {\n            metaSections.push(metaSection);\n        }\n    });\n    const payload = Buffer.concat(payloadSections);\n    const meta = Buffer.concat(metaSections);\n    return { fin: true, topic, action, rawHeader, meta, payload };\n}\nfunction parseMessage(rawMessage) {\n    const { topic: rawTopic, action: rawAction, rawHeader } = rawMessage;\n    if (message_constants_1.TOPIC[rawTopic] === undefined) {\n        return {\n            parseError: true,\n            action: message_constants_1.PARSER_ACTIONS.UNKNOWN_TOPIC,\n            parsedMessage: {\n                topic: rawTopic,\n                action: rawAction\n            },\n            description: `unknown topic ${rawTopic}`,\n            raw: rawHeader\n        };\n    }\n    const topic = rawTopic;\n    if (message_constants_1.ACTIONS[topic][rawAction] === undefined) {\n        return {\n            parseError: true,\n            action: message_constants_1.PARSER_ACTIONS.UNKNOWN_ACTION,\n            parsedMessage: {\n                topic,\n                action: rawAction\n            },\n            description: `unknown ${message_constants_1.TOPIC[topic]} action ${rawAction}`,\n            raw: rawHeader\n        };\n    }\n    // mask out uppermost bit(ACK)\n    const action = rawAction & 0x7F;\n    const message = { topic, action };\n    if (rawMessage.meta && rawMessage.meta.length > 0) {\n        const meta = parseJSON(rawMessage.meta);\n        if (!meta || typeof meta !== 'object') {\n            return {\n                parseError: true,\n                action: message_constants_1.PARSER_ACTIONS.MESSAGE_PARSE_ERROR,\n                parsedMessage: message,\n                description: `invalid meta field ${rawMessage.meta.toString()}`,\n                raw: rawHeader\n            };\n        }\n        const metaError = message_validator_1.validateMeta(topic, rawAction, meta);\n        if (metaError) {\n            throw new Error(`invalid meta ${message_constants_1.TOPIC[message.topic]} ${message_constants_1.ACTIONS[message.topic][message.action]}: ${metaError}`);\n            // return {\n            //   parseError: true,\n            //   action: PARSER_ACTIONS.INVALID_META_PARAMS,\n            //   parsedMessage: message,\n            //   description: 'invalid ack'\n            // }\n        }\n        addMetadataToMessage(meta, message);\n    }\n    if (rawMessage.payload !== undefined) {\n        if (!message_validator_1.hasPayload(message.topic, rawAction)) {\n            return {\n                parseError: true,\n                action: message_constants_1.PARSER_ACTIONS.INVALID_MESSAGE,\n                parsedMessage: message,\n                description: 'should not have a payload'\n            };\n        }\n        if (!message.payloadEncoding && topic === message_constants_1.TOPIC.PARSER) {\n            message.payloadEncoding = message_constants_1.PAYLOAD_ENCODING.BINARY;\n        }\n        message.data = rawMessage.payload;\n    }\n    // if (rawMessage.payload && rawMessage.payload.length > 0) {\n    //   const payload = parseJSON(rawMessage.payload)\n    //   if (payload === undefined) {\n    //     return {\n    //       parseError: true,\n    //       description: `invalid message data ${rawMessage.payload.toString()}`,\n    //       parsedMessage: message,\n    //       raw: rawHeader\n    //     }\n    //   }\n    //   message.data = payload\n    // }\n    message.isAck = rawAction >= 0x80;\n    message.isError = isError(message);\n    if (message.topic === message_constants_1.TOPIC.RECORD && utils_1.isWriteAck(rawAction)) {\n        message.isWriteAck = true;\n    }\n    return message;\n}\nfunction addMetadataToMessage(meta, message) {\n    for (const key in message_constants_1.META_KEYS) {\n        const value = meta[message_constants_1.META_KEYS[key]];\n        if (value !== undefined) {\n            message[key] = value;\n        }\n    }\n}\nfunction parseJSON(buff) {\n    try {\n        return JSON.parse(buff.toString());\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nexports.parseJSON = parseJSON;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://deepstream/./binary-protocol/src/message-parser.ts?");

/***/ }),

/***/ "./binary-protocol/src/message-validator.ts":
/*!**************************************************!*\
  !*** ./binary-protocol/src/message-validator.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ./message-constants */ \"./binary-protocol/src/message-constants.ts\");\n/*\n * Specification of  fields within Meta Params used for message validation\n * (see `validateMeta`)\n *\n * META_PARAMS_SPEC[topic][action] => [required, optional]\n * The keys in `required` must be present in all instances of the message\n * The keys in `optional` may be present in some instances of the message\n */\nexports.META_PARAMS_SPEC = {\n    [message_constants_1.TOPIC.PARSER]: {\n        [message_constants_1.PARSER_ACTIONS.UNKNOWN_TOPIC]: [[message_constants_1.META_KEYS.originalTopic], []],\n        [message_constants_1.PARSER_ACTIONS.UNKNOWN_ACTION]: [[message_constants_1.META_KEYS.originalTopic, message_constants_1.META_KEYS.originalAction], []],\n        [message_constants_1.PARSER_ACTIONS.INVALID_MESSAGE]: [[], []],\n        [message_constants_1.PARSER_ACTIONS.INVALID_META_PARAMS]: [[message_constants_1.META_KEYS.originalTopic, message_constants_1.META_KEYS.originalAction], []],\n    },\n    [message_constants_1.TOPIC.CONNECTION]: {\n        [message_constants_1.CONNECTION_ACTIONS.PING]: [[], []],\n        [message_constants_1.CONNECTION_ACTIONS.PONG]: [[], []],\n        [message_constants_1.CONNECTION_ACTIONS.CHALLENGE]: [[message_constants_1.META_KEYS.url, message_constants_1.META_KEYS.protocolVersion], []],\n        [message_constants_1.CONNECTION_ACTIONS.ACCEPT]: [[], []],\n        [message_constants_1.CONNECTION_ACTIONS.REJECT]: [[], []],\n        [message_constants_1.CONNECTION_ACTIONS.REDIRECT]: [[message_constants_1.META_KEYS.url], []],\n        [message_constants_1.CONNECTION_ACTIONS.CLOSING]: [[], []],\n        [message_constants_1.CONNECTION_ACTIONS.CLOSED]: [[], []],\n        [message_constants_1.CONNECTION_ACTIONS.ERROR]: [[], []],\n        [message_constants_1.CONNECTION_ACTIONS.AUTHENTICATION_TIMEOUT]: [[], []],\n        [message_constants_1.CONNECTION_ACTIONS.INVALID_MESSAGE]: [[message_constants_1.META_KEYS.originalTopic, message_constants_1.META_KEYS.originalAction], []],\n    },\n    [message_constants_1.TOPIC.AUTH]: {\n        [message_constants_1.AUTH_ACTIONS.REQUEST]: [[], []],\n        [message_constants_1.AUTH_ACTIONS.AUTH_SUCCESSFUL]: [[], []],\n        [message_constants_1.AUTH_ACTIONS.AUTH_UNSUCCESSFUL]: [[], []],\n        [message_constants_1.AUTH_ACTIONS.TOO_MANY_AUTH_ATTEMPTS]: [[], []],\n        [message_constants_1.AUTH_ACTIONS.INVALID_MESSAGE]: [[message_constants_1.META_KEYS.originalTopic, message_constants_1.META_KEYS.originalAction], []],\n        [message_constants_1.AUTH_ACTIONS.INVALID_MESSAGE_DATA]: [[message_constants_1.META_KEYS.originalAction], []],\n    },\n    [message_constants_1.TOPIC.RECORD]: {\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBE]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBE_ACK]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE_ACK]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.MULTIPLE_SUBSCRIPTIONS]: [[message_constants_1.META_KEYS.name], [message_constants_1.META_KEYS.originalAction]],\n        [message_constants_1.RECORD_ACTIONS.NOT_SUBSCRIBED]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.HEAD]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.HEAD_RESPONSE]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version], []],\n        [message_constants_1.RECORD_ACTIONS.READ]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDREAD]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.READ_RESPONSE]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version], []],\n        [message_constants_1.RECORD_ACTIONS.UPDATE]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version], []],\n        [message_constants_1.RECORD_ACTIONS.UPDATE_WITH_WRITE_ACK]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RECORD_ACTIONS.PATCH]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.path], []],\n        [message_constants_1.RECORD_ACTIONS.PATCH_WITH_WRITE_ACK]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.path, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RECORD_ACTIONS.ERASE]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.path], []],\n        [message_constants_1.RECORD_ACTIONS.ERASE_WITH_WRITE_ACK]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.path, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDUPDATE]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version], []],\n        [message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE_WITH_WRITE_ACK]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RECORD_ACTIONS.CREATEANDPATCH]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.path], []],\n        [message_constants_1.RECORD_ACTIONS.CREATEANDPATCH_WITH_WRITE_ACK]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.path, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RECORD_ACTIONS.DELETE]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.DELETE_SUCCESS]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.DELETED]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_PROVIDER]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_NO_PROVIDER]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.WRITE_ACKNOWLEDGEMENT]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RECORD_ACTIONS.VERSION_EXISTS]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version], [message_constants_1.META_KEYS.originalAction]],\n        [message_constants_1.RECORD_ACTIONS.CACHE_RETRIEVAL_TIMEOUT]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.STORAGE_RETRIEVAL_TIMEOUT]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.RECORD_LOAD_ERROR]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.RECORD_CREATE_ERROR]: [[message_constants_1.META_KEYS.name], [message_constants_1.META_KEYS.correlationId, message_constants_1.META_KEYS.originalAction]],\n        [message_constants_1.RECORD_ACTIONS.RECORD_UPDATE_ERROR]: [[message_constants_1.META_KEYS.name], [message_constants_1.META_KEYS.correlationId, message_constants_1.META_KEYS.originalAction]],\n        [message_constants_1.RECORD_ACTIONS.RECORD_DELETE_ERROR]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.RECORD_NOT_FOUND]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.originalAction], []],\n        [message_constants_1.RECORD_ACTIONS.INVALID_VERSION]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.originalAction], [message_constants_1.META_KEYS.correlationId]],\n        [message_constants_1.RECORD_ACTIONS.INVALID_PATCH_ON_HOTPATH]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.originalAction], [message_constants_1.META_KEYS.correlationId]],\n        [message_constants_1.RECORD_ACTIONS.LISTEN]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.LISTEN_ACK]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.UNLISTEN]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.UNLISTEN_ACK]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_FOR_PATTERN_FOUND]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_FOR_PATTERN_REMOVED]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        [message_constants_1.RECORD_ACTIONS.LISTEN_ACCEPT]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        [message_constants_1.RECORD_ACTIONS.LISTEN_REJECT]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        [message_constants_1.RECORD_ACTIONS.INVALID_LISTEN_REGEX]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.MESSAGE_PERMISSION_ERROR]: [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], [message_constants_1.META_KEYS.correlationId]],\n        [message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED]: [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], [message_constants_1.META_KEYS.correlationId]],\n        [message_constants_1.RECORD_ACTIONS.INVALID_MESSAGE_DATA]: [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], [message_constants_1.META_KEYS.correlationId]],\n    },\n    [message_constants_1.TOPIC.RPC]: {\n        [message_constants_1.RPC_ACTIONS.REQUEST_ERROR]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], [message_constants_1.META_KEYS.reason]],\n        [message_constants_1.RPC_ACTIONS.REQUEST]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], [message_constants_1.META_KEYS.requestorName, message_constants_1.META_KEYS.requestorData, message_constants_1.META_KEYS.trustedSender]],\n        [message_constants_1.RPC_ACTIONS.ACCEPT]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RPC_ACTIONS.REJECT]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RPC_ACTIONS.RESPONSE]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RPC_ACTIONS.PROVIDE]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RPC_ACTIONS.PROVIDE_ACK]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RPC_ACTIONS.UNPROVIDE]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RPC_ACTIONS.UNPROVIDE_ACK]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RPC_ACTIONS.MULTIPLE_PROVIDERS]: [[message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RPC_ACTIONS.NOT_PROVIDED]: [[message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RPC_ACTIONS.MULTIPLE_RESPONSE]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RPC_ACTIONS.RESPONSE_TIMEOUT]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RPC_ACTIONS.INVALID_RPC_CORRELATION_ID]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId, message_constants_1.META_KEYS.originalAction], []],\n        [message_constants_1.RPC_ACTIONS.MULTIPLE_ACCEPT]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RPC_ACTIONS.ACCEPT_TIMEOUT]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RPC_ACTIONS.NO_RPC_PROVIDER]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RPC_ACTIONS.MESSAGE_PERMISSION_ERROR]: [[message_constants_1.META_KEYS.originalAction], [message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId]],\n        [message_constants_1.RPC_ACTIONS.MESSAGE_DENIED]: [[message_constants_1.META_KEYS.originalAction], [message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId]],\n        [message_constants_1.RPC_ACTIONS.INVALID_MESSAGE_DATA]: [[message_constants_1.META_KEYS.originalAction], [message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId]],\n    },\n    [message_constants_1.TOPIC.EVENT]: {\n        [message_constants_1.EVENT_ACTIONS.EMIT]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.SUBSCRIBE]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.SUBSCRIBE_ACK]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.UNSUBSCRIBE]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.UNSUBSCRIBE_ACK]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.MULTIPLE_SUBSCRIPTIONS]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.NOT_SUBSCRIBED]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.MESSAGE_PERMISSION_ERROR]: [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.MESSAGE_DENIED]: [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.LISTEN]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.LISTEN_ACK]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.UNLISTEN]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.UNLISTEN_ACK]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.SUBSCRIPTION_FOR_PATTERN_FOUND]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        [message_constants_1.EVENT_ACTIONS.SUBSCRIPTION_FOR_PATTERN_REMOVED]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        [message_constants_1.EVENT_ACTIONS.LISTEN_ACCEPT]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        [message_constants_1.EVENT_ACTIONS.LISTEN_REJECT]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        [message_constants_1.EVENT_ACTIONS.INVALID_LISTEN_REGEX]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.MESSAGE_PERMISSION_ERROR]: [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.MESSAGE_DENIED]: [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.INVALID_MESSAGE_DATA]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.originalAction], []],\n    },\n    [message_constants_1.TOPIC.PRESENCE]: {\n        [message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE]: [[message_constants_1.META_KEYS.correlationId, message_constants_1.META_KEYS.names], []],\n        [message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE_ACK]: [[message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE_ALL]: [[], []],\n        [message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE_ALL_ACK]: [[], []],\n        [message_constants_1.PRESENCE_ACTIONS.UNSUBSCRIBE]: [[message_constants_1.META_KEYS.correlationId, message_constants_1.META_KEYS.names], []],\n        [message_constants_1.PRESENCE_ACTIONS.UNSUBSCRIBE_ACK]: [[message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.PRESENCE_ACTIONS.UNSUBSCRIBE_ALL]: [[message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.PRESENCE_ACTIONS.UNSUBSCRIBE_ALL_ACK]: [[message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.PRESENCE_ACTIONS.NOT_SUBSCRIBED]: [[], [message_constants_1.META_KEYS.correlationId]],\n        [message_constants_1.PRESENCE_ACTIONS.MULTIPLE_SUBSCRIPTIONS]: [[], [message_constants_1.META_KEYS.correlationId, message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.originalAction]],\n        [message_constants_1.PRESENCE_ACTIONS.QUERY]: [[message_constants_1.META_KEYS.correlationId, message_constants_1.META_KEYS.names], []],\n        [message_constants_1.PRESENCE_ACTIONS.QUERY_RESPONSE]: [[message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.PRESENCE_ACTIONS.QUERY_ALL]: [[], []],\n        [message_constants_1.PRESENCE_ACTIONS.QUERY_ALL_RESPONSE]: [[message_constants_1.META_KEYS.names], []],\n        [message_constants_1.PRESENCE_ACTIONS.PRESENCE_JOIN]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.PRESENCE_ACTIONS.PRESENCE_LEAVE]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.PRESENCE_ACTIONS.PRESENCE_JOIN_ALL]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.PRESENCE_ACTIONS.PRESENCE_LEAVE_ALL]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.PRESENCE_ACTIONS.INVALID_PRESENCE_USERS]: [[], []],\n        [message_constants_1.PRESENCE_ACTIONS.MESSAGE_PERMISSION_ERROR]: [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], [message_constants_1.META_KEYS.correlationId]],\n        [message_constants_1.PRESENCE_ACTIONS.MESSAGE_DENIED]: [[message_constants_1.META_KEYS.originalAction], [message_constants_1.META_KEYS.correlationId, message_constants_1.META_KEYS.name]],\n    },\n    [message_constants_1.TOPIC.CLUSTER]: {\n        [message_constants_1.CLUSTER_ACTIONS.CLOSE]: [[], []],\n        [message_constants_1.CLUSTER_ACTIONS.IDENTIFICATION_REQUEST]: [[], []],\n        [message_constants_1.CLUSTER_ACTIONS.IDENTIFICATION_RESPONSE]: [[], []],\n        [message_constants_1.CLUSTER_ACTIONS.KNOWN_PEERS]: [[], []],\n        [message_constants_1.CLUSTER_ACTIONS.PING]: [[], []],\n        [message_constants_1.CLUSTER_ACTIONS.PONG]: [[], []],\n        [message_constants_1.CLUSTER_ACTIONS.REJECT]: [[], []],\n        [message_constants_1.CLUSTER_ACTIONS.REJECT_DUPLICATE]: [[], []]\n    },\n    [message_constants_1.TOPIC.STATE_REGISTRY]: {\n        [message_constants_1.STATE_ACTIONS.ERROR]: [[message_constants_1.META_KEYS.registryTopic], []],\n        [message_constants_1.STATE_ACTIONS.ADD]: [[message_constants_1.META_KEYS.registryTopic], []],\n        [message_constants_1.STATE_ACTIONS.REMOVE]: [[message_constants_1.META_KEYS.registryTopic], []],\n        [message_constants_1.STATE_ACTIONS.REQUEST_FULL_STATE]: [[message_constants_1.META_KEYS.registryTopic], []],\n        [message_constants_1.STATE_ACTIONS.FULL_STATE]: [[message_constants_1.META_KEYS.registryTopic], []]\n    },\n    [message_constants_1.TOPIC.LOCK]: {}\n};\nconst payloadMap = {\n    [message_constants_1.TOPIC.PARSER]: [\n        message_constants_1.PARSER_ACTIONS.MESSAGE_PARSE_ERROR,\n        message_constants_1.PARSER_ACTIONS.INVALID_META_PARAMS,\n    ],\n    [message_constants_1.TOPIC.AUTH]: [\n        message_constants_1.AUTH_ACTIONS.REQUEST,\n        message_constants_1.AUTH_ACTIONS.AUTH_SUCCESSFUL,\n        message_constants_1.AUTH_ACTIONS.AUTH_UNSUCCESSFUL,\n    ],\n    [message_constants_1.TOPIC.RECORD]: [\n        message_constants_1.RECORD_ACTIONS.READ_RESPONSE,\n        message_constants_1.RECORD_ACTIONS.UPDATE,\n        message_constants_1.RECORD_ACTIONS.UPDATE_WITH_WRITE_ACK,\n        message_constants_1.RECORD_ACTIONS.PATCH,\n        message_constants_1.RECORD_ACTIONS.PATCH_WITH_WRITE_ACK,\n        message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE,\n        message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE_WITH_WRITE_ACK,\n        message_constants_1.RECORD_ACTIONS.CREATEANDPATCH,\n        message_constants_1.RECORD_ACTIONS.CREATEANDPATCH_WITH_WRITE_ACK,\n        message_constants_1.RECORD_ACTIONS.VERSION_EXISTS,\n    ],\n    [message_constants_1.TOPIC.RPC]: [\n        message_constants_1.RPC_ACTIONS.REQUEST,\n        message_constants_1.RPC_ACTIONS.RESPONSE,\n        message_constants_1.RPC_ACTIONS.REQUEST_ERROR\n    ],\n    [message_constants_1.TOPIC.EVENT]: [\n        message_constants_1.EVENT_ACTIONS.EMIT,\n    ],\n    [message_constants_1.TOPIC.PRESENCE]: [\n        message_constants_1.PRESENCE_ACTIONS.QUERY_RESPONSE,\n    ],\n    [message_constants_1.TOPIC.CLUSTER]: [\n        message_constants_1.CLUSTER_ACTIONS.IDENTIFICATION_REQUEST,\n        message_constants_1.CLUSTER_ACTIONS.IDENTIFICATION_RESPONSE,\n        message_constants_1.CLUSTER_ACTIONS.KNOWN_PEERS\n    ],\n    [message_constants_1.TOPIC.STATE_REGISTRY]: [\n        message_constants_1.STATE_ACTIONS.FULL_STATE\n    ],\n    [message_constants_1.TOPIC.LOCK]: []\n};\nfunction mapOfArraysHas(map, topic, action) {\n    const actions = map[topic];\n    if (!actions) {\n        return false;\n    }\n    return actions.indexOf(action) !== -1;\n}\nexports.hasPayload = (topic, action) => mapOfArraysHas(payloadMap, topic, action);\nfunction validateUnkownMeta(topic, action, meta) {\n    const spec = exports.META_PARAMS_SPEC[topic][action];\n    if (!spec) {\n        return 'no meta spec';\n    }\n    const [required, optional] = spec;\n    for (const key in meta) {\n        if (meta[key] !== undefined\n            && required.indexOf(key) === -1\n            && optional.indexOf(key) === -1) {\n            return `meta object has unknown key ${key}`;\n        }\n    }\n    return;\n}\nexports.validateUnkownMeta = validateUnkownMeta;\nfunction validateMeta(topic, action, meta) {\n    const spec = exports.META_PARAMS_SPEC[topic][action];\n    if (!spec) {\n        return 'no meta spec';\n    }\n    const [required,] = spec;\n    for (const req of required) {\n        if (meta[req] === undefined) {\n            return `meta object does not have required key ${req}`;\n        }\n    }\n    return;\n}\nexports.validateMeta = validateMeta;\nfunction hasCorrelationId(topic, action) {\n    const spec = exports.META_PARAMS_SPEC[topic][action];\n    if (!spec) {\n        return;\n    }\n    const [required, optional] = spec;\n    return (required.indexOf(message_constants_1.META_KEYS.correlationId) !== -1) || (optional.indexOf(message_constants_1.META_KEYS.correlationId) !== -1);\n}\nexports.hasCorrelationId = hasCorrelationId;\n\n\n//# sourceURL=webpack://deepstream/./binary-protocol/src/message-validator.ts?");

/***/ }),

/***/ "./binary-protocol/src/utils.ts":
/*!**************************************!*\
  !*** ./binary-protocol/src/utils.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ./message-constants */ \"./binary-protocol/src/message-constants.ts\");\nfunction isWriteAck(action) {\n    return action === message_constants_1.RECORD_ACTIONS.CREATEANDPATCH_WITH_WRITE_ACK\n        || action === message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE_WITH_WRITE_ACK\n        || action === message_constants_1.RECORD_ACTIONS.PATCH_WITH_WRITE_ACK\n        || action === message_constants_1.RECORD_ACTIONS.UPDATE_WITH_WRITE_ACK\n        || action === message_constants_1.RECORD_ACTIONS.ERASE_WITH_WRITE_ACK\n        || action === message_constants_1.RECORD_ACTIONS.WRITE_ACKNOWLEDGEMENT;\n}\nexports.isWriteAck = isWriteAck;\nexports.ACTION_TO_WRITE_ACK = {\n    [message_constants_1.RECORD_ACTIONS.CREATEANDPATCH]: message_constants_1.RECORD_ACTIONS.CREATEANDPATCH_WITH_WRITE_ACK,\n    [message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE]: message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE_WITH_WRITE_ACK,\n    [message_constants_1.RECORD_ACTIONS.PATCH]: message_constants_1.RECORD_ACTIONS.PATCH_WITH_WRITE_ACK,\n    [message_constants_1.RECORD_ACTIONS.UPDATE]: message_constants_1.RECORD_ACTIONS.UPDATE_WITH_WRITE_ACK,\n    [message_constants_1.RECORD_ACTIONS.ERASE]: message_constants_1.RECORD_ACTIONS.ERASE_WITH_WRITE_ACK,\n};\n/**\n * Like reverseMap but the values will be cast using Number(k)\n */\nfunction reverseMapNumeric(map) {\n    const reversedMap = {};\n    for (const key in map) {\n        reversedMap[map[key]] = Number(key);\n    }\n    return reversedMap;\n}\nexports.reverseMapNumeric = reverseMapNumeric;\nexports.WRITE_ACK_TO_ACTION = reverseMapNumeric(exports.ACTION_TO_WRITE_ACK);\nexports.RESPONSE_TO_REQUEST = {\n    [message_constants_1.TOPIC.RECORD]: {\n        [message_constants_1.RECORD_ACTIONS.HEAD_RESPONSE]: message_constants_1.RECORD_ACTIONS.HEAD,\n        [message_constants_1.RECORD_ACTIONS.READ_RESPONSE]: message_constants_1.RECORD_ACTIONS.READ,\n        [message_constants_1.RECORD_ACTIONS.DELETE_SUCCESS]: message_constants_1.RECORD_ACTIONS.DELETE,\n    },\n    [message_constants_1.TOPIC.PRESENCE]: {\n        [message_constants_1.PRESENCE_ACTIONS.QUERY_RESPONSE]: message_constants_1.PRESENCE_ACTIONS.QUERY,\n        [message_constants_1.PRESENCE_ACTIONS.QUERY_ALL_RESPONSE]: message_constants_1.PRESENCE_ACTIONS.QUERY_ALL\n    },\n    [message_constants_1.TOPIC.RPC]: {\n        [message_constants_1.RPC_ACTIONS.ACCEPT]: message_constants_1.RPC_ACTIONS.REQUEST,\n        [message_constants_1.RPC_ACTIONS.ERROR]: message_constants_1.RPC_ACTIONS.REQUEST\n    },\n    [message_constants_1.TOPIC.EVENT]: {}\n};\n\n\n//# sourceURL=webpack://deepstream/./binary-protocol/src/utils.ts?");

/***/ }),

/***/ "./node_modules/assert/assert.js":
/*!***************************************!*\
  !*** ./node_modules/assert/assert.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = __webpack_require__(/*! util/ */ \"./node_modules/util/util.js\");\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://deepstream/./node_modules/assert/assert.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://deepstream/./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer-from/index.js":
/*!*******************************************!*\
  !*** ./node_modules/buffer-from/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var toString = Object.prototype.toString\n\nvar isModern = (\n  typeof Buffer.alloc === 'function' &&\n  typeof Buffer.allocUnsafe === 'function' &&\n  typeof Buffer.from === 'function'\n)\n\nfunction isArrayBuffer (input) {\n  return toString.call(input).slice(8, -1) === 'ArrayBuffer'\n}\n\nfunction fromArrayBuffer (obj, byteOffset, length) {\n  byteOffset >>>= 0\n\n  var maxLength = obj.byteLength - byteOffset\n\n  if (maxLength < 0) {\n    throw new RangeError(\"'offset' is out of bounds\")\n  }\n\n  if (length === undefined) {\n    length = maxLength\n  } else {\n    length >>>= 0\n\n    if (length > maxLength) {\n      throw new RangeError(\"'length' is out of bounds\")\n    }\n  }\n\n  return isModern\n    ? Buffer.from(obj.slice(byteOffset, byteOffset + length))\n    : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)))\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  return isModern\n    ? Buffer.from(string, encoding)\n    : new Buffer(string, encoding)\n}\n\nfunction bufferFrom (value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (isArrayBuffer(value)) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  return isModern\n    ? Buffer.from(value)\n    : new Buffer(value)\n}\n\nmodule.exports = bufferFrom\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://deepstream/./node_modules/buffer-from/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/buffer/node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://deepstream/./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/buffer/node_modules/isarray/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/buffer/node_modules/isarray/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack://deepstream/./node_modules/buffer/node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/component-emitter2/index.js":
/*!**************************************************!*\
  !*** ./node_modules/component-emitter2/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * Expose `Emitter`.\n */\n\nif (true) {\n  module.exports = Emitter;\n}\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || Object.create(null);\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  function on() {\n    this.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || Object.create(null);\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = Object.create(null);\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n\n  // Remove event specific arrays for event types that no\n  // one is subscribed for to avoid memory leak.\n  if (callbacks.length === 0) {\n    delete this._callbacks[event];\n  }\n\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || Object.create(null);\n\n  var args = new Array(arguments.length - 1)\n    , callbacks = this._callbacks[event];\n\n  for (var i = 1; i < arguments.length; i++) {\n    args[i - 1] = arguments[i];\n  }\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || Object.create(null);\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n/**\n * Returns an array listing the events for which the emitter has registered listeners.\n *\n * @return {Array}\n * @api public\n */\nEmitter.prototype.eventNames = function(){\n  return this._callbacks ? Object.keys(this._callbacks) : [];\n}\n\n\n//# sourceURL=webpack://deepstream/./node_modules/component-emitter2/index.js?");

/***/ }),

/***/ "./node_modules/constants-browserify/constants.json":
/*!**********************************************************!*\
  !*** ./node_modules/constants-browserify/constants.json ***!
  \**********************************************************/
/*! exports provided: O_RDONLY, O_WRONLY, O_RDWR, S_IFMT, S_IFREG, S_IFDIR, S_IFCHR, S_IFBLK, S_IFIFO, S_IFLNK, S_IFSOCK, O_CREAT, O_EXCL, O_NOCTTY, O_TRUNC, O_APPEND, O_DIRECTORY, O_NOFOLLOW, O_SYNC, O_SYMLINK, O_NONBLOCK, S_IRWXU, S_IRUSR, S_IWUSR, S_IXUSR, S_IRWXG, S_IRGRP, S_IWGRP, S_IXGRP, S_IRWXO, S_IROTH, S_IWOTH, S_IXOTH, E2BIG, EACCES, EADDRINUSE, EADDRNOTAVAIL, EAFNOSUPPORT, EAGAIN, EALREADY, EBADF, EBADMSG, EBUSY, ECANCELED, ECHILD, ECONNABORTED, ECONNREFUSED, ECONNRESET, EDEADLK, EDESTADDRREQ, EDOM, EDQUOT, EEXIST, EFAULT, EFBIG, EHOSTUNREACH, EIDRM, EILSEQ, EINPROGRESS, EINTR, EINVAL, EIO, EISCONN, EISDIR, ELOOP, EMFILE, EMLINK, EMSGSIZE, EMULTIHOP, ENAMETOOLONG, ENETDOWN, ENETRESET, ENETUNREACH, ENFILE, ENOBUFS, ENODATA, ENODEV, ENOENT, ENOEXEC, ENOLCK, ENOLINK, ENOMEM, ENOMSG, ENOPROTOOPT, ENOSPC, ENOSR, ENOSTR, ENOSYS, ENOTCONN, ENOTDIR, ENOTEMPTY, ENOTSOCK, ENOTSUP, ENOTTY, ENXIO, EOPNOTSUPP, EOVERFLOW, EPERM, EPIPE, EPROTO, EPROTONOSUPPORT, EPROTOTYPE, ERANGE, EROFS, ESPIPE, ESRCH, ESTALE, ETIME, ETIMEDOUT, ETXTBSY, EWOULDBLOCK, EXDEV, SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGIOT, SIGBUS, SIGFPE, SIGKILL, SIGUSR1, SIGSEGV, SIGUSR2, SIGPIPE, SIGALRM, SIGTERM, SIGCHLD, SIGCONT, SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGPROF, SIGWINCH, SIGIO, SIGSYS, SSL_OP_ALL, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION, SSL_OP_CIPHER_SERVER_PREFERENCE, SSL_OP_CISCO_ANYCONNECT, SSL_OP_COOKIE_EXCHANGE, SSL_OP_CRYPTOPRO_TLSEXT_BUG, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS, SSL_OP_EPHEMERAL_RSA, SSL_OP_LEGACY_SERVER_CONNECT, SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER, SSL_OP_MICROSOFT_SESS_ID_BUG, SSL_OP_MSIE_SSLV2_RSA_PADDING, SSL_OP_NETSCAPE_CA_DN_BUG, SSL_OP_NETSCAPE_CHALLENGE_BUG, SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG, SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG, SSL_OP_NO_COMPRESSION, SSL_OP_NO_QUERY_MTU, SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION, SSL_OP_NO_SSLv2, SSL_OP_NO_SSLv3, SSL_OP_NO_TICKET, SSL_OP_NO_TLSv1, SSL_OP_NO_TLSv1_1, SSL_OP_NO_TLSv1_2, SSL_OP_PKCS1_CHECK_1, SSL_OP_PKCS1_CHECK_2, SSL_OP_SINGLE_DH_USE, SSL_OP_SINGLE_ECDH_USE, SSL_OP_SSLEAY_080_CLIENT_DH_BUG, SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG, SSL_OP_TLS_BLOCK_PADDING_BUG, SSL_OP_TLS_D5_BUG, SSL_OP_TLS_ROLLBACK_BUG, ENGINE_METHOD_DSA, ENGINE_METHOD_DH, ENGINE_METHOD_RAND, ENGINE_METHOD_ECDH, ENGINE_METHOD_ECDSA, ENGINE_METHOD_CIPHERS, ENGINE_METHOD_DIGESTS, ENGINE_METHOD_STORE, ENGINE_METHOD_PKEY_METHS, ENGINE_METHOD_PKEY_ASN1_METHS, ENGINE_METHOD_ALL, ENGINE_METHOD_NONE, DH_CHECK_P_NOT_SAFE_PRIME, DH_CHECK_P_NOT_PRIME, DH_UNABLE_TO_CHECK_GENERATOR, DH_NOT_SUITABLE_GENERATOR, NPN_ENABLED, RSA_PKCS1_PADDING, RSA_SSLV23_PADDING, RSA_NO_PADDING, RSA_PKCS1_OAEP_PADDING, RSA_X931_PADDING, RSA_PKCS1_PSS_PADDING, POINT_CONVERSION_COMPRESSED, POINT_CONVERSION_UNCOMPRESSED, POINT_CONVERSION_HYBRID, F_OK, R_OK, W_OK, X_OK, UV_UDP_REUSEADDR, default */
/***/ (function(module) {

eval("module.exports = {\"O_RDONLY\":0,\"O_WRONLY\":1,\"O_RDWR\":2,\"S_IFMT\":61440,\"S_IFREG\":32768,\"S_IFDIR\":16384,\"S_IFCHR\":8192,\"S_IFBLK\":24576,\"S_IFIFO\":4096,\"S_IFLNK\":40960,\"S_IFSOCK\":49152,\"O_CREAT\":512,\"O_EXCL\":2048,\"O_NOCTTY\":131072,\"O_TRUNC\":1024,\"O_APPEND\":8,\"O_DIRECTORY\":1048576,\"O_NOFOLLOW\":256,\"O_SYNC\":128,\"O_SYMLINK\":2097152,\"O_NONBLOCK\":4,\"S_IRWXU\":448,\"S_IRUSR\":256,\"S_IWUSR\":128,\"S_IXUSR\":64,\"S_IRWXG\":56,\"S_IRGRP\":32,\"S_IWGRP\":16,\"S_IXGRP\":8,\"S_IRWXO\":7,\"S_IROTH\":4,\"S_IWOTH\":2,\"S_IXOTH\":1,\"E2BIG\":7,\"EACCES\":13,\"EADDRINUSE\":48,\"EADDRNOTAVAIL\":49,\"EAFNOSUPPORT\":47,\"EAGAIN\":35,\"EALREADY\":37,\"EBADF\":9,\"EBADMSG\":94,\"EBUSY\":16,\"ECANCELED\":89,\"ECHILD\":10,\"ECONNABORTED\":53,\"ECONNREFUSED\":61,\"ECONNRESET\":54,\"EDEADLK\":11,\"EDESTADDRREQ\":39,\"EDOM\":33,\"EDQUOT\":69,\"EEXIST\":17,\"EFAULT\":14,\"EFBIG\":27,\"EHOSTUNREACH\":65,\"EIDRM\":90,\"EILSEQ\":92,\"EINPROGRESS\":36,\"EINTR\":4,\"EINVAL\":22,\"EIO\":5,\"EISCONN\":56,\"EISDIR\":21,\"ELOOP\":62,\"EMFILE\":24,\"EMLINK\":31,\"EMSGSIZE\":40,\"EMULTIHOP\":95,\"ENAMETOOLONG\":63,\"ENETDOWN\":50,\"ENETRESET\":52,\"ENETUNREACH\":51,\"ENFILE\":23,\"ENOBUFS\":55,\"ENODATA\":96,\"ENODEV\":19,\"ENOENT\":2,\"ENOEXEC\":8,\"ENOLCK\":77,\"ENOLINK\":97,\"ENOMEM\":12,\"ENOMSG\":91,\"ENOPROTOOPT\":42,\"ENOSPC\":28,\"ENOSR\":98,\"ENOSTR\":99,\"ENOSYS\":78,\"ENOTCONN\":57,\"ENOTDIR\":20,\"ENOTEMPTY\":66,\"ENOTSOCK\":38,\"ENOTSUP\":45,\"ENOTTY\":25,\"ENXIO\":6,\"EOPNOTSUPP\":102,\"EOVERFLOW\":84,\"EPERM\":1,\"EPIPE\":32,\"EPROTO\":100,\"EPROTONOSUPPORT\":43,\"EPROTOTYPE\":41,\"ERANGE\":34,\"EROFS\":30,\"ESPIPE\":29,\"ESRCH\":3,\"ESTALE\":70,\"ETIME\":101,\"ETIMEDOUT\":60,\"ETXTBSY\":26,\"EWOULDBLOCK\":35,\"EXDEV\":18,\"SIGHUP\":1,\"SIGINT\":2,\"SIGQUIT\":3,\"SIGILL\":4,\"SIGTRAP\":5,\"SIGABRT\":6,\"SIGIOT\":6,\"SIGBUS\":10,\"SIGFPE\":8,\"SIGKILL\":9,\"SIGUSR1\":30,\"SIGSEGV\":11,\"SIGUSR2\":31,\"SIGPIPE\":13,\"SIGALRM\":14,\"SIGTERM\":15,\"SIGCHLD\":20,\"SIGCONT\":19,\"SIGSTOP\":17,\"SIGTSTP\":18,\"SIGTTIN\":21,\"SIGTTOU\":22,\"SIGURG\":16,\"SIGXCPU\":24,\"SIGXFSZ\":25,\"SIGVTALRM\":26,\"SIGPROF\":27,\"SIGWINCH\":28,\"SIGIO\":23,\"SIGSYS\":12,\"SSL_OP_ALL\":2147486719,\"SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION\":262144,\"SSL_OP_CIPHER_SERVER_PREFERENCE\":4194304,\"SSL_OP_CISCO_ANYCONNECT\":32768,\"SSL_OP_COOKIE_EXCHANGE\":8192,\"SSL_OP_CRYPTOPRO_TLSEXT_BUG\":2147483648,\"SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS\":2048,\"SSL_OP_EPHEMERAL_RSA\":0,\"SSL_OP_LEGACY_SERVER_CONNECT\":4,\"SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER\":32,\"SSL_OP_MICROSOFT_SESS_ID_BUG\":1,\"SSL_OP_MSIE_SSLV2_RSA_PADDING\":0,\"SSL_OP_NETSCAPE_CA_DN_BUG\":536870912,\"SSL_OP_NETSCAPE_CHALLENGE_BUG\":2,\"SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG\":1073741824,\"SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG\":8,\"SSL_OP_NO_COMPRESSION\":131072,\"SSL_OP_NO_QUERY_MTU\":4096,\"SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION\":65536,\"SSL_OP_NO_SSLv2\":16777216,\"SSL_OP_NO_SSLv3\":33554432,\"SSL_OP_NO_TICKET\":16384,\"SSL_OP_NO_TLSv1\":67108864,\"SSL_OP_NO_TLSv1_1\":268435456,\"SSL_OP_NO_TLSv1_2\":134217728,\"SSL_OP_PKCS1_CHECK_1\":0,\"SSL_OP_PKCS1_CHECK_2\":0,\"SSL_OP_SINGLE_DH_USE\":1048576,\"SSL_OP_SINGLE_ECDH_USE\":524288,\"SSL_OP_SSLEAY_080_CLIENT_DH_BUG\":128,\"SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG\":0,\"SSL_OP_TLS_BLOCK_PADDING_BUG\":512,\"SSL_OP_TLS_D5_BUG\":256,\"SSL_OP_TLS_ROLLBACK_BUG\":8388608,\"ENGINE_METHOD_DSA\":2,\"ENGINE_METHOD_DH\":4,\"ENGINE_METHOD_RAND\":8,\"ENGINE_METHOD_ECDH\":16,\"ENGINE_METHOD_ECDSA\":32,\"ENGINE_METHOD_CIPHERS\":64,\"ENGINE_METHOD_DIGESTS\":128,\"ENGINE_METHOD_STORE\":256,\"ENGINE_METHOD_PKEY_METHS\":512,\"ENGINE_METHOD_PKEY_ASN1_METHS\":1024,\"ENGINE_METHOD_ALL\":65535,\"ENGINE_METHOD_NONE\":0,\"DH_CHECK_P_NOT_SAFE_PRIME\":2,\"DH_CHECK_P_NOT_PRIME\":1,\"DH_UNABLE_TO_CHECK_GENERATOR\":4,\"DH_NOT_SUITABLE_GENERATOR\":8,\"NPN_ENABLED\":1,\"RSA_PKCS1_PADDING\":1,\"RSA_SSLV23_PADDING\":2,\"RSA_NO_PADDING\":3,\"RSA_PKCS1_OAEP_PADDING\":4,\"RSA_X931_PADDING\":5,\"RSA_PKCS1_PSS_PADDING\":6,\"POINT_CONVERSION_COMPRESSED\":2,\"POINT_CONVERSION_UNCOMPRESSED\":4,\"POINT_CONVERSION_HYBRID\":6,\"F_OK\":0,\"R_OK\":4,\"W_OK\":2,\"X_OK\":1,\"UV_UDP_REUSEADDR\":4};\n\n//# sourceURL=webpack://deepstream/./node_modules/constants-browserify/constants.json?");

/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://deepstream/./node_modules/core-util-is/lib/util.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n//# sourceURL=webpack://deepstream/./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/graceful-fs/clone.js":
/*!*******************************************!*\
  !*** ./node_modules/graceful-fs/clone.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = clone\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: obj.__proto__ }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n\n\n//# sourceURL=webpack://deepstream/./node_modules/graceful-fs/clone.js?");

/***/ }),

/***/ "./node_modules/graceful-fs/graceful-fs.js":
/*!*************************************************!*\
  !*** ./node_modules/graceful-fs/graceful-fs.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var fs = __webpack_require__(/*! fs */ \"./node_modules/node-libs-browser/mock/empty.js\")\nvar polyfills = __webpack_require__(/*! ./polyfills.js */ \"./node_modules/graceful-fs/polyfills.js\")\nvar legacy = __webpack_require__(/*! ./legacy-streams.js */ \"./node_modules/graceful-fs/legacy-streams.js\")\nvar clone = __webpack_require__(/*! ./clone.js */ \"./node_modules/graceful-fs/clone.js\")\n\nvar queue = []\n\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\")\n\nfunction noop () {}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\nif (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n  process.on('exit', function() {\n    debug(queue)\n    __webpack_require__(/*! assert */ \"./node_modules/assert/assert.js\").equal(queue.length, 0)\n  })\n}\n\nmodule.exports = patch(clone(fs))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {\n    module.exports = patch(fs)\n    fs.__patched = true;\n}\n\n// Always patch fs.close/closeSync, because we want to\n// retry() whenever a close happens *anywhere* in the program.\n// This is essential when multiple graceful-fs instances are\n// in play at the same time.\nmodule.exports.close = (function (fs$close) { return function (fd, cb) {\n  return fs$close.call(fs, fd, function (err) {\n    if (!err)\n      retry()\n\n    if (typeof cb === 'function')\n      cb.apply(this, arguments)\n  })\n}})(fs.close)\n\nmodule.exports.closeSync = (function (fs$closeSync) { return function (fd) {\n  // Note that graceful-fs also retries when fs.closeSync() fails.\n  // Looks like a bug to me, although it's probably a harmless one.\n  var rval = fs$closeSync.apply(fs, arguments)\n  retry()\n  return rval\n}})(fs.closeSync)\n\n// Only patch fs once, otherwise we'll run into a memory leak if\n// graceful-fs is loaded multiple times, such as in test environments that\n// reset the loaded modules between tests.\n// We look for the string `graceful-fs` from the comment above. This\n// way we are not adding any extra properties and it will detect if older\n// versions of graceful-fs are installed.\nif (!/\\bgraceful-fs\\b/.test(fs.closeSync.toString())) {\n  fs.closeSync = module.exports.closeSync;\n  fs.close = module.exports.close;\n}\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n  fs.FileReadStream = ReadStream;  // Legacy name.\n  fs.FileWriteStream = WriteStream;  // Legacy name.\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  function readdir (path, options, cb) {\n    var args = [path]\n    if (typeof options !== 'function') {\n      args.push(options)\n    } else {\n      cb = options\n    }\n    args.push(go$readdir$cb)\n\n    return go$readdir(args)\n\n    function go$readdir$cb (err, files) {\n      if (files && files.sort)\n        files.sort()\n\n      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n        enqueue([go$readdir, [args]])\n\n      else {\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n        retry()\n      }\n    }\n  }\n\n  function go$readdir (args) {\n    return fs$readdir.apply(fs, args)\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  if (fs$ReadStream) {\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n    ReadStream.prototype.open = ReadStream$open\n  }\n\n  var fs$WriteStream = fs.WriteStream\n  if (fs$WriteStream) {\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n    WriteStream.prototype.open = WriteStream$open\n  }\n\n  fs.ReadStream = ReadStream\n  fs.WriteStream = WriteStream\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  queue.push(elem)\n}\n\nfunction retry () {\n  var elem = queue.shift()\n  if (elem) {\n    debug('RETRY', elem[0].name, elem[1])\n    elem[0].apply(null, elem[1])\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './../process/browser.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))))\n\n//# sourceURL=webpack://deepstream/./node_modules/graceful-fs/graceful-fs.js?");

/***/ }),

/***/ "./node_modules/graceful-fs/legacy-streams.js":
/*!****************************************************!*\
  !*** ./node_modules/graceful-fs/legacy-streams.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var Stream = __webpack_require__(/*! stream */ \"./node_modules/stream-browserify/index.js\").Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './../process/browser.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))))\n\n//# sourceURL=webpack://deepstream/./node_modules/graceful-fs/legacy-streams.js?");

/***/ }),

/***/ "./node_modules/graceful-fs/polyfills.js":
/*!***********************************************!*\
  !*** ./node_modules/graceful-fs/polyfills.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var constants = __webpack_require__(/*! constants */ \"./node_modules/constants-browserify/constants.json\")\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\nvar chdir = process.chdir\nprocess.chdir = function(d) {\n  cwd = null\n  chdir.call(process, d)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (!fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (!fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n      var start = Date.now()\n      var backoff = 0;\n      fs$rename(from, to, function CB (er) {\n        if (er\n            && (er.code === \"EACCES\" || er.code === \"EPERM\")\n            && Date.now() - start < 60000) {\n          setTimeout(function() {\n            fs.stat(to, function (stater, st) {\n              if (stater && stater.code === \"ENOENT\")\n                fs$rename(from, to, CB);\n              else\n                cb(er)\n            })\n          }, backoff)\n          if (backoff < 100)\n            backoff += 10;\n          return;\n        }\n        if (cb) cb(er)\n      })\n    }})(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = (function (fs$read) { return function (fd, buffer, offset, length, position, callback_) {\n    var callback\n    if (callback_ && typeof callback_ === 'function') {\n      var eagCounter = 0\n      callback = function (er, _, __) {\n        if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n        }\n        callback_.apply(this, arguments)\n      }\n    }\n    return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n  }})(fs.read)\n\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n\n  function patchLchmod (fs) {\n    fs.lchmod = function (path, mode, callback) {\n      fs.open( path\n             , constants.O_WRONLY | constants.O_SYMLINK\n             , mode\n             , function (err, fd) {\n        if (err) {\n          if (callback) callback(err)\n          return\n        }\n        // prefer to return the chmod error, if one occurs,\n        // but still try to close, and report closing errors if they occur.\n        fs.fchmod(fd, mode, function (err) {\n          fs.close(fd, function(err2) {\n            if (callback) callback(err || err2)\n          })\n        })\n      })\n    }\n\n    fs.lchmodSync = function (path, mode) {\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      var threw = true\n      var ret\n      try {\n        ret = fs.fchmodSync(fd, mode)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n  }\n\n  function patchLutimes (fs) {\n    if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n      fs.lutimes = function (path, at, mt, cb) {\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\n          if (er) {\n            if (cb) cb(er)\n            return\n          }\n          fs.futimes(fd, at, mt, function (er) {\n            fs.close(fd, function (er2) {\n              if (cb) cb(er || er2)\n            })\n          })\n        })\n      }\n\n      fs.lutimesSync = function (path, at, mt) {\n        var fd = fs.openSync(path, constants.O_SYMLINK)\n        var ret\n        var threw = true\n        try {\n          ret = fs.futimesSync(fd, at, mt)\n          threw = false\n        } finally {\n          if (threw) {\n            try {\n              fs.closeSync(fd)\n            } catch (er) {}\n          } else {\n            fs.closeSync(fd)\n          }\n        }\n        return ret\n      }\n\n    } else {\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n      fs.lutimesSync = function () {}\n    }\n  }\n\n  function chmodFix (orig) {\n    if (!orig) return orig\n    return function (target, mode, cb) {\n      return orig.call(fs, target, mode, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chmodFixSync (orig) {\n    if (!orig) return orig\n    return function (target, mode) {\n      try {\n        return orig.call(fs, target, mode)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function chownFix (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid, cb) {\n      return orig.call(fs, target, uid, gid, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chownFixSync (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid) {\n      try {\n        return orig.call(fs, target, uid, gid)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function statFix (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, cb) {\n      return orig.call(fs, target, function (er, stats) {\n        if (!stats) return cb.apply(this, arguments)\n        if (stats.uid < 0) stats.uid += 0x100000000\n        if (stats.gid < 0) stats.gid += 0x100000000\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function statFixSync (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target) {\n      var stats = orig.call(fs, target)\n      if (stats.uid < 0) stats.uid += 0x100000000\n      if (stats.gid < 0) stats.gid += 0x100000000\n      return stats;\n    }\n  }\n\n  // ENOSYS means that the fs doesn't support the op. Just ignore\n  // that, because it doesn't matter.\n  //\n  // if there's no getuid, or if getuid() is something other\n  // than 0, and the error is EINVAL or EPERM, then just ignore\n  // it.\n  //\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  //\n  // When running as root, or if other types of errors are\n  // encountered, then it's strict.\n  function chownErOk (er) {\n    if (!er)\n      return true\n\n    if (er.code === \"ENOSYS\")\n      return true\n\n    var nonroot = !process.getuid || process.getuid() !== 0\n    if (nonroot) {\n      if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n        return true\n    }\n\n    return false\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './../process/browser.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))))\n\n//# sourceURL=webpack://deepstream/./node_modules/graceful-fs/polyfills.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://deepstream/./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/imurmurhash/imurmurhash.js":
/*!*************************************************!*\
  !*** ./node_modules/imurmurhash/imurmurhash.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @preserve\n * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)\n *\n * @author <a href=\"mailto:jensyt@gmail.com\">Jens Taylor</a>\n * @see http://github.com/homebrewing/brauhaus-diff\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/murmurhash-js\n * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\n * @see http://sites.google.com/site/murmurhash/\n */\n(function(){\n    var cache;\n\n    // Call this function without `new` to use the cached object (good for\n    // single-threaded environments), or with `new` to create a new object.\n    //\n    // @param {string} key A UTF-16 or ASCII string\n    // @param {number} seed An optional positive integer\n    // @return {object} A MurmurHash3 object for incremental hashing\n    function MurmurHash3(key, seed) {\n        var m = this instanceof MurmurHash3 ? this : cache;\n        m.reset(seed)\n        if (typeof key === 'string' && key.length > 0) {\n            m.hash(key);\n        }\n\n        if (m !== this) {\n            return m;\n        }\n    };\n\n    // Incrementally add a string to this hash\n    //\n    // @param {string} key A UTF-16 or ASCII string\n    // @return {object} this\n    MurmurHash3.prototype.hash = function(key) {\n        var h1, k1, i, top, len;\n\n        len = key.length;\n        this.len += len;\n\n        k1 = this.k1;\n        i = 0;\n        switch (this.rem) {\n            case 0: k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) : 0;\n            case 1: k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) << 8 : 0;\n            case 2: k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) << 16 : 0;\n            case 3:\n                k1 ^= len > i ? (key.charCodeAt(i) & 0xff) << 24 : 0;\n                k1 ^= len > i ? (key.charCodeAt(i++) & 0xff00) >> 8 : 0;\n        }\n\n        this.rem = (len + this.rem) & 3; // & 3 is same as % 4\n        len -= this.rem;\n        if (len > 0) {\n            h1 = this.h1;\n            while (1) {\n                k1 = (k1 * 0x2d51 + (k1 & 0xffff) * 0xcc9e0000) & 0xffffffff;\n                k1 = (k1 << 15) | (k1 >>> 17);\n                k1 = (k1 * 0x3593 + (k1 & 0xffff) * 0x1b870000) & 0xffffffff;\n\n                h1 ^= k1;\n                h1 = (h1 << 13) | (h1 >>> 19);\n                h1 = (h1 * 5 + 0xe6546b64) & 0xffffffff;\n\n                if (i >= len) {\n                    break;\n                }\n\n                k1 = ((key.charCodeAt(i++) & 0xffff)) ^\n                     ((key.charCodeAt(i++) & 0xffff) << 8) ^\n                     ((key.charCodeAt(i++) & 0xffff) << 16);\n                top = key.charCodeAt(i++);\n                k1 ^= ((top & 0xff) << 24) ^\n                      ((top & 0xff00) >> 8);\n            }\n\n            k1 = 0;\n            switch (this.rem) {\n                case 3: k1 ^= (key.charCodeAt(i + 2) & 0xffff) << 16;\n                case 2: k1 ^= (key.charCodeAt(i + 1) & 0xffff) << 8;\n                case 1: k1 ^= (key.charCodeAt(i) & 0xffff);\n            }\n\n            this.h1 = h1;\n        }\n\n        this.k1 = k1;\n        return this;\n    };\n\n    // Get the result of this hash\n    //\n    // @return {number} The 32-bit hash\n    MurmurHash3.prototype.result = function() {\n        var k1, h1;\n        \n        k1 = this.k1;\n        h1 = this.h1;\n\n        if (k1 > 0) {\n            k1 = (k1 * 0x2d51 + (k1 & 0xffff) * 0xcc9e0000) & 0xffffffff;\n            k1 = (k1 << 15) | (k1 >>> 17);\n            k1 = (k1 * 0x3593 + (k1 & 0xffff) * 0x1b870000) & 0xffffffff;\n            h1 ^= k1;\n        }\n\n        h1 ^= this.len;\n\n        h1 ^= h1 >>> 16;\n        h1 = (h1 * 0xca6b + (h1 & 0xffff) * 0x85eb0000) & 0xffffffff;\n        h1 ^= h1 >>> 13;\n        h1 = (h1 * 0xae35 + (h1 & 0xffff) * 0xc2b20000) & 0xffffffff;\n        h1 ^= h1 >>> 16;\n\n        return h1 >>> 0;\n    };\n\n    // Reset the hash object for reuse\n    //\n    // @param {number} seed An optional positive integer\n    MurmurHash3.prototype.reset = function(seed) {\n        this.h1 = typeof seed === 'number' ? seed : 0;\n        this.rem = this.k1 = this.len = 0;\n        return this;\n    };\n\n    // A cached object to use. This can be safely used if you're in a single-\n    // threaded environment, otherwise you need to create new hashes to use.\n    cache = new MurmurHash3();\n\n    if (true) {\n        module.exports = MurmurHash3;\n    } else {}\n}());\n\n\n//# sourceURL=webpack://deepstream/./node_modules/imurmurhash/imurmurhash.js?");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack://deepstream/./node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/node-libs-browser/mock/empty.js":
/*!******************************************************!*\
  !*** ./node_modules/node-libs-browser/mock/empty.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack://deepstream/./node_modules/node-libs-browser/mock/empty.js?");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/punycode/punycode.js":
/*!**************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/punycode/punycode.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports =  true && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule =  true && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttrue\n\t) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\t\treturn punycode;\n\t\t}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n\n}(this));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module), __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://deepstream/./node_modules/node-libs-browser/node_modules/punycode/punycode.js?");

/***/ }),

/***/ "./node_modules/node-localstorage/LocalStorage.js":
/*!********************************************************!*\
  !*** ./node_modules/node-localstorage/LocalStorage.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Generated by CoffeeScript 1.10.0\n(function() {\n  var JSONStorage, KEY_FOR_EMPTY_STRING, LocalStorage, MetaKey, QUOTA_EXCEEDED_ERR, StorageEvent, _emptyDirectory, _escapeKey, _rm, createMap, events, fs, path, writeSync,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n\n  fs = __webpack_require__(/*! fs */ \"./node_modules/node-libs-browser/mock/empty.js\");\n\n  events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\n  writeSync = __webpack_require__(/*! write-file-atomic */ \"./node_modules/write-file-atomic/index.js\").sync;\n\n  KEY_FOR_EMPTY_STRING = '---.EMPTY_STRING.---';\n\n  _emptyDirectory = function(target) {\n    var i, len, p, ref, results;\n    ref = fs.readdirSync(target);\n    results = [];\n    for (i = 0, len = ref.length; i < len; i++) {\n      p = ref[i];\n      results.push(_rm(path.join(target, p)));\n    }\n    return results;\n  };\n\n  _rm = function(target) {\n    if (fs.statSync(target).isDirectory()) {\n      _emptyDirectory(target);\n      return fs.rmdirSync(target);\n    } else {\n      return fs.unlinkSync(target);\n    }\n  };\n\n  _escapeKey = function(key) {\n    var newKey;\n    if (key === '') {\n      newKey = KEY_FOR_EMPTY_STRING;\n    } else {\n      newKey = key.toString();\n    }\n    return newKey;\n  };\n\n  QUOTA_EXCEEDED_ERR = (function(superClass) {\n    extend(QUOTA_EXCEEDED_ERR, superClass);\n\n    function QUOTA_EXCEEDED_ERR(message) {\n      this.message = message != null ? message : 'Unknown error.';\n      if (Error.captureStackTrace != null) {\n        Error.captureStackTrace(this, this.constructor);\n      }\n      this.name = this.constructor.name;\n    }\n\n    QUOTA_EXCEEDED_ERR.prototype.toString = function() {\n      return this.name + \": \" + this.message;\n    };\n\n    return QUOTA_EXCEEDED_ERR;\n\n  })(Error);\n\n  StorageEvent = (function() {\n    function StorageEvent(key1, oldValue1, newValue1, url, storageArea) {\n      this.key = key1;\n      this.oldValue = oldValue1;\n      this.newValue = newValue1;\n      this.url = url;\n      this.storageArea = storageArea != null ? storageArea : 'localStorage';\n    }\n\n    return StorageEvent;\n\n  })();\n\n  MetaKey = (function() {\n    function MetaKey(key1, index1) {\n      this.key = key1;\n      this.index = index1;\n      if (!(this instanceof MetaKey)) {\n        return new MetaKey(this.key, this.index);\n      }\n    }\n\n    return MetaKey;\n\n  })();\n\n  createMap = function() {\n    var Map;\n    Map = function() {};\n    Map.prototype = Object.create(null);\n    return new Map();\n  };\n\n  LocalStorage = (function(superClass) {\n    var instanceMap;\n\n    extend(LocalStorage, superClass);\n\n    instanceMap = {};\n\n    function LocalStorage(_location, quota) {\n      this._location = _location;\n      this.quota = quota != null ? quota : 5 * 1024 * 1024;\n      if (!(this instanceof LocalStorage)) {\n        return new LocalStorage(this._location, this.quota);\n      }\n      this._location = path.resolve(this._location);\n      if (instanceMap[this._location] != null) {\n        return instanceMap[this._location];\n      }\n      this.length = 0;\n      this._bytesInUse = 0;\n      this._keys = [];\n      this._metaKeyMap = createMap();\n      this._eventUrl = \"pid:\" + process.pid;\n      this._init();\n      this._QUOTA_EXCEEDED_ERR = QUOTA_EXCEEDED_ERR;\n      instanceMap[this._location] = this;\n      return instanceMap[this._location];\n    }\n\n    LocalStorage.prototype._init = function() {\n      var _MetaKey, _decodedKey, _keys, e, error, error1, i, index, k, len, stat;\n      try {\n        stat = fs.statSync(this._location);\n        if ((stat != null) && !stat.isDirectory()) {\n          throw new Error(\"A file exists at the location '\" + this._location + \"' when trying to create/open localStorage\");\n        }\n        this._bytesInUse = 0;\n        this.length = 0;\n        _keys = fs.readdirSync(this._location);\n        for (index = i = 0, len = _keys.length; i < len; index = ++i) {\n          k = _keys[index];\n          _decodedKey = decodeURIComponent(k);\n          this._keys.push(_decodedKey);\n          _MetaKey = new MetaKey(k, index);\n          this._metaKeyMap[_decodedKey] = _MetaKey;\n          stat = this._getStat(k);\n          if ((stat != null ? stat.size : void 0) != null) {\n            _MetaKey.size = stat.size;\n            this._bytesInUse += stat.size;\n          }\n        }\n        this.length = _keys.length;\n      } catch (error) {\n        e = error;\n        if (e.code !== \"ENOENT\") {\n          throw e;\n        }\n        try {\n          fs.mkdirSync(this._location);\n        } catch (error1) {\n          e = error1;\n          if (e.code !== \"EEXIST\") {\n            throw e;\n          }\n        }\n      }\n    };\n\n    LocalStorage.prototype.setItem = function(key, value) {\n      var encodedKey, evnt, existsBeforeSet, filename, hasListeners, metaKey, oldLength, oldValue, valueString, valueStringLength;\n      hasListeners = events.EventEmitter.listenerCount(this, 'storage');\n      oldValue = null;\n      if (hasListeners) {\n        oldValue = this.getItem(key);\n      }\n      key = _escapeKey(key);\n      encodedKey = encodeURIComponent(key);\n      filename = path.join(this._location, encodedKey);\n      valueString = value.toString();\n      valueStringLength = valueString.length;\n      metaKey = this._metaKeyMap[key];\n      existsBeforeSet = !!metaKey;\n      if (existsBeforeSet) {\n        oldLength = metaKey.size;\n      } else {\n        oldLength = 0;\n      }\n      if (this._bytesInUse - oldLength + valueStringLength > this.quota) {\n        throw new QUOTA_EXCEEDED_ERR();\n      }\n      writeSync(filename, valueString, 'utf8');\n      if (!existsBeforeSet) {\n        metaKey = new MetaKey(encodedKey, (this._keys.push(key)) - 1);\n        metaKey.size = valueStringLength;\n        this._metaKeyMap[key] = metaKey;\n        this.length += 1;\n        this._bytesInUse += valueStringLength;\n      }\n      if (hasListeners) {\n        evnt = new StorageEvent(key, oldValue, value, this._eventUrl);\n        return this.emit('storage', evnt);\n      }\n    };\n\n    LocalStorage.prototype.getItem = function(key) {\n      var filename, metaKey;\n      key = _escapeKey(key);\n      metaKey = this._metaKeyMap[key];\n      if (!!metaKey) {\n        filename = path.join(this._location, metaKey.key);\n        return fs.readFileSync(filename, 'utf8');\n      } else {\n        return null;\n      }\n    };\n\n    LocalStorage.prototype._getStat = function(key) {\n      var error, filename;\n      key = _escapeKey(key);\n      filename = path.join(this._location, encodeURIComponent(key));\n      try {\n        return fs.statSync(filename);\n      } catch (error) {\n        return null;\n      }\n    };\n\n    LocalStorage.prototype.removeItem = function(key) {\n      var evnt, filename, hasListeners, k, meta, metaKey, oldValue, ref, v;\n      key = _escapeKey(key);\n      metaKey = this._metaKeyMap[key];\n      if (!!metaKey) {\n        hasListeners = events.EventEmitter.listenerCount(this, 'storage');\n        oldValue = null;\n        if (hasListeners) {\n          oldValue = this.getItem(key);\n        }\n        delete this._metaKeyMap[key];\n        this.length -= 1;\n        this._bytesInUse -= metaKey.size;\n        filename = path.join(this._location, metaKey.key);\n        this._keys.splice(metaKey.index, 1);\n        ref = this._metaKeyMap;\n        for (k in ref) {\n          v = ref[k];\n          meta = this._metaKeyMap[k];\n          if (meta.index > metaKey.index) {\n            meta.index -= 1;\n          }\n        }\n        _rm(filename);\n        if (hasListeners) {\n          evnt = new StorageEvent(key, oldValue, null, this._eventUrl);\n          return this.emit('storage', evnt);\n        }\n      }\n    };\n\n    LocalStorage.prototype.key = function(n) {\n      return this._keys[n];\n    };\n\n    LocalStorage.prototype.clear = function() {\n      var evnt;\n      _emptyDirectory(this._location);\n      this._metaKeyMap = createMap();\n      this._keys = [];\n      this.length = 0;\n      this._bytesInUse = 0;\n      if (events.EventEmitter.listenerCount(this, 'storage')) {\n        evnt = new StorageEvent(null, null, null, this._eventUrl);\n        return this.emit('storage', evnt);\n      }\n    };\n\n    LocalStorage.prototype._getBytesInUse = function() {\n      return this._bytesInUse;\n    };\n\n    LocalStorage.prototype._deleteLocation = function() {\n      delete instanceMap[this._location];\n      _rm(this._location);\n      this._metaKeyMap = {};\n      this._keys = [];\n      this.length = 0;\n      return this._bytesInUse = 0;\n    };\n\n    return LocalStorage;\n\n  })(events.EventEmitter);\n\n  JSONStorage = (function(superClass) {\n    extend(JSONStorage, superClass);\n\n    function JSONStorage() {\n      return JSONStorage.__super__.constructor.apply(this, arguments);\n    }\n\n    JSONStorage.prototype.setItem = function(key, value) {\n      var newValue;\n      newValue = JSON.stringify(value);\n      return JSONStorage.__super__.setItem.call(this, key, newValue);\n    };\n\n    JSONStorage.prototype.getItem = function(key) {\n      return JSON.parse(JSONStorage.__super__.getItem.call(this, key));\n    };\n\n    return JSONStorage;\n\n  })(LocalStorage);\n\n  exports.LocalStorage = LocalStorage;\n\n  exports.JSONStorage = JSONStorage;\n\n  exports.QUOTA_EXCEEDED_ERR = QUOTA_EXCEEDED_ERR;\n\n}).call(this);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './../process/browser.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))))\n\n//# sourceURL=webpack://deepstream/./node_modules/node-localstorage/LocalStorage.js?");

/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './../process/browser.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))))\n\n//# sourceURL=webpack://deepstream/./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./node_modules/process-nextick-args/index.js":
/*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './../process/browser.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))))\n\n//# sourceURL=webpack://deepstream/./node_modules/process-nextick-args/index.js?");

/***/ }),

/***/ "./node_modules/querystring-es3/decode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/decode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n\n//# sourceURL=webpack://deepstream/./node_modules/querystring-es3/decode.js?");

/***/ }),

/***/ "./node_modules/querystring-es3/encode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/encode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n\n\n//# sourceURL=webpack://deepstream/./node_modules/querystring-es3/encode.js?");

/***/ }),

/***/ "./node_modules/querystring-es3/index.js":
/*!***********************************************!*\
  !*** ./node_modules/querystring-es3/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.decode = exports.parse = __webpack_require__(/*! ./decode */ \"./node_modules/querystring-es3/decode.js\");\nexports.encode = exports.stringify = __webpack_require__(/*! ./encode */ \"./node_modules/querystring-es3/encode.js\");\n\n\n//# sourceURL=webpack://deepstream/./node_modules/querystring-es3/index.js?");

/***/ }),

/***/ "./node_modules/readable-stream/duplex-browser.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/duplex-browser.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n\n//# sourceURL=webpack://deepstream/./node_modules/readable-stream/duplex-browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};\n\n//# sourceURL=webpack://deepstream/./node_modules/readable-stream/lib/_stream_duplex.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\n\nmodule.exports = PassThrough;\n\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"./node_modules/readable-stream/lib/_stream_transform.js\");\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n//# sourceURL=webpack://deepstream/./node_modules/readable-stream/lib/_stream_passthrough.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/readable-stream/node_modules/isarray/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = __webpack_require__(/*! util */ 1);\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ \"./node_modules/readable-stream/lib/internal/streams/BufferList.js\");\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './../../process/browser.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))))\n\n//# sourceURL=webpack://deepstream/./node_modules/readable-stream/lib/_stream_readable.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\n\nmodule.exports = Transform;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n//# sourceURL=webpack://deepstream/./node_modules/readable-stream/lib/_stream_transform.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/browser.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './../../process/browser.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())), __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './../../timers-browserify/main.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())).setImmediate, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://deepstream/./node_modules/readable-stream/lib/_stream_writable.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!*************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\nvar util = __webpack_require__(/*! util */ 2);\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}\n\n//# sourceURL=webpack://deepstream/./node_modules/readable-stream/lib/internal/streams/BufferList.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};\n\n//# sourceURL=webpack://deepstream/./node_modules/readable-stream/lib/internal/streams/destroy.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\n\n//# sourceURL=webpack://deepstream/./node_modules/readable-stream/lib/internal/streams/stream-browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/node_modules/isarray/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/readable-stream/node_modules/isarray/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack://deepstream/./node_modules/readable-stream/node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/readable-stream/passthrough.js":
/*!*****************************************************!*\
  !*** ./node_modules/readable-stream/passthrough.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./readable */ \"./node_modules/readable-stream/readable-browser.js\").PassThrough\n\n\n//# sourceURL=webpack://deepstream/./node_modules/readable-stream/passthrough.js?");

/***/ }),

/***/ "./node_modules/readable-stream/readable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\nexports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\nexports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"./node_modules/readable-stream/lib/_stream_transform.js\");\nexports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"./node_modules/readable-stream/lib/_stream_passthrough.js\");\n\n\n//# sourceURL=webpack://deepstream/./node_modules/readable-stream/readable-browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/transform.js":
/*!***************************************************!*\
  !*** ./node_modules/readable-stream/transform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./readable */ \"./node_modules/readable-stream/readable-browser.js\").Transform\n\n\n//# sourceURL=webpack://deepstream/./node_modules/readable-stream/transform.js?");

/***/ }),

/***/ "./node_modules/readable-stream/writable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/writable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/_stream_writable.js */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\n\n\n//# sourceURL=webpack://deepstream/./node_modules/readable-stream/writable-browser.js?");

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n\n//# sourceURL=webpack://deepstream/./node_modules/safe-buffer/index.js?");

/***/ }),

/***/ "./node_modules/slide/lib/async-map.js":
/*!*********************************************!*\
  !*** ./node_modules/slide/lib/async-map.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {\n/*\nusage:\n\n// do something to a list of things\nasyncMap(myListOfStuff, function (thing, cb) { doSomething(thing.foo, cb) }, cb)\n// do more than one thing to each item\nasyncMap(list, fooFn, barFn, cb)\n\n*/\n\nmodule.exports = asyncMap\n\nfunction asyncMap () {\n  var steps = Array.prototype.slice.call(arguments)\n    , list = steps.shift() || []\n    , cb_ = steps.pop()\n  if (typeof cb_ !== \"function\") throw new Error(\n    \"No callback provided to asyncMap\")\n  if (!list) return cb_(null, [])\n  if (!Array.isArray(list)) list = [list]\n  var n = steps.length\n    , data = [] // 2d array\n    , errState = null\n    , l = list.length\n    , a = l * n\n  if (!a) return cb_(null, [])\n  function cb (er) {\n    if (er && !errState) errState = er\n\n    var argLen = arguments.length\n    for (var i = 1; i < argLen; i ++) if (arguments[i] !== undefined) {\n      data[i - 1] = (data[i - 1] || []).concat(arguments[i])\n    }\n    // see if any new things have been added.\n    if (list.length > l) {\n      var newList = list.slice(l)\n      a += (list.length - l) * n\n      l = list.length\n      process.nextTick(function () {\n        newList.forEach(function (ar) {\n          steps.forEach(function (fn) { fn(ar, cb) })\n        })\n      })\n    }\n\n    if (--a === 0) cb_.apply(null, [errState].concat(data))\n  }\n  // expect the supplied cb function to be called\n  // \"n\" times for each thing in the array.\n  list.forEach(function (ar) {\n    steps.forEach(function (fn) { fn(ar, cb) })\n  })\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './../../process/browser.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))))\n\n//# sourceURL=webpack://deepstream/./node_modules/slide/lib/async-map.js?");

/***/ }),

/***/ "./node_modules/slide/lib/bind-actor.js":
/*!**********************************************!*\
  !*** ./node_modules/slide/lib/bind-actor.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = bindActor\nfunction bindActor () {\n  var args = \n        Array.prototype.slice.call\n        (arguments) // jswtf.\n    , obj = null\n    , fn\n  if (typeof args[0] === \"object\") {\n    obj = args.shift()\n    fn = args.shift()\n    if (typeof fn === \"string\")\n      fn = obj[ fn ]\n  } else fn = args.shift()\n  return function (cb) {\n    fn.apply(obj, args.concat(cb)) }\n}\n\n\n//# sourceURL=webpack://deepstream/./node_modules/slide/lib/bind-actor.js?");

/***/ }),

/***/ "./node_modules/slide/lib/chain.js":
/*!*****************************************!*\
  !*** ./node_modules/slide/lib/chain.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = chain\nvar bindActor = __webpack_require__(/*! ./bind-actor.js */ \"./node_modules/slide/lib/bind-actor.js\")\nchain.first = {} ; chain.last = {}\nfunction chain (things, cb) {\n  var res = []\n  ;(function LOOP (i, len) {\n    if (i >= len) return cb(null,res)\n    if (Array.isArray(things[i]))\n      things[i] = bindActor.apply(null,\n        things[i].map(function(i){\n          return (i===chain.first) ? res[0]\n           : (i===chain.last)\n             ? res[res.length - 1] : i }))\n    if (!things[i]) return LOOP(i + 1, len)\n    things[i](function (er, data) {\n      if (er) return cb(er, res)\n      if (data !== undefined) res = res.concat(data)\n      LOOP(i + 1, len)\n    })\n  })(0, things.length) }\n\n\n//# sourceURL=webpack://deepstream/./node_modules/slide/lib/chain.js?");

/***/ }),

/***/ "./node_modules/slide/lib/slide.js":
/*!*****************************************!*\
  !*** ./node_modules/slide/lib/slide.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports.asyncMap = __webpack_require__(/*! ./async-map */ \"./node_modules/slide/lib/async-map.js\")\nexports.bindActor = __webpack_require__(/*! ./bind-actor */ \"./node_modules/slide/lib/bind-actor.js\")\nexports.chain = __webpack_require__(/*! ./chain */ \"./node_modules/slide/lib/chain.js\")\n\n\n//# sourceURL=webpack://deepstream/./node_modules/slide/lib/slide.js?");

/***/ }),

/***/ "./node_modules/source-map-support/source-map-support.js":
/*!***************************************************************!*\
  !*** ./node_modules/source-map-support/source-map-support.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var SourceMapConsumer = __webpack_require__(/*! source-map */ \"./node_modules/source-map/source-map.js\").SourceMapConsumer;\nvar path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n\nvar fs;\ntry {\n  fs = __webpack_require__(/*! fs */ \"./node_modules/node-libs-browser/mock/empty.js\");\n  if (!fs.existsSync || !fs.readFileSync) {\n    // fs doesn't have all methods we need\n    fs = null;\n  }\n} catch (err) {\n  /* nop */\n}\n\nvar bufferFrom = __webpack_require__(/*! buffer-from */ \"./node_modules/buffer-from/index.js\");\n\n// Only install once if called multiple times\nvar errorFormatterInstalled = false;\nvar uncaughtShimInstalled = false;\n\n// If true, the caches are reset before a stack trace formatting operation\nvar emptyCacheBetweenOperations = false;\n\n// Supports {browser, node, auto}\nvar environment = \"auto\";\n\n// Maps a file path to a string containing the file contents\nvar fileContentsCache = {};\n\n// Maps a file path to a source map for that file\nvar sourceMapCache = {};\n\n// Regex for detecting source maps\nvar reSourceMap = /^data:application\\/json[^,]+base64,/;\n\n// Priority list of retrieve handlers\nvar retrieveFileHandlers = [];\nvar retrieveMapHandlers = [];\n\nfunction isInBrowser() {\n  if (environment === \"browser\")\n    return true;\n  if (environment === \"node\")\n    return false;\n  return ((typeof window !== 'undefined') && (typeof XMLHttpRequest === 'function') && !(window.require && window.module && window.process && window.process.type === \"renderer\"));\n}\n\nfunction hasGlobalProcessEventEmitter() {\n  return ((typeof process === 'object') && (process !== null) && (typeof process.on === 'function'));\n}\n\nfunction handlerExec(list) {\n  return function(arg) {\n    for (var i = 0; i < list.length; i++) {\n      var ret = list[i](arg);\n      if (ret) {\n        return ret;\n      }\n    }\n    return null;\n  };\n}\n\nvar retrieveFile = handlerExec(retrieveFileHandlers);\n\nretrieveFileHandlers.push(function(path) {\n  // Trim the path to make sure there is no extra whitespace.\n  path = path.trim();\n  if (/^file:/.test(path)) {\n    // existsSync/readFileSync can't handle file protocol, but once stripped, it works\n    path = path.replace(/file:\\/\\/\\/(\\w:)?/, function(protocol, drive) {\n      return drive ?\n        '' : // file:///C:/dir/file -> C:/dir/file\n        '/'; // file:///root-dir/file -> /root-dir/file\n    });\n  }\n  if (path in fileContentsCache) {\n    return fileContentsCache[path];\n  }\n\n  var contents = '';\n  try {\n    if (!fs) {\n      // Use SJAX if we are in the browser\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', path, /** async */ false);\n      xhr.send(null);\n      if (xhr.readyState === 4 && xhr.status === 200) {\n        contents = xhr.responseText;\n      }\n    } else if (fs.existsSync(path)) {\n      // Otherwise, use the filesystem\n      contents = fs.readFileSync(path, 'utf8');\n    }\n  } catch (er) {\n    /* ignore any errors */\n  }\n\n  return fileContentsCache[path] = contents;\n});\n\n// Support URLs relative to a directory, but be careful about a protocol prefix\n// in case we are in the browser (i.e. directories may start with \"http://\" or \"file:///\")\nfunction supportRelativeURL(file, url) {\n  if (!file) return url;\n  var dir = path.dirname(file);\n  var match = /^\\w+:\\/\\/[^\\/]*/.exec(dir);\n  var protocol = match ? match[0] : '';\n  var startPath = dir.slice(protocol.length);\n  if (protocol && /^\\/\\w\\:/.test(startPath)) {\n    // handle file:///C:/ paths\n    protocol += '/';\n    return protocol + path.resolve(dir.slice(protocol.length), url).replace(/\\\\/g, '/');\n  }\n  return protocol + path.resolve(dir.slice(protocol.length), url);\n}\n\nfunction retrieveSourceMapURL(source) {\n  var fileData;\n\n  if (isInBrowser()) {\n     try {\n       var xhr = new XMLHttpRequest();\n       xhr.open('GET', source, false);\n       xhr.send(null);\n       fileData = xhr.readyState === 4 ? xhr.responseText : null;\n\n       // Support providing a sourceMappingURL via the SourceMap header\n       var sourceMapHeader = xhr.getResponseHeader(\"SourceMap\") ||\n                             xhr.getResponseHeader(\"X-SourceMap\");\n       if (sourceMapHeader) {\n         return sourceMapHeader;\n       }\n     } catch (e) {\n     }\n  }\n\n  // Get the URL of the source map\n  fileData = retrieveFile(source);\n  var re = /(?:\\/\\/[@#][ \\t]+sourceMappingURL=([^\\s'\"]+?)[ \\t]*$)|(?:\\/\\*[@#][ \\t]+sourceMappingURL=([^\\*]+?)[ \\t]*(?:\\*\\/)[ \\t]*$)/mg;\n  // Keep executing the search to find the *last* sourceMappingURL to avoid\n  // picking up sourceMappingURLs from comments, strings, etc.\n  var lastMatch, match;\n  while (match = re.exec(fileData)) lastMatch = match;\n  if (!lastMatch) return null;\n  return lastMatch[1];\n};\n\n// Can be overridden by the retrieveSourceMap option to install. Takes a\n// generated source filename; returns a {map, optional url} object, or null if\n// there is no source map.  The map field may be either a string or the parsed\n// JSON object (ie, it must be a valid argument to the SourceMapConsumer\n// constructor).\nvar retrieveSourceMap = handlerExec(retrieveMapHandlers);\nretrieveMapHandlers.push(function(source) {\n  var sourceMappingURL = retrieveSourceMapURL(source);\n  if (!sourceMappingURL) return null;\n\n  // Read the contents of the source map\n  var sourceMapData;\n  if (reSourceMap.test(sourceMappingURL)) {\n    // Support source map URL as a data url\n    var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);\n    sourceMapData = bufferFrom(rawData, \"base64\").toString();\n    sourceMappingURL = source;\n  } else {\n    // Support source map URLs relative to the source URL\n    sourceMappingURL = supportRelativeURL(source, sourceMappingURL);\n    sourceMapData = retrieveFile(sourceMappingURL);\n  }\n\n  if (!sourceMapData) {\n    return null;\n  }\n\n  return {\n    url: sourceMappingURL,\n    map: sourceMapData\n  };\n});\n\nfunction mapSourcePosition(position) {\n  var sourceMap = sourceMapCache[position.source];\n  if (!sourceMap) {\n    // Call the (overrideable) retrieveSourceMap function to get the source map.\n    var urlAndMap = retrieveSourceMap(position.source);\n    if (urlAndMap) {\n      sourceMap = sourceMapCache[position.source] = {\n        url: urlAndMap.url,\n        map: new SourceMapConsumer(urlAndMap.map)\n      };\n\n      // Load all sources stored inline with the source map into the file cache\n      // to pretend like they are already loaded. They may not exist on disk.\n      if (sourceMap.map.sourcesContent) {\n        sourceMap.map.sources.forEach(function(source, i) {\n          var contents = sourceMap.map.sourcesContent[i];\n          if (contents) {\n            var url = supportRelativeURL(sourceMap.url, source);\n            fileContentsCache[url] = contents;\n          }\n        });\n      }\n    } else {\n      sourceMap = sourceMapCache[position.source] = {\n        url: null,\n        map: null\n      };\n    }\n  }\n\n  // Resolve the source URL relative to the URL of the source map\n  if (sourceMap && sourceMap.map && typeof sourceMap.map.originalPositionFor === 'function') {\n    var originalPosition = sourceMap.map.originalPositionFor(position);\n\n    // Only return the original position if a matching line was found. If no\n    // matching line is found then we return position instead, which will cause\n    // the stack trace to print the path and line for the compiled file. It is\n    // better to give a precise location in the compiled file than a vague\n    // location in the original file.\n    if (originalPosition.source !== null) {\n      originalPosition.source = supportRelativeURL(\n        sourceMap.url, originalPosition.source);\n      return originalPosition;\n    }\n  }\n\n  return position;\n}\n\n// Parses code generated by FormatEvalOrigin(), a function inside V8:\n// https://code.google.com/p/v8/source/browse/trunk/src/messages.js\nfunction mapEvalOrigin(origin) {\n  // Most eval() calls are in this format\n  var match = /^eval at ([^(]+) \\((.+):(\\d+):(\\d+)\\)$/.exec(origin);\n  if (match) {\n    var position = mapSourcePosition({\n      source: match[2],\n      line: +match[3],\n      column: match[4] - 1\n    });\n    return 'eval at ' + match[1] + ' (' + position.source + ':' +\n      position.line + ':' + (position.column + 1) + ')';\n  }\n\n  // Parse nested eval() calls using recursion\n  match = /^eval at ([^(]+) \\((.+)\\)$/.exec(origin);\n  if (match) {\n    return 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';\n  }\n\n  // Make sure we still return useful information if we didn't find anything\n  return origin;\n}\n\n// This is copied almost verbatim from the V8 source code at\n// https://code.google.com/p/v8/source/browse/trunk/src/messages.js. The\n// implementation of wrapCallSite() used to just forward to the actual source\n// code of CallSite.prototype.toString but unfortunately a new release of V8\n// did something to the prototype chain and broke the shim. The only fix I\n// could find was copy/paste.\nfunction CallSiteToString() {\n  var fileName;\n  var fileLocation = \"\";\n  if (this.isNative()) {\n    fileLocation = \"native\";\n  } else {\n    fileName = this.getScriptNameOrSourceURL();\n    if (!fileName && this.isEval()) {\n      fileLocation = this.getEvalOrigin();\n      fileLocation += \", \";  // Expecting source position to follow.\n    }\n\n    if (fileName) {\n      fileLocation += fileName;\n    } else {\n      // Source code does not originate from a file and is not native, but we\n      // can still get the source position inside the source string, e.g. in\n      // an eval string.\n      fileLocation += \"<anonymous>\";\n    }\n    var lineNumber = this.getLineNumber();\n    if (lineNumber != null) {\n      fileLocation += \":\" + lineNumber;\n      var columnNumber = this.getColumnNumber();\n      if (columnNumber) {\n        fileLocation += \":\" + columnNumber;\n      }\n    }\n  }\n\n  var line = \"\";\n  var functionName = this.getFunctionName();\n  var addSuffix = true;\n  var isConstructor = this.isConstructor();\n  var isMethodCall = !(this.isToplevel() || isConstructor);\n  if (isMethodCall) {\n    var typeName = this.getTypeName();\n    // Fixes shim to be backward compatable with Node v0 to v4\n    if (typeName === \"[object Object]\") {\n      typeName = \"null\";\n    }\n    var methodName = this.getMethodName();\n    if (functionName) {\n      if (typeName && functionName.indexOf(typeName) != 0) {\n        line += typeName + \".\";\n      }\n      line += functionName;\n      if (methodName && functionName.indexOf(\".\" + methodName) != functionName.length - methodName.length - 1) {\n        line += \" [as \" + methodName + \"]\";\n      }\n    } else {\n      line += typeName + \".\" + (methodName || \"<anonymous>\");\n    }\n  } else if (isConstructor) {\n    line += \"new \" + (functionName || \"<anonymous>\");\n  } else if (functionName) {\n    line += functionName;\n  } else {\n    line += fileLocation;\n    addSuffix = false;\n  }\n  if (addSuffix) {\n    line += \" (\" + fileLocation + \")\";\n  }\n  return line;\n}\n\nfunction cloneCallSite(frame) {\n  var object = {};\n  Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {\n    object[name] = /^(?:is|get)/.test(name) ? function() { return frame[name].call(frame); } : frame[name];\n  });\n  object.toString = CallSiteToString;\n  return object;\n}\n\nfunction wrapCallSite(frame) {\n  if(frame.isNative()) {\n    return frame;\n  }\n\n  // Most call sites will return the source file from getFileName(), but code\n  // passed to eval() ending in \"//# sourceURL=...\" will return the source file\n  // from getScriptNameOrSourceURL() instead\n  var source = frame.getFileName() || frame.getScriptNameOrSourceURL();\n  if (source) {\n    var line = frame.getLineNumber();\n    var column = frame.getColumnNumber() - 1;\n\n    // Fix position in Node where some (internal) code is prepended.\n    // See https://github.com/evanw/node-source-map-support/issues/36\n    var headerLength = 62;\n    if (line === 1 && column > headerLength && !isInBrowser() && !frame.isEval()) {\n      column -= headerLength;\n    }\n\n    var position = mapSourcePosition({\n      source: source,\n      line: line,\n      column: column\n    });\n    frame = cloneCallSite(frame);\n    var originalFunctionName = frame.getFunctionName;\n    frame.getFunctionName = function() { return position.name || originalFunctionName(); };\n    frame.getFileName = function() { return position.source; };\n    frame.getLineNumber = function() { return position.line; };\n    frame.getColumnNumber = function() { return position.column + 1; };\n    frame.getScriptNameOrSourceURL = function() { return position.source; };\n    return frame;\n  }\n\n  // Code called using eval() needs special handling\n  var origin = frame.isEval() && frame.getEvalOrigin();\n  if (origin) {\n    origin = mapEvalOrigin(origin);\n    frame = cloneCallSite(frame);\n    frame.getEvalOrigin = function() { return origin; };\n    return frame;\n  }\n\n  // If we get here then we were unable to change the source position\n  return frame;\n}\n\n// This function is part of the V8 stack trace API, for more info see:\n// http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\nfunction prepareStackTrace(error, stack) {\n  if (emptyCacheBetweenOperations) {\n    fileContentsCache = {};\n    sourceMapCache = {};\n  }\n\n  return error + stack.map(function(frame) {\n    return '\\n    at ' + wrapCallSite(frame);\n  }).join('');\n}\n\n// Generate position and snippet of original source with pointer\nfunction getErrorSource(error) {\n  var match = /\\n    at [^(]+ \\((.*):(\\d+):(\\d+)\\)/.exec(error.stack);\n  if (match) {\n    var source = match[1];\n    var line = +match[2];\n    var column = +match[3];\n\n    // Support the inline sourceContents inside the source map\n    var contents = fileContentsCache[source];\n\n    // Support files on disk\n    if (!contents && fs && fs.existsSync(source)) {\n      try {\n        contents = fs.readFileSync(source, 'utf8');\n      } catch (er) {\n        contents = '';\n      }\n    }\n\n    // Format the line from the original source code like node does\n    if (contents) {\n      var code = contents.split(/(?:\\r\\n|\\r|\\n)/)[line - 1];\n      if (code) {\n        return source + ':' + line + '\\n' + code + '\\n' +\n          new Array(column).join(' ') + '^';\n      }\n    }\n  }\n  return null;\n}\n\nfunction printErrorAndExit (error) {\n  var source = getErrorSource(error);\n\n  // Ensure error is printed synchronously and not truncated\n  if (process.stderr._handle && process.stderr._handle.setBlocking) {\n    process.stderr._handle.setBlocking(true);\n  }\n\n  if (source) {\n    console.error();\n    console.error(source);\n  }\n\n  console.error(error.stack);\n  process.exit(1);\n}\n\nfunction shimEmitUncaughtException () {\n  var origEmit = process.emit;\n\n  process.emit = function (type) {\n    if (type === 'uncaughtException') {\n      var hasStack = (arguments[1] && arguments[1].stack);\n      var hasListeners = (this.listeners(type).length > 0);\n\n      if (hasStack && !hasListeners) {\n        return printErrorAndExit(arguments[1]);\n      }\n    }\n\n    return origEmit.apply(this, arguments);\n  };\n}\n\nvar originalRetrieveFileHandlers = retrieveFileHandlers.slice(0);\nvar originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);\n\nexports.wrapCallSite = wrapCallSite;\nexports.getErrorSource = getErrorSource;\nexports.mapSourcePosition = mapSourcePosition;\nexports.retrieveSourceMap = retrieveSourceMap;\n\nexports.install = function(options) {\n  options = options || {};\n\n  if (options.environment) {\n    environment = options.environment;\n    if ([\"node\", \"browser\", \"auto\"].indexOf(environment) === -1) {\n      throw new Error(\"environment \" + environment + \" was unknown. Available options are {auto, browser, node}\")\n    }\n  }\n\n  // Allow sources to be found by methods other than reading the files\n  // directly from disk.\n  if (options.retrieveFile) {\n    if (options.overrideRetrieveFile) {\n      retrieveFileHandlers.length = 0;\n    }\n\n    retrieveFileHandlers.unshift(options.retrieveFile);\n  }\n\n  // Allow source maps to be found by methods other than reading the files\n  // directly from disk.\n  if (options.retrieveSourceMap) {\n    if (options.overrideRetrieveSourceMap) {\n      retrieveMapHandlers.length = 0;\n    }\n\n    retrieveMapHandlers.unshift(options.retrieveSourceMap);\n  }\n\n  // Support runtime transpilers that include inline source maps\n  if (options.hookRequire && !isInBrowser()) {\n    var Module;\n    try {\n      Module = __webpack_require__(/*! module */ \"./node_modules/node-libs-browser/mock/empty.js\");\n    } catch (err) {\n      // NOP: Loading in catch block to convert webpack error to warning.\n    }\n    var $compile = Module.prototype._compile;\n\n    if (!$compile.__sourceMapSupport) {\n      Module.prototype._compile = function(content, filename) {\n        fileContentsCache[filename] = content;\n        sourceMapCache[filename] = undefined;\n        return $compile.call(this, content, filename);\n      };\n\n      Module.prototype._compile.__sourceMapSupport = true;\n    }\n  }\n\n  // Configure options\n  if (!emptyCacheBetweenOperations) {\n    emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in options ?\n      options.emptyCacheBetweenOperations : false;\n  }\n\n  // Install the error reformatter\n  if (!errorFormatterInstalled) {\n    errorFormatterInstalled = true;\n    Error.prepareStackTrace = prepareStackTrace;\n  }\n\n  if (!uncaughtShimInstalled) {\n    var installHandler = 'handleUncaughtExceptions' in options ?\n      options.handleUncaughtExceptions : true;\n\n    // Provide the option to not install the uncaught exception handler. This is\n    // to support other uncaught exception handlers (in test frameworks, for\n    // example). If this handler is not installed and there are no other uncaught\n    // exception handlers, uncaught exceptions will be caught by node's built-in\n    // exception handler and the process will still be terminated. However, the\n    // generated JavaScript code will be shown above the stack trace instead of\n    // the original source code.\n    if (installHandler && hasGlobalProcessEventEmitter()) {\n      uncaughtShimInstalled = true;\n      shimEmitUncaughtException();\n    }\n  }\n};\n\nexports.resetRetrieveHandlers = function() {\n  retrieveFileHandlers.length = 0;\n  retrieveMapHandlers.length = 0;\n\n  retrieveFileHandlers = originalRetrieveFileHandlers.slice(0);\n  retrieveMapHandlers = originalRetrieveMapHandlers.slice(0);\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './../process/browser.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))))\n\n//# sourceURL=webpack://deepstream/./node_modules/source-map-support/source-map-support.js?");

/***/ }),

/***/ "./node_modules/source-map/lib/array-set.js":
/*!**************************************************!*\
  !*** ./node_modules/source-map/lib/array-set.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/source-map/lib/util.js\");\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    if (hasNativeMap) {\n      this._set.set(aStr, idx);\n    } else {\n      this._set[sStr] = idx;\n    }\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  if (hasNativeMap) {\n    return this._set.has(aStr);\n  } else {\n    var sStr = util.toSetString(aStr);\n    return has.call(this._set, sStr);\n  }\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  if (hasNativeMap) {\n    var idx = this._set.get(aStr);\n    if (idx >= 0) {\n        return idx;\n    }\n  } else {\n    var sStr = util.toSetString(aStr);\n    if (has.call(this._set, sStr)) {\n      return this._set[sStr];\n    }\n  }\n\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n\n\n//# sourceURL=webpack://deepstream/./node_modules/source-map/lib/array-set.js?");

/***/ }),

/***/ "./node_modules/source-map/lib/base64-vlq.js":
/*!***************************************************!*\
  !*** ./node_modules/source-map/lib/base64-vlq.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = __webpack_require__(/*! ./base64 */ \"./node_modules/source-map/lib/base64.js\");\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n\n\n//# sourceURL=webpack://deepstream/./node_modules/source-map/lib/base64-vlq.js?");

/***/ }),

/***/ "./node_modules/source-map/lib/base64.js":
/*!***********************************************!*\
  !*** ./node_modules/source-map/lib/base64.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n\n\n//# sourceURL=webpack://deepstream/./node_modules/source-map/lib/base64.js?");

/***/ }),

/***/ "./node_modules/source-map/lib/binary-search.js":
/*!******************************************************!*\
  !*** ./node_modules/source-map/lib/binary-search.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n\n\n//# sourceURL=webpack://deepstream/./node_modules/source-map/lib/binary-search.js?");

/***/ }),

/***/ "./node_modules/source-map/lib/mapping-list.js":
/*!*****************************************************!*\
  !*** ./node_modules/source-map/lib/mapping-list.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/source-map/lib/util.js\");\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n\n\n//# sourceURL=webpack://deepstream/./node_modules/source-map/lib/mapping-list.js?");

/***/ }),

/***/ "./node_modules/source-map/lib/quick-sort.js":
/*!***************************************************!*\
  !*** ./node_modules/source-map/lib/quick-sort.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\nexports.quickSort = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};\n\n\n//# sourceURL=webpack://deepstream/./node_modules/source-map/lib/quick-sort.js?");

/***/ }),

/***/ "./node_modules/source-map/lib/source-map-consumer.js":
/*!************************************************************!*\
  !*** ./node_modules/source-map/lib/source-map-consumer.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/source-map/lib/util.js\");\nvar binarySearch = __webpack_require__(/*! ./binary-search */ \"./node_modules/source-map/lib/binary-search.js\");\nvar ArraySet = __webpack_require__(/*! ./array-set */ \"./node_modules/source-map/lib/array-set.js\").ArraySet;\nvar base64VLQ = __webpack_require__(/*! ./base64-vlq */ \"./node_modules/source-map/lib/base64-vlq.js\");\nvar quickSort = __webpack_require__(/*! ./quick-sort */ \"./node_modules/source-map/lib/quick-sort.js\").quickSort;\n\nfunction SourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number is 1-based.\n *   - column: Optional. the column number in the original source.\n *    The column number is 0-based.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *    line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *    The column number is 0-based.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n      return [];\n    }\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  if (sourceRoot) {\n    sourceRoot = util.normalize(sourceRoot);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this._absoluteSources = this._sources.toArray().map(function (s) {\n    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n  });\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this._sourceMapURL = aSourceMapURL;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Utility function to find the index of a source.  Returns -1 if not\n * found.\n */\nBasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {\n  var relativeSource = aSource;\n  if (this.sourceRoot != null) {\n    relativeSource = util.relative(this.sourceRoot, relativeSource);\n  }\n\n  if (this._sources.has(relativeSource)) {\n    return this._sources.indexOf(relativeSource);\n  }\n\n  // Maybe aSource is an absolute URL as returned by |sources|.  In\n  // this case we can't simply undo the transform.\n  var i;\n  for (i = 0; i < this._absoluteSources.length; ++i) {\n    if (this._absoluteSources[i] == aSource) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @param String aSourceMapURL\n *        The URL at which the source map can be found (optional)\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n    smc._sourceMapURL = aSourceMapURL;\n    smc._absoluteSources = smc._sources.toArray().map(function (s) {\n      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\n    });\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._absoluteSources.slice();\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        // Because each offset is encoded relative to the previous one,\n        // many segments often have the same encoding. We can exploit this\n        // fact by caching the parsed variable length fields of each segment,\n        // allowing us to avoid a second parse if we encounter the same\n        // segment again.\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = cachedSegments[str];\n        if (segment) {\n          index += str.length;\n        } else {\n          segment = [];\n          while (index < end) {\n            base64VLQ.decode(aStr, index, temp);\n            value = temp.value;\n            index = temp.rest;\n            segment.push(value);\n          }\n\n          if (segment.length === 2) {\n            throw new Error('Found a source, but no line and column');\n          }\n\n          if (segment.length === 3) {\n            throw new Error('Found a source and line, but no column');\n          }\n\n          cachedSegments[str] = segment;\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          originalMappings.push(mapping);\n        }\n      }\n    }\n\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = generatedMappings;\n\n    quickSort(originalMappings, util.compareByOriginalPositions);\n    this.__originalMappings = originalMappings;\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    var index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    var relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + relativeSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based. \n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = null;\n        if (mapping.name) {\n          name = section.consumer._names.at(mapping.name);\n          this._names.add(name);\n          name = this._names.indexOf(name);\n        }\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n\n//# sourceURL=webpack://deepstream/./node_modules/source-map/lib/source-map-consumer.js?");

/***/ }),

/***/ "./node_modules/source-map/lib/source-map-generator.js":
/*!*************************************************************!*\
  !*** ./node_modules/source-map/lib/source-map-generator.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = __webpack_require__(/*! ./base64-vlq */ \"./node_modules/source-map/lib/base64-vlq.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/source-map/lib/util.js\");\nvar ArraySet = __webpack_require__(/*! ./array-set */ \"./node_modules/source-map/lib/array-set.js\").ArraySet;\nvar MappingList = __webpack_require__(/*! ./mapping-list */ \"./node_modules/source-map/lib/mapping-list.js\").MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var sourceRelative = sourceFile;\n      if (sourceRoot !== null) {\n        sourceRelative = util.relative(sourceRoot, sourceFile);\n      }\n\n      if (!generator._sources.has(sourceRelative)) {\n        generator._sources.add(sourceRelative);\n      }\n\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n        throw new Error(\n            'original.line and original.column are not numbers -- you probably meant to omit ' +\n            'the original mapping entirely and only map the generated position. If so, pass ' +\n            'null for the original mapping instead of an object with empty or null values.'\n        );\n    }\n\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n\n\n//# sourceURL=webpack://deepstream/./node_modules/source-map/lib/source-map-generator.js?");

/***/ }),

/***/ "./node_modules/source-map/lib/source-node.js":
/*!****************************************************!*\
  !*** ./node_modules/source-map/lib/source-node.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = __webpack_require__(/*! ./source-map-generator */ \"./node_modules/source-map/lib/source-map-generator.js\").SourceMapGenerator;\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/source-map/lib/util.js\");\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n      var lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      var newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[remainingLinesIndex] || '';\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[remainingLinesIndex] || '';\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n\n\n//# sourceURL=webpack://deepstream/./node_modules/source-map/lib/source-node.js?");

/***/ }),

/***/ "./node_modules/source-map/lib/util.js":
/*!*********************************************!*\
  !*** ./node_modules/source-map/lib/util.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || '';\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n      sourceRoot += '/';\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   sources entry.  This value is prepended to the individual\n    //   entries in the source field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   sourceRoot, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    var parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      var index = parsed.path.lastIndexOf('/');\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n\n\n//# sourceURL=webpack://deepstream/./node_modules/source-map/lib/util.js?");

/***/ }),

/***/ "./node_modules/source-map/source-map.js":
/*!***********************************************!*\
  !*** ./node_modules/source-map/source-map.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = __webpack_require__(/*! ./lib/source-map-generator */ \"./node_modules/source-map/lib/source-map-generator.js\").SourceMapGenerator;\nexports.SourceMapConsumer = __webpack_require__(/*! ./lib/source-map-consumer */ \"./node_modules/source-map/lib/source-map-consumer.js\").SourceMapConsumer;\nexports.SourceNode = __webpack_require__(/*! ./lib/source-node */ \"./node_modules/source-map/lib/source-node.js\").SourceNode;\n\n\n//# sourceURL=webpack://deepstream/./node_modules/source-map/source-map.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\ninherits(Stream, EE);\nStream.Readable = __webpack_require__(/*! readable-stream/readable.js */ \"./node_modules/readable-stream/readable-browser.js\");\nStream.Writable = __webpack_require__(/*! readable-stream/writable.js */ \"./node_modules/readable-stream/writable-browser.js\");\nStream.Duplex = __webpack_require__(/*! readable-stream/duplex.js */ \"./node_modules/readable-stream/duplex-browser.js\");\nStream.Transform = __webpack_require__(/*! readable-stream/transform.js */ \"./node_modules/readable-stream/transform.js\");\nStream.PassThrough = __webpack_require__(/*! readable-stream/passthrough.js */ \"./node_modules/readable-stream/passthrough.js\");\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n\n//# sourceURL=webpack://deepstream/./node_modules/stream-browserify/index.js?");

/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n\n//# sourceURL=webpack://deepstream/./node_modules/string_decoder/lib/string_decoder.js?");

/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar punycode = __webpack_require__(/*! punycode */ \"./node_modules/node-libs-browser/node_modules/punycode/punycode.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/url/util.js\");\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = __webpack_require__(/*! querystring */ \"./node_modules/querystring-es3/index.js\");\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\n\n//# sourceURL=webpack://deepstream/./node_modules/url/url.js?");

/***/ }),

/***/ "./node_modules/url/util.js":
/*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n\n\n//# sourceURL=webpack://deepstream/./node_modules/url/util.js?");

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://deepstream/./node_modules/util-deprecate/browser.js?");

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack://deepstream/./node_modules/util/support/isBufferBrowser.js?");

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './../process/browser.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))))\n\n//# sourceURL=webpack://deepstream/./node_modules/util/util.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://deepstream/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack://deepstream/(webpack)/buildin/module.js?");

/***/ }),

/***/ "./node_modules/write-file-atomic/index.js":
/*!*************************************************!*\
  !*** ./node_modules/write-file-atomic/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__filename, process, Buffer) {\nmodule.exports = writeFile\nmodule.exports.sync = writeFileSync\nmodule.exports._getTmpname = getTmpname // for testing\n\nvar fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nvar chain = __webpack_require__(/*! slide */ \"./node_modules/slide/lib/slide.js\").chain\nvar MurmurHash3 = __webpack_require__(/*! imurmurhash */ \"./node_modules/imurmurhash/imurmurhash.js\")\nvar extend = Object.assign || __webpack_require__(/*! util */ \"./node_modules/util/util.js\")._extend\n\nvar invocations = 0\nfunction getTmpname (filename) {\n  return filename + '.' +\n    MurmurHash3(__filename)\n      .hash(String(process.pid))\n      .hash(String(++invocations))\n      .result()\n}\n\nfunction writeFile (filename, data, options, callback) {\n  if (options instanceof Function) {\n    callback = options\n    options = null\n  }\n  if (!options) options = {}\n  fs.realpath(filename, function (_, realname) {\n    _writeFile(realname || filename, data, options, callback)\n  })\n}\nfunction _writeFile (filename, data, options, callback) {\n  var tmpfile = getTmpname(filename)\n\n  if (options.mode && options.chown) {\n    return thenWriteFile()\n  } else {\n    // Either mode or chown is not explicitly set\n    // Default behavior is to copy it from original file\n    return fs.stat(filename, function (err, stats) {\n      if (err || !stats) return thenWriteFile()\n\n      options = extend({}, options)\n      if (!options.mode) {\n        options.mode = stats.mode\n      }\n      if (!options.chown && process.getuid) {\n        options.chown = { uid: stats.uid, gid: stats.gid }\n      }\n      return thenWriteFile()\n    })\n  }\n\n  function thenWriteFile () {\n    chain([\n      [writeFileAsync, tmpfile, data, options.mode, options.encoding || 'utf8'],\n      options.chown && [fs, fs.chown, tmpfile, options.chown.uid, options.chown.gid],\n      options.mode && [fs, fs.chmod, tmpfile, options.mode],\n      [fs, fs.rename, tmpfile, filename]\n    ], function (err) {\n      err ? fs.unlink(tmpfile, function () { callback(err) })\n        : callback()\n    })\n  }\n\n  // doing this instead of `fs.writeFile` in order to get the ability to\n  // call `fsync`.\n  function writeFileAsync (file, data, mode, encoding, cb) {\n    fs.open(file, 'w', options.mode, function (err, fd) {\n      if (err) return cb(err)\n      if (Buffer.isBuffer(data)) {\n        return fs.write(fd, data, 0, data.length, 0, syncAndClose)\n      } else if (data != null) {\n        return fs.write(fd, String(data), 0, String(encoding), syncAndClose)\n      } else {\n        return syncAndClose()\n      }\n      function syncAndClose (err) {\n        if (err) return cb(err)\n        fs.fsync(fd, function (err) {\n          if (err) return cb(err)\n          fs.close(fd, cb)\n        })\n      }\n    })\n  }\n}\n\nfunction writeFileSync (filename, data, options) {\n  if (!options) options = {}\n  try {\n    filename = fs.realpathSync(filename)\n  } catch (ex) {\n    // it's ok, it'll happen on a not yet existing file\n  }\n  var tmpfile = getTmpname(filename)\n\n  try {\n    if (!options.mode || !options.chown) {\n      // Either mode or chown is not explicitly set\n      // Default behavior is to copy it from original file\n      try {\n        var stats = fs.statSync(filename)\n        options = extend({}, options)\n        if (!options.mode) {\n          options.mode = stats.mode\n        }\n        if (!options.chown && process.getuid) {\n          options.chown = { uid: stats.uid, gid: stats.gid }\n        }\n      } catch (ex) {\n        // ignore stat errors\n      }\n    }\n\n    var fd = fs.openSync(tmpfile, 'w', options.mode)\n    if (Buffer.isBuffer(data)) {\n      fs.writeSync(fd, data, 0, data.length, 0)\n    } else if (data != null) {\n      fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'))\n    }\n    fs.fsyncSync(fd)\n    fs.closeSync(fd)\n    if (options.chown) fs.chownSync(tmpfile, options.chown.uid, options.chown.gid)\n    if (options.mode) fs.chmodSync(tmpfile, options.mode)\n    fs.renameSync(tmpfile, filename)\n  } catch (err) {\n    try { fs.unlinkSync(tmpfile) } catch (e) {}\n    throw err\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, \"/index.js\", __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './../process/browser.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())), __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://deepstream/./node_modules/write-file-atomic/index.js?");

/***/ }),

/***/ "./src/client-options.ts":
/*!*******************************!*\
  !*** ./src/client-options.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst merge_strategy_1 = __webpack_require__(/*! ./record/merge-strategy */ \"./src/record/merge-strategy.ts\");\nexports.DefaultOptions = {\n    heartbeatInterval: 30000,\n    reconnectIntervalIncrement: 4000,\n    maxReconnectInterval: 180000,\n    maxReconnectAttempts: 5,\n    rpcAcceptTimeout: 6000,\n    rpcResponseTimeout: 10000,\n    subscriptionTimeout: 2000,\n    recordReadAckTimeout: 15000,\n    recordReadTimeout: 15000,\n    recordDeleteTimeout: 15000,\n    offlineBufferTimeout: 2000,\n    discardTimeout: 5000,\n    path: '/deepstream',\n    mergeStrategy: merge_strategy_1.REMOTE_WINS,\n    recordDeepCopy: true,\n    socketOptions: null,\n    dirtyStorageName: '__ds__dirty_records',\n    nodeStoragePath: './local-storage',\n    nodeStorageSize: 5,\n    lazyConnect: false\n};\n\n\n//# sourceURL=webpack://deepstream/./src/client-options.ts?");

/***/ }),

/***/ "./src/client.ts":
/*!***********************!*\
  !*** ./src/client.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst client_options_1 = __webpack_require__(/*! ./client-options */ \"./src/client-options.ts\");\nconst logger_1 = __webpack_require__(/*! ./util/logger */ \"./src/util/logger.ts\");\nconst timeout_registry_1 = __webpack_require__(/*! ./util/timeout-registry */ \"./src/util/timeout-registry.ts\");\nconst timer_registry_1 = __webpack_require__(/*! ./util/timer-registry */ \"./src/util/timer-registry.ts\");\nconst connection_1 = __webpack_require__(/*! ./connection/connection */ \"./src/connection/connection.ts\");\nconst socket_factory_1 = __webpack_require__(/*! ./connection/socket-factory */ \"./src/connection/socket-factory.ts\");\nconst event_handler_1 = __webpack_require__(/*! ./event/event-handler */ \"./src/event/event-handler.ts\");\nconst rpc_handler_1 = __webpack_require__(/*! ./rpc/rpc-handler */ \"./src/rpc/rpc-handler.ts\");\nconst record_handler_1 = __webpack_require__(/*! ./record/record-handler */ \"./src/record/record-handler.ts\");\nconst storage_service_1 = __webpack_require__(/*! ./record/storage-service */ \"./src/record/storage-service.ts\");\nconst presence_handler_1 = __webpack_require__(/*! ./presence/presence-handler */ \"./src/presence/presence-handler.ts\");\nconst EventEmitter = __webpack_require__(/*! component-emitter2 */ \"./node_modules/component-emitter2/index.js\");\nclass Client extends EventEmitter {\n    constructor(url, options = {}) {\n        super();\n        this.options = Object.assign({}, client_options_1.DefaultOptions, options);\n        const services = {};\n        services.storage = options.storage || new storage_service_1.Storage(this.options);\n        services.logger = new logger_1.Logger(this);\n        services.timerRegistry = new timer_registry_1.TimerRegistry();\n        services.timeoutRegistry = new timeout_registry_1.TimeoutRegistry(services, this.options);\n        services.socketFactory = options.socketFactory || socket_factory_1.socketFactory;\n        services.connection = new connection_1.Connection(services, this.options, url, this);\n        this.services = services;\n        this.services.connection.onLost(services.timeoutRegistry.onConnectionLost.bind(services.timeoutRegistry));\n        this.event = new event_handler_1.EventHandler(this.services, this.options);\n        this.rpc = new rpc_handler_1.RPCHandler(this.services, this.options);\n        this.record = new record_handler_1.RecordHandler(this.services, this.options);\n        this.presence = new presence_handler_1.PresenceHandler(this.services, this.options);\n    }\n    login(detailsOrCallback, callback) {\n        if (detailsOrCallback && typeof detailsOrCallback === 'object') {\n            if (callback) {\n                this.services.connection.authenticate(detailsOrCallback, callback);\n            }\n            else {\n                return new Promise((resolve, reject) => {\n                    this.services.connection.authenticate(detailsOrCallback, (success, data) => {\n                        success ? resolve(data) : reject(data);\n                    });\n                });\n            }\n        }\n        else {\n            if (typeof detailsOrCallback === 'function') {\n                this.services.connection.authenticate({}, detailsOrCallback);\n            }\n            else {\n                return new Promise((resolve, reject) => {\n                    this.services.connection.authenticate({}, (success, data) => {\n                        success ? resolve(data) : reject(data);\n                    });\n                });\n            }\n        }\n    }\n    getConnectionState() {\n        return this.services.connection.getConnectionState();\n    }\n    close() {\n        this.services.connection.close();\n    }\n    pause() {\n        this.services.connection.pause();\n    }\n    resume(callback) {\n        if (callback) {\n            this.services.connection.resume(callback);\n            return;\n        }\n        return new Promise((resolve, reject) => {\n            this.services.connection.resume(error => {\n                error ? reject(error) : resolve();\n            });\n        });\n    }\n    /**\n    * Returns a random string. The first block of characters\n    * is a timestamp, in order to allow databases to optimize for semi-\n    * sequentuel numberings\n    */\n    getUid() {\n        const timestamp = (new Date()).getTime().toString(36);\n        const randomString = (Math.random() * 10000000000000000).toString(36).replace('.', '');\n        return `${timestamp}-${randomString}`;\n    }\n}\nexports.Client = Client;\n\n\n//# sourceURL=webpack://deepstream/./src/client.ts?");

/***/ }),

/***/ "./src/connection/connection.ts":
/*!**************************************!*\
  !*** ./src/connection/connection.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nconst message_parser_1 = __webpack_require__(/*! ../../binary-protocol/src/message-parser */ \"./binary-protocol/src/message-parser.ts\");\nconst state_machine_1 = __webpack_require__(/*! ../util/state-machine */ \"./src/util/state-machine.ts\");\nconst utils = __webpack_require__(/*! ../util/utils */ \"./src/util/utils.ts\");\nconst Emitter = __webpack_require__(/*! component-emitter2 */ \"./node_modules/component-emitter2/index.js\");\nclass Connection {\n    constructor(services, options, url, emitter) {\n        this.options = options;\n        this.services = services;\n        this.authParams = null;\n        this.handlers = new Map();\n        // tslint:disable-next-line:no-empty\n        this.authCallback = null;\n        this.resumeCallback = null;\n        this.emitter = emitter;\n        this.internalEmitter = new Emitter();\n        this.isInLimbo = true;\n        this.clientData = null;\n        this.heartbeatInterval = null;\n        this.lastHeartBeat = null;\n        this.endpoint = null;\n        this.reconnectTimeout = null;\n        this.reconnectionAttempt = 0;\n        this.limboTimeout = null;\n        let isReconnecting = false;\n        let firstOpen = true;\n        this.stateMachine = new state_machine_1.StateMachine(this.services.logger, {\n            init: constants_1.CONNECTION_STATE.CLOSED,\n            onStateChanged: (newState, oldState) => {\n                if (newState === oldState) {\n                    return;\n                }\n                emitter.emit(constants_1.EVENT.CONNECTION_STATE_CHANGED, newState);\n                if (newState === constants_1.CONNECTION_STATE.RECONNECTING) {\n                    this.isInLimbo = true;\n                    isReconnecting = true;\n                    if (oldState !== constants_1.CONNECTION_STATE.CLOSED) {\n                        this.internalEmitter.emit(constants_1.EVENT.CONNECTION_LOST);\n                        this.limboTimeout = this.services.timerRegistry.add({\n                            duration: this.options.offlineBufferTimeout,\n                            context: this,\n                            callback: () => {\n                                this.isInLimbo = false;\n                                this.internalEmitter.emit(constants_1.EVENT.EXIT_LIMBO);\n                            }\n                        });\n                    }\n                }\n                else if (newState === constants_1.CONNECTION_STATE.OPEN && (isReconnecting || firstOpen)) {\n                    firstOpen = false;\n                    this.isInLimbo = false;\n                    this.internalEmitter.emit(constants_1.EVENT.CONNECTION_REESTABLISHED);\n                    this.services.timerRegistry.remove(this.limboTimeout);\n                }\n            },\n            transitions: [\n                { name: \"initialised\" /* INITIALISED */, from: constants_1.CONNECTION_STATE.CLOSED, to: constants_1.CONNECTION_STATE.INITIALISING },\n                { name: \"connected\" /* CONNECTED */, from: constants_1.CONNECTION_STATE.INITIALISING, to: constants_1.CONNECTION_STATE.AWAITING_CONNECTION },\n                { name: \"connected\" /* CONNECTED */, from: constants_1.CONNECTION_STATE.REDIRECTING, to: constants_1.CONNECTION_STATE.AWAITING_CONNECTION },\n                { name: \"connected\" /* CONNECTED */, from: constants_1.CONNECTION_STATE.RECONNECTING, to: constants_1.CONNECTION_STATE.AWAITING_CONNECTION },\n                { name: \"challenge\" /* CHALLENGE */, from: constants_1.CONNECTION_STATE.AWAITING_CONNECTION, to: constants_1.CONNECTION_STATE.CHALLENGING },\n                { name: \"redirected\" /* CONNECTION_REDIRECTED */, from: constants_1.CONNECTION_STATE.CHALLENGING, to: constants_1.CONNECTION_STATE.REDIRECTING },\n                { name: \"challenge-denied\" /* CHALLENGE_DENIED */, from: constants_1.CONNECTION_STATE.CHALLENGING, to: constants_1.CONNECTION_STATE.CHALLENGE_DENIED },\n                { name: \"accepted\" /* CHALLENGE_ACCEPTED */, from: constants_1.CONNECTION_STATE.CHALLENGING, to: constants_1.CONNECTION_STATE.AWAITING_AUTHENTICATION, handler: this.onAwaitingAuthentication.bind(this) },\n                { name: \"authentication-timeout\" /* AUTHENTICATION_TIMEOUT */, from: constants_1.CONNECTION_STATE.AWAITING_CONNECTION, to: constants_1.CONNECTION_STATE.AUTHENTICATION_TIMEOUT },\n                { name: \"authentication-timeout\" /* AUTHENTICATION_TIMEOUT */, from: constants_1.CONNECTION_STATE.AWAITING_AUTHENTICATION, to: constants_1.CONNECTION_STATE.AUTHENTICATION_TIMEOUT },\n                { name: \"authenticate\" /* AUTHENTICATE */, from: constants_1.CONNECTION_STATE.AWAITING_AUTHENTICATION, to: constants_1.CONNECTION_STATE.AUTHENTICATING },\n                { name: \"unsuccesful-login\" /* UNSUCCESFUL_LOGIN */, from: constants_1.CONNECTION_STATE.AUTHENTICATING, to: constants_1.CONNECTION_STATE.AWAITING_AUTHENTICATION },\n                { name: \"succesful-login\" /* SUCCESFUL_LOGIN */, from: constants_1.CONNECTION_STATE.AUTHENTICATING, to: constants_1.CONNECTION_STATE.OPEN },\n                { name: \"too-many-auth-attempts\" /* TOO_MANY_AUTH_ATTEMPTS */, from: constants_1.CONNECTION_STATE.AUTHENTICATING, to: constants_1.CONNECTION_STATE.TOO_MANY_AUTH_ATTEMPTS },\n                { name: \"too-many-auth-attempts\" /* TOO_MANY_AUTH_ATTEMPTS */, from: constants_1.CONNECTION_STATE.AWAITING_AUTHENTICATION, to: constants_1.CONNECTION_STATE.TOO_MANY_AUTH_ATTEMPTS },\n                { name: \"authentication-timeout\" /* AUTHENTICATION_TIMEOUT */, from: constants_1.CONNECTION_STATE.AWAITING_AUTHENTICATION, to: constants_1.CONNECTION_STATE.AUTHENTICATION_TIMEOUT },\n                { name: \"reconnect\" /* RECONNECT */, from: constants_1.CONNECTION_STATE.RECONNECTING, to: constants_1.CONNECTION_STATE.RECONNECTING },\n                { name: \"closed\" /* CLOSED */, from: constants_1.CONNECTION_STATE.CLOSING, to: constants_1.CONNECTION_STATE.CLOSED },\n                { name: \"offline\" /* OFFLINE */, from: constants_1.CONNECTION_STATE.PAUSING, to: constants_1.CONNECTION_STATE.OFFLINE },\n                { name: \"error\" /* ERROR */, to: constants_1.CONNECTION_STATE.RECONNECTING },\n                { name: \"connection-lost\" /* LOST */, to: constants_1.CONNECTION_STATE.RECONNECTING },\n                { name: \"resume\" /* RESUME */, to: constants_1.CONNECTION_STATE.RECONNECTING },\n                { name: \"pause\" /* PAUSE */, to: constants_1.CONNECTION_STATE.PAUSING },\n                { name: \"close\" /* CLOSE */, to: constants_1.CONNECTION_STATE.CLOSING },\n            ]\n        });\n        this.stateMachine.transition(\"initialised\" /* INITIALISED */);\n        this.originalUrl = utils.parseUrl(url, this.options.path);\n        this.url = this.originalUrl;\n        if (!options.lazyConnect) {\n            this.createEndpoint();\n        }\n    }\n    get isConnected() {\n        return this.stateMachine.state === constants_1.CONNECTION_STATE.OPEN;\n    }\n    onLost(callback) {\n        this.internalEmitter.on(constants_1.EVENT.CONNECTION_LOST, callback);\n    }\n    removeOnLost(callback) {\n        this.internalEmitter.off(constants_1.EVENT.CONNECTION_LOST, callback);\n    }\n    onReestablished(callback) {\n        this.internalEmitter.on(constants_1.EVENT.CONNECTION_REESTABLISHED, callback);\n    }\n    removeOnReestablished(callback) {\n        this.internalEmitter.off(constants_1.EVENT.CONNECTION_REESTABLISHED, callback);\n    }\n    onExitLimbo(callback) {\n        this.internalEmitter.on(constants_1.EVENT.EXIT_LIMBO, callback);\n    }\n    registerHandler(topic, callback) {\n        this.handlers.set(topic, callback);\n    }\n    sendMessage(message) {\n        if (!this.isOpen()) {\n            this.services.logger.error(message, constants_1.EVENT.IS_CLOSED);\n            return;\n        }\n        if (this.endpoint) {\n            this.endpoint.sendParsedMessage(message);\n        }\n    }\n    authenticate(authParamsOrCallback, callback) {\n        if (authParamsOrCallback &&\n            typeof authParamsOrCallback !== 'object' &&\n            typeof authParamsOrCallback !== 'function') {\n            throw new Error('invalid argument authParamsOrCallback');\n        }\n        if (callback && typeof callback !== 'function') {\n            throw new Error('invalid argument callback');\n        }\n        if (this.stateMachine.state === constants_1.CONNECTION_STATE.CHALLENGE_DENIED ||\n            this.stateMachine.state === constants_1.CONNECTION_STATE.TOO_MANY_AUTH_ATTEMPTS ||\n            this.stateMachine.state === constants_1.CONNECTION_STATE.AUTHENTICATION_TIMEOUT) {\n            this.services.logger.error({ topic: message_constants_1.TOPIC.CONNECTION }, constants_1.EVENT.IS_CLOSED);\n            return;\n        }\n        if (authParamsOrCallback) {\n            this.authParams = typeof authParamsOrCallback === 'object' ? authParamsOrCallback : {};\n        }\n        if (authParamsOrCallback && typeof authParamsOrCallback === 'function') {\n            this.authCallback = authParamsOrCallback;\n        }\n        else if (callback) {\n            this.authCallback = callback;\n        }\n        else {\n            this.authCallback = () => { };\n        }\n        // if (this.stateMachine.state === CONNECTION_STATE.CLOSED && !this.endpoint) {\n        //   this.createEndpoint()\n        //   return\n        // }\n        if (this.stateMachine.state === constants_1.CONNECTION_STATE.AWAITING_AUTHENTICATION && this.authParams) {\n            this.sendAuthParams();\n        }\n        if (!this.endpoint) {\n            this.createEndpoint();\n        }\n    }\n    /*\n    * Returns the current connection state.\n    */\n    getConnectionState() {\n        return this.stateMachine.state;\n    }\n    isOpen() {\n        const connState = this.getConnectionState();\n        return connState !== constants_1.CONNECTION_STATE.CLOSED\n            && connState !== constants_1.CONNECTION_STATE.ERROR\n            && connState !== constants_1.CONNECTION_STATE.CLOSING;\n    }\n    /**\n     * Closes the connection. Using this method\n     * will prevent the client from reconnecting.\n     */\n    close() {\n        this.services.timerRegistry.remove(this.heartbeatInterval);\n        this.sendMessage({\n            topic: message_constants_1.TOPIC.CONNECTION,\n            action: message_constants_1.CONNECTION_ACTIONS.CLOSING\n        });\n        this.stateMachine.transition(\"close\" /* CLOSE */);\n    }\n    pause() {\n        this.stateMachine.transition(\"pause\" /* PAUSE */);\n        this.services.timerRegistry.remove(this.heartbeatInterval);\n        if (this.endpoint) {\n            this.endpoint.close();\n        }\n    }\n    resume(callback) {\n        this.stateMachine.transition(\"resume\" /* RESUME */);\n        this.resumeCallback = callback;\n        this.tryReconnect();\n    }\n    /**\n     * Creates the endpoint to connect to using the url deepstream\n     * was initialised with.\n     */\n    createEndpoint() {\n        this.endpoint = this.services.socketFactory(this.url, this.options.socketOptions);\n        this.endpoint.onopen = this.onOpen.bind(this);\n        // @ts-ignore\n        this.endpoint.onerror = this.onError.bind(this);\n        this.endpoint.onclose = this.onClose.bind(this);\n        this.endpoint.onparsedmessages = this.onMessages.bind(this);\n    }\n    /********************************\n    ****** Endpoint Callbacks ******\n    /********************************/\n    /**\n    * Will be invoked once the connection is established. The client\n    * can't send messages yet, and needs to get a connection ACK or REDIRECT\n    * from the server before authenticating\n    */\n    onOpen() {\n        this.clearReconnect();\n        this.lastHeartBeat = Date.now();\n        this.checkHeartBeat();\n        this.stateMachine.transition(\"connected\" /* CONNECTED */);\n        this.sendMessage({\n            topic: message_constants_1.TOPIC.CONNECTION,\n            action: message_constants_1.CONNECTION_ACTIONS.CHALLENGE,\n            url: this.originalUrl,\n            protocolVersion: '0.1a'\n        });\n        this.stateMachine.transition(\"challenge\" /* CHALLENGE */);\n    }\n    /**\n     * Callback for generic connection errors. Forwards\n     * the error to the client.\n     *\n     * The connection is considered broken once this method has been\n     * invoked.\n     */\n    onError(error) {\n        /*\n         * If the implementation isn't listening on the error event this will throw\n         * an error. So let's defer it to allow the reconnection to kick in.\n         */\n        setTimeout(() => {\n            let msg;\n            if (error.code === 'ECONNRESET' || error.code === 'ECONNREFUSED') {\n                msg = `Can't connect! Deepstream server unreachable on ${this.originalUrl}`;\n            }\n            else {\n                try {\n                    msg = JSON.stringify(error);\n                }\n                catch (e) {\n                    msg = error.toString();\n                }\n            }\n            this.services.logger.error({ topic: message_constants_1.TOPIC.CONNECTION }, constants_1.EVENT.CONNECTION_ERROR, msg);\n        }, 1);\n        this.services.timerRegistry.remove(this.heartbeatInterval);\n        this.stateMachine.transition(\"error\" /* ERROR */);\n        this.tryReconnect();\n    }\n    /**\n     * Callback when the connection closes. This might have been a deliberate\n     * close triggered by the client or the result of the connection getting\n     * lost.\n     *\n     * In the latter case the client will try to reconnect using the configured\n     * strategy.\n     */\n    onClose() {\n        this.services.timerRegistry.remove(this.heartbeatInterval);\n        if (this.stateMachine.state === constants_1.CONNECTION_STATE.REDIRECTING) {\n            this.createEndpoint();\n            return;\n        }\n        if (this.stateMachine.state === constants_1.CONNECTION_STATE.CHALLENGE_DENIED ||\n            this.stateMachine.state === constants_1.CONNECTION_STATE.TOO_MANY_AUTH_ATTEMPTS ||\n            this.stateMachine.state === constants_1.CONNECTION_STATE.AUTHENTICATION_TIMEOUT) {\n            return;\n        }\n        if (this.stateMachine.state === constants_1.CONNECTION_STATE.CLOSING) {\n            this.stateMachine.transition(\"closed\" /* CLOSED */);\n            return;\n        }\n        if (this.stateMachine.state === constants_1.CONNECTION_STATE.PAUSING) {\n            this.stateMachine.transition(\"offline\" /* OFFLINE */);\n            return;\n        }\n        this.stateMachine.transition(\"connection-lost\" /* LOST */);\n        this.tryReconnect();\n    }\n    /**\n     * Callback for messages received on the connection.\n     */\n    onMessages(parseResults) {\n        parseResults.forEach(parseResult => {\n            if (parseResult.parseError) {\n                this.services.logger.error({ topic: message_constants_1.TOPIC.PARSER }, parseResult.action, parseResult.raw && parseResult.raw.toString());\n                return;\n            }\n            const message = parseResult;\n            const res = message_parser_1.parseData(message);\n            if (res !== true) {\n                this.services.logger.error({ topic: message_constants_1.TOPIC.PARSER }, message_constants_1.PARSER_ACTIONS.INVALID_MESSAGE, res);\n            }\n            if (message === null) {\n                return;\n            }\n            if (message.topic === message_constants_1.TOPIC.CONNECTION) {\n                this.handleConnectionResponse(message);\n                return;\n            }\n            if (message.topic === message_constants_1.TOPIC.AUTH) {\n                this.handleAuthResponse(message);\n                return;\n            }\n            const handler = this.handlers.get(message.topic);\n            if (!handler) {\n                // this should never happen\n                return;\n            }\n            handler(message);\n        });\n    }\n    /**\n    * Sends authentication params to the server. Please note, this\n    * doesn't use the queued message mechanism, but rather sends the message directly\n    */\n    sendAuthParams() {\n        this.stateMachine.transition(\"authenticate\" /* AUTHENTICATE */);\n        this.sendMessage({\n            topic: message_constants_1.TOPIC.AUTH,\n            action: message_constants_1.AUTH_ACTIONS.REQUEST,\n            parsedData: this.authParams\n        });\n    }\n    /**\n    * Ensures that a heartbeat was not missed more than once, otherwise it considers the connection\n    * to have been lost and closes it for reconnection.\n    */\n    checkHeartBeat() {\n        const heartBeatTolerance = this.options.heartbeatInterval * 2;\n        if (Date.now() - this.lastHeartBeat > heartBeatTolerance) {\n            this.services.timerRegistry.remove(this.heartbeatInterval);\n            this.services.logger.error({ topic: message_constants_1.TOPIC.CONNECTION }, constants_1.EVENT.HEARTBEAT_TIMEOUT);\n            if (this.endpoint) {\n                this.endpoint.close();\n            }\n            return;\n        }\n        this.heartbeatInterval = this.services.timerRegistry.add({\n            duration: this.options.heartbeatInterval,\n            callback: this.checkHeartBeat,\n            context: this\n        });\n    }\n    /**\n    * If the connection drops or is closed in error this\n    * method schedules increasing reconnection intervals\n    *\n    * If the number of failed reconnection attempts exceeds\n    * options.maxReconnectAttempts the connection is closed\n    */\n    tryReconnect() {\n        if (this.reconnectTimeout !== null) {\n            return;\n        }\n        if (this.reconnectionAttempt < this.options.maxReconnectAttempts) {\n            this.stateMachine.transition(\"reconnect\" /* RECONNECT */);\n            // @ts-ignore\n            this.reconnectTimeout = setTimeout(this.tryOpen.bind(this), Math.min(this.options.maxReconnectInterval, this.options.reconnectIntervalIncrement * this.reconnectionAttempt));\n            this.reconnectionAttempt++;\n            return;\n        }\n        this.emitter.emit(constants_1.EVENT[constants_1.EVENT.MAX_RECONNECTION_ATTEMPTS_REACHED], this.reconnectionAttempt);\n        this.clearReconnect();\n        this.close();\n    }\n    /**\n     * Attempts to open a errourosly closed connection\n     */\n    tryOpen() {\n        if (this.stateMachine.state !== constants_1.CONNECTION_STATE.REDIRECTING) {\n            this.url = this.originalUrl;\n        }\n        this.createEndpoint();\n        this.reconnectTimeout = null;\n    }\n    /**\n     * Stops all further reconnection attempts,\n     * either because the connection is open again\n     * or because the maximal number of reconnection\n     * attempts has been exceeded\n     */\n    clearReconnect() {\n        if (this.reconnectTimeout) {\n            // @ts-ignore\n            clearTimeout(this.reconnectTimeout);\n        }\n        this.reconnectTimeout = null;\n        this.reconnectionAttempt = 0;\n    }\n    /**\n     * The connection response will indicate whether the deepstream connection\n     * can be used or if it should be forwarded to another instance. This\n     * allows us to introduce load-balancing if needed.\n     *\n     * If authentication parameters are already provided this will kick of\n     * authentication immediately. The actual 'open' event won't be emitted\n     * by the client until the authentication is successful.\n     *\n     * If a challenge is recieved, the user will send the url to the server\n     * in response to get the appropriate redirect. If the URL is invalid the\n     * server will respond with a REJECTION resulting in the client connection\n     * being permanently closed.\n     *\n     * If a redirect is recieved, this connection is closed and updated with\n     * a connection to the url supplied in the message.\n     */\n    handleConnectionResponse(message) {\n        if (message.action === message_constants_1.CONNECTION_ACTIONS.PING) {\n            this.lastHeartBeat = Date.now();\n            if (this.getConnectionState() !== constants_1.CONNECTION_STATE.CLOSING &&\n                this.getConnectionState() !== constants_1.CONNECTION_STATE.PAUSING) {\n                this.sendMessage({ topic: message_constants_1.TOPIC.CONNECTION, action: message_constants_1.CONNECTION_ACTIONS.PONG });\n            }\n            return;\n        }\n        if (message.action === message_constants_1.CONNECTION_ACTIONS.ACCEPT) {\n            this.stateMachine.transition(\"accepted\" /* CHALLENGE_ACCEPTED */);\n            return;\n        }\n        if (message.action === message_constants_1.CONNECTION_ACTIONS.REJECT) {\n            this.stateMachine.transition(\"challenge-denied\" /* CHALLENGE_DENIED */);\n            if (this.endpoint) {\n                this.endpoint.close();\n            }\n            return;\n        }\n        if (message.action === message_constants_1.CONNECTION_ACTIONS.REDIRECT) {\n            this.url = message.url;\n            this.stateMachine.transition(\"redirected\" /* CONNECTION_REDIRECTED */);\n            if (this.endpoint) {\n                this.endpoint.close();\n            }\n            return;\n        }\n        if (message.action === message_constants_1.CONNECTION_ACTIONS.AUTHENTICATION_TIMEOUT) {\n            this.stateMachine.transition(\"authentication-timeout\" /* AUTHENTICATION_TIMEOUT */);\n            this.services.logger.error(message);\n        }\n    }\n    /**\n     * Callback for messages received for the AUTH topic. If\n     * the authentication was successful this method will\n     * open the connection and send all messages that the client\n     * tried to send so far.\n     */\n    handleAuthResponse(message) {\n        if (message.action === message_constants_1.AUTH_ACTIONS.TOO_MANY_AUTH_ATTEMPTS) {\n            this.stateMachine.transition(\"too-many-auth-attempts\" /* TOO_MANY_AUTH_ATTEMPTS */);\n            this.services.logger.error(message);\n            return;\n        }\n        if (message.action === message_constants_1.AUTH_ACTIONS.AUTH_UNSUCCESSFUL) {\n            this.stateMachine.transition(\"unsuccesful-login\" /* UNSUCCESFUL_LOGIN */);\n            this.onAuthUnSuccessful();\n            return;\n        }\n        if (message.action === message_constants_1.AUTH_ACTIONS.AUTH_SUCCESSFUL) {\n            this.stateMachine.transition(\"succesful-login\" /* SUCCESFUL_LOGIN */);\n            this.onAuthSuccessful(message.parsedData);\n            return;\n        }\n    }\n    onAwaitingAuthentication() {\n        if (this.authParams) {\n            this.sendAuthParams();\n        }\n    }\n    onAuthSuccessful(clientData) {\n        this.updateClientData(clientData);\n        if (this.resumeCallback) {\n            this.resumeCallback();\n            this.resumeCallback = null;\n        }\n        if (this.authCallback === null) {\n            return;\n        }\n        this.authCallback(true, this.clientData);\n        this.authCallback = null;\n    }\n    onAuthUnSuccessful() {\n        const reason = { reason: constants_1.EVENT[constants_1.EVENT.INVALID_AUTHENTICATION_DETAILS] };\n        if (this.resumeCallback) {\n            this.resumeCallback(reason);\n            this.resumeCallback = null;\n        }\n        if (this.authCallback === null) {\n            this.emitter.emit(constants_1.EVENT.REAUTHENTICATION_FAILURE, reason);\n            return;\n        }\n        this.authCallback(false, reason);\n        this.authCallback = null;\n    }\n    updateClientData(data) {\n        const newClientData = data || null;\n        if (this.clientData === null &&\n            (newClientData === null || Object.keys(newClientData).length === 0)) {\n            return;\n        }\n        if (!utils.deepEquals(this.clientData, data)) {\n            this.emitter.emit(constants_1.EVENT.CLIENT_DATA_CHANGED, Object.assign({}, newClientData));\n            this.clientData = newClientData;\n        }\n    }\n}\nexports.Connection = Connection;\n\n\n//# sourceURL=webpack://deepstream/./src/connection/connection.ts?");

/***/ }),

/***/ "./src/connection/socket-factory.ts":
/*!******************************************!*\
  !*** ./src/connection/socket-factory.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst NodeWebSocket = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'ws'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst message_parser_1 = __webpack_require__(/*! ../../binary-protocol/src/message-parser */ \"./binary-protocol/src/message-parser.ts\");\nconst message_builder_1 = __webpack_require__(/*! ../../binary-protocol/src/message-builder */ \"./binary-protocol/src/message-builder.ts\");\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nconst BrowserWebsocket = (global.WebSocket || global.MozWebSocket);\nexports.socketFactory = (url, options) => {\n    const socket = BrowserWebsocket\n        ? new BrowserWebsocket(url, [], options)\n        : new NodeWebSocket(url, options);\n    if (BrowserWebsocket) {\n        socket.binaryType = 'arraybuffer';\n    }\n    // tslint:disable-next-line:no-empty\n    socket.onparsedmessage = () => { };\n    socket.onmessage = (raw) => {\n        const parseResults = message_parser_1.parse(BrowserWebsocket ? new Buffer(new Uint8Array(raw.data)) : raw.data);\n        socket.onparsedmessages(parseResults);\n    };\n    socket.sendParsedMessage = (message) => {\n        if (message.topic === message_constants_1.TOPIC.CONNECTION && message.action === message_constants_1.CONNECTION_ACTIONS.CLOSING) {\n            socket.onparsedmessages([{ topic: message_constants_1.TOPIC.CONNECTION, action: message_constants_1.CONNECTION_ACTIONS.CLOSED }]);\n            socket.close();\n            return;\n        }\n        message.data = JSON.stringify(message.parsedData);\n        // if (message.action !== CONNECTION_ACTIONS.PONG && message.action !== CONNECTION_ACTIONS.PING) {\n        //     console.log('>>>', TOPIC[message.topic], (ACTIONS as any)[message.topic][message.action], message.parsedData, message.data, message.name)\n        // }\n        socket.send(message_builder_1.getMessage(message, false));\n    };\n    return socket;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../node_modules/buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://deepstream/./src/connection/socket-factory.ts?");

/***/ }),

/***/ "./src/constants.ts":
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar EVENT;\n(function (EVENT) {\n    EVENT[EVENT[\"UNSOLICITED_MESSAGE\"] = 0] = \"UNSOLICITED_MESSAGE\";\n    EVENT[EVENT[\"IS_CLOSED\"] = 1] = \"IS_CLOSED\";\n    EVENT[EVENT[\"MAX_RECONNECTION_ATTEMPTS_REACHED\"] = 2] = \"MAX_RECONNECTION_ATTEMPTS_REACHED\";\n    EVENT[EVENT[\"CONNECTION_ERROR\"] = 3] = \"CONNECTION_ERROR\";\n    EVENT[EVENT[\"ACK_TIMEOUT\"] = 4] = \"ACK_TIMEOUT\";\n    EVENT[EVENT[\"UNKNOWN_CORRELATION_ID\"] = 5] = \"UNKNOWN_CORRELATION_ID\";\n    EVENT[EVENT[\"HEARTBEAT_TIMEOUT\"] = 6] = \"HEARTBEAT_TIMEOUT\";\n    EVENT[EVENT[\"LISTENER_EXISTS\"] = 7] = \"LISTENER_EXISTS\";\n    EVENT[EVENT[\"NOT_LISTENING\"] = 8] = \"NOT_LISTENING\";\n    EVENT[EVENT[\"RECORD_ALREADY_DESTROYED\"] = 9] = \"RECORD_ALREADY_DESTROYED\";\n    EVENT[EVENT[\"RECORD_DELETE_TIMEOUT\"] = 10] = \"RECORD_DELETE_TIMEOUT\";\n    EVENT[\"CLIENT_OFFLINE\"] = \"client offline\";\n    EVENT[\"INVALID_AUTHENTICATION_DETAILS\"] = \"INVALID_AUTHENTICATION_DETAILS\";\n    EVENT[\"CONNECTION_LOST\"] = \"connectionLost\";\n    EVENT[\"CONNECTION_REESTABLISHED\"] = \"connectionReestablished\";\n    EVENT[\"EXIT_LIMBO\"] = \"exitLimbo\";\n    EVENT[\"CONNECTION_STATE_CHANGED\"] = \"connectionStateChanged\";\n    EVENT[\"CLIENT_DATA_CHANGED\"] = \"clientDataChanged\";\n    EVENT[\"REAUTHENTICATION_FAILURE\"] = \"reauthenticationFailure\";\n    EVENT[\"AUTHENTICATION_TIMEOUT\"] = \"AUTHENTICATION_TIMEOUT\";\n    EVENT[\"RECORD_ERROR\"] = \"error\";\n    EVENT[\"RECORD_READY\"] = \"ready\";\n    EVENT[\"RECORD_DELETED\"] = \"delete\";\n    EVENT[\"RECORD_DISCARDED\"] = \"discard\";\n    EVENT[\"RECORD_VERSION_EXISTS\"] = \"versionExists\";\n    EVENT[\"RECORD_HAS_PROVIDER_CHANGED\"] = \"hasProviderChanged\";\n    EVENT[\"RECORD_STATE_CHANGED\"] = \"onRecordStateChanged\";\n    EVENT[\"ENTRY_ADDED_EVENT\"] = \"entry-added\";\n    EVENT[\"ENTRY_REMOVED_EVENT\"] = \"entry-removed\";\n    EVENT[\"ENTRY_MOVED_EVENT\"] = \"entry-moved\";\n})(EVENT = exports.EVENT || (exports.EVENT = {}));\nvar CONNECTION_STATE;\n(function (CONNECTION_STATE) {\n    CONNECTION_STATE[\"CLOSING\"] = \"CLOSING\";\n    CONNECTION_STATE[\"CLOSED\"] = \"CLOSED\";\n    CONNECTION_STATE[\"INITIALISING\"] = \"INITIALISING\";\n    CONNECTION_STATE[\"AWAITING_CONNECTION\"] = \"AWAITING_CONNECTION\";\n    CONNECTION_STATE[\"CHALLENGING\"] = \"CHALLENGING\";\n    CONNECTION_STATE[\"AWAITING_AUTHENTICATION\"] = \"AWAITING_AUTHENTICATION\";\n    CONNECTION_STATE[\"AUTHENTICATING\"] = \"AUTHENTICATING\";\n    CONNECTION_STATE[\"OPEN\"] = \"OPEN\";\n    CONNECTION_STATE[\"ERROR\"] = \"ERROR\";\n    CONNECTION_STATE[\"RECONNECTING\"] = \"RECONNECTING\";\n    CONNECTION_STATE[\"REDIRECTING\"] = \"REDIRECTING\";\n    CONNECTION_STATE[\"CHALLENGE_DENIED\"] = \"CHALLENGE_DENIED\";\n    CONNECTION_STATE[\"TOO_MANY_AUTH_ATTEMPTS\"] = \"TOO_MANY_AUTH_ATTEMPTS\";\n    CONNECTION_STATE[\"AUTHENTICATION_TIMEOUT\"] = \"AUTHENTICATION_TIMEOUT\";\n    CONNECTION_STATE[\"PAUSING\"] = \"PAUSING\";\n    CONNECTION_STATE[\"OFFLINE\"] = \"OFFLINE\";\n})(CONNECTION_STATE = exports.CONNECTION_STATE || (exports.CONNECTION_STATE = {}));\n\n\n//# sourceURL=webpack://deepstream/./src/constants.ts?");

/***/ }),

/***/ "./src/deepstream.ts":
/*!***************************!*\
  !*** ./src/deepstream.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n__webpack_require__(/*! source-map-support */ \"./node_modules/source-map-support/source-map-support.js\").install();\nconst client_1 = __webpack_require__(/*! ./client */ \"./src/client.ts\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\nconst C = __webpack_require__(/*! ../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nconst client = (url, options) => {\n    return new client_1.Client(url, options);\n};\nmodule.exports = Object.assign(client, {\n    CONNECTION_STATE: constants_1.CONNECTION_STATE,\n    C,\n    EVENT: constants_1.EVENT,\n    deepstream: client\n});\n\n\n//# sourceURL=webpack://deepstream/./src/deepstream.ts?");

/***/ }),

/***/ "./src/event/event-handler.ts":
/*!************************************!*\
  !*** ./src/event/event-handler.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nconst listener_1 = __webpack_require__(/*! ../util/listener */ \"./src/util/listener.ts\");\nconst Emitter = __webpack_require__(/*! component-emitter2 */ \"./node_modules/component-emitter2/index.js\");\nclass EventHandler {\n    constructor(services, options, listeners) {\n        this.services = services;\n        this.listeners = listeners || new listener_1.Listener(message_constants_1.TOPIC.EVENT, services);\n        this.emitter = new Emitter();\n        this.limboQueue = [];\n        this.services.connection.registerHandler(message_constants_1.TOPIC.EVENT, this.handle.bind(this));\n        this.services.connection.onExitLimbo(this.onExitLimbo.bind(this));\n        this.services.connection.onReestablished(this.onConnectionReestablished.bind(this));\n    }\n    /**\n    * Subscribe to an event. This will receive both locally emitted events\n    * as well as events emitted by other connected clients.\n    */\n    subscribe(name, callback) {\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument name');\n        }\n        if (typeof callback !== 'function') {\n            throw new Error('invalid argument callback');\n        }\n        if (!this.emitter.hasListeners(name)) {\n            if (this.services.connection.isConnected) {\n                this.sendSubscriptionMessage(name);\n            }\n        }\n        this.emitter.on(name, callback);\n    }\n    /**\n     * Removes a callback for a specified event. If all callbacks\n     * for an event have been removed, the server will be notified\n     * that the client is unsubscribed as a listener\n     */\n    unsubscribe(name, callback) {\n        if (!name || typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument name');\n        }\n        if (callback !== undefined && typeof callback !== 'function') {\n            throw new Error('invalid argument callback');\n        }\n        if (!this.emitter.hasListeners(name)) {\n            this.services.logger.warn({\n                topic: message_constants_1.TOPIC.EVENT,\n                action: message_constants_1.EVENT_ACTIONS.NOT_SUBSCRIBED,\n                name\n            });\n            return;\n        }\n        this.emitter.off(name, callback);\n        if (!this.emitter.hasListeners(name)) {\n            const message = {\n                topic: message_constants_1.TOPIC.EVENT,\n                action: message_constants_1.EVENT_ACTIONS.UNSUBSCRIBE,\n                name\n            };\n            this.services.timeoutRegistry.add({ message });\n            this.services.connection.sendMessage(message);\n        }\n    }\n    /**\n     * Emits an event locally and sends a message to the server to\n     * broadcast the event to the other connected clients\n     */\n    emit(name, data) {\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument name');\n        }\n        const message = {\n            topic: message_constants_1.TOPIC.EVENT,\n            action: message_constants_1.EVENT_ACTIONS.EMIT,\n            name,\n            parsedData: data\n        };\n        if (this.services.connection.isConnected) {\n            this.services.connection.sendMessage(message);\n        }\n        else if (this.services.connection.isInLimbo) {\n            this.limboQueue.push(message);\n        }\n        this.emitter.emit(name, data);\n    }\n    /**\n   * Allows to listen for event subscriptions made by this or other clients. This\n   * is useful to create \"active\" data providers, e.g. providers that only provide\n   * data for a particular event if a user is actually interested in it\n   */\n    listen(pattern, callback) {\n        this.listeners.listen(pattern, callback);\n    }\n    /**\n     * Removes a listener that was previously registered\n     */\n    unlisten(pattern) {\n        this.listeners.unlisten(pattern);\n    }\n    /**\n   * Handles incoming messages from the server\n   */\n    handle(message) {\n        if (message.isAck) {\n            this.services.timeoutRegistry.remove(message);\n            return;\n        }\n        if (message.action === message_constants_1.EVENT_ACTIONS.EMIT) {\n            if (message.parsedData !== undefined) {\n                this.emitter.emit(message.name, message.parsedData);\n            }\n            else {\n                this.emitter.emit(message.name, undefined);\n            }\n            return;\n        }\n        if (message.action === message_constants_1.EVENT_ACTIONS.MESSAGE_DENIED) {\n            this.services.logger.error({ topic: message_constants_1.TOPIC.EVENT }, message_constants_1.EVENT_ACTIONS.MESSAGE_DENIED);\n            this.services.timeoutRegistry.remove(message);\n            if (message.originalAction === message_constants_1.EVENT_ACTIONS.SUBSCRIBE) {\n                this.emitter.off(message.name);\n            }\n            return;\n        }\n        if (message.action === message_constants_1.EVENT_ACTIONS.MULTIPLE_SUBSCRIPTIONS) {\n            this.services.timeoutRegistry.remove(Object.assign({}, message, {\n                action: message_constants_1.EVENT_ACTIONS.SUBSCRIBE\n            }));\n            this.services.logger.warn(message);\n            return;\n        }\n        if (message.action === message_constants_1.EVENT_ACTIONS.NOT_SUBSCRIBED) {\n            this.services.timeoutRegistry.remove(Object.assign({}, message, {\n                action: message_constants_1.EVENT_ACTIONS.SUBSCRIBE\n            }));\n            this.services.logger.warn(message);\n            return;\n        }\n        if (message.action === message_constants_1.EVENT_ACTIONS.SUBSCRIPTION_FOR_PATTERN_FOUND ||\n            message.action === message_constants_1.EVENT_ACTIONS.SUBSCRIPTION_FOR_PATTERN_REMOVED) {\n            this.listeners.handle(message);\n            return;\n        }\n        if (message.action === message_constants_1.EVENT_ACTIONS.INVALID_LISTEN_REGEX) {\n            this.services.logger.error(message);\n            return;\n        }\n        this.services.logger.error(message, constants_1.EVENT.UNSOLICITED_MESSAGE);\n    }\n    /**\n     * Resubscribes to events when connection is lost\n     */\n    onConnectionReestablished() {\n        const callbacks = this.emitter.eventNames();\n        for (const name of callbacks) {\n            this.sendSubscriptionMessage(name);\n        }\n        for (let i = 0; i < this.limboQueue.length; i++) {\n            this.services.connection.sendMessage(this.limboQueue[i]);\n        }\n        this.limboQueue = [];\n    }\n    onExitLimbo() {\n        this.limboQueue = [];\n    }\n    sendSubscriptionMessage(name) {\n        const message = {\n            topic: message_constants_1.TOPIC.EVENT,\n            action: message_constants_1.EVENT_ACTIONS.SUBSCRIBE,\n            name\n        };\n        this.services.timeoutRegistry.add({ message });\n        this.services.connection.sendMessage(message);\n    }\n}\nexports.EventHandler = EventHandler;\n\n\n//# sourceURL=webpack://deepstream/./src/event/event-handler.ts?");

/***/ }),

/***/ "./src/presence/presence-handler.ts":
/*!******************************************!*\
  !*** ./src/presence/presence-handler.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nconst Emitter = __webpack_require__(/*! component-emitter2 */ \"./node_modules/component-emitter2/index.js\");\nconst ONLY_EVENT = 'OE';\nfunction validateQueryArguments(rest) {\n    let users = null;\n    let callback = null;\n    if (rest.length === 1) {\n        if (Array.isArray(rest[0])) {\n            users = rest[0];\n        }\n        else {\n            if (typeof rest[0] !== 'function') {\n                throw new Error('invalid argument: \"callback\"');\n            }\n            callback = rest[0];\n        }\n    }\n    else if (rest.length === 2) {\n        users = rest[0];\n        callback = rest[1];\n        if (!Array.isArray(users) || typeof callback !== 'function') {\n            throw new Error('invalid argument: \"users\" or \"callback\"');\n        }\n    }\n    return { users, callback };\n}\nclass PresenceHandler {\n    constructor(services, options) {\n        this.services = services;\n        this.subscriptionEmitter = new Emitter();\n        this.globalSubscriptionEmitter = new Emitter();\n        this.queryEmitter = new Emitter();\n        this.queryAllEmitter = new Emitter();\n        this.services.connection.registerHandler(message_constants_1.TOPIC.PRESENCE, this.handle.bind(this));\n        this.services.connection.onExitLimbo(this.onExitLimbo.bind(this));\n        this.services.connection.onLost(this.onExitLimbo.bind(this));\n        this.services.connection.onReestablished(this.onConnectionReestablished.bind(this));\n        this.counter = 0;\n        this.pendingSubscribes = new Set();\n        this.pendingUnsubscribes = new Set();\n        this.limboQueue = [];\n        this.flushTimeout = null;\n    }\n    subscribe(userOrCallback, callback) {\n        if (typeof userOrCallback === 'string' && userOrCallback.length > 0 && typeof callback === 'function') {\n            const user = userOrCallback;\n            if (!this.subscriptionEmitter.hasListeners(user)) {\n                this.pendingSubscribes.add(user);\n            }\n            this.subscriptionEmitter.on(user, callback);\n            this.pendingUnsubscribes.delete(user);\n            this.registerFlushTimeout();\n            return;\n        }\n        if (typeof userOrCallback === 'function' && typeof callback === 'undefined') {\n            if (!this.globalSubscriptionEmitter.hasListeners(ONLY_EVENT)) {\n                this.subscribeToAllChanges();\n            }\n            this.globalSubscriptionEmitter.on(ONLY_EVENT, userOrCallback);\n            return;\n        }\n        throw new Error('invalid arguments: \"user\" or \"callback\"');\n    }\n    unsubscribe(userOrCallback, callback) {\n        if (userOrCallback && typeof userOrCallback === 'string' && userOrCallback.length > 0) {\n            const user = userOrCallback;\n            if (callback) {\n                if (typeof callback !== 'function') {\n                    throw new Error('invalid argument: \"callback\"');\n                }\n                this.subscriptionEmitter.off(user, callback);\n            }\n            else {\n                this.subscriptionEmitter.off(user);\n            }\n            if (!this.subscriptionEmitter.hasListeners(user)) {\n                this.pendingSubscribes.delete(user);\n                this.pendingUnsubscribes.add(user);\n                this.registerFlushTimeout();\n            }\n            return;\n        }\n        if (userOrCallback && typeof userOrCallback === 'function') {\n            callback = userOrCallback;\n            this.globalSubscriptionEmitter.off(ONLY_EVENT, callback);\n            if (!this.globalSubscriptionEmitter.hasListeners(ONLY_EVENT)) {\n                this.unsubscribeToAllChanges();\n            }\n            return;\n        }\n        if (typeof userOrCallback === 'undefined' && typeof callback === 'undefined') {\n            this.subscriptionEmitter.off();\n            this.globalSubscriptionEmitter.off();\n            this.pendingSubscribes.clear();\n            const users = this.subscriptionEmitter.eventNames();\n            for (let i = 0; i < users.length; i++) {\n                this.pendingUnsubscribes.add(users[i]);\n            }\n            this.registerFlushTimeout();\n            this.unsubscribeToAllChanges();\n            return;\n        }\n        throw new Error('invalid argument: \"user\" or \"callback\"');\n    }\n    getAll(...rest) {\n        const { callback, users } = validateQueryArguments(rest);\n        let message;\n        let emitter;\n        let emitterAction;\n        if (users) {\n            const queryId = (this.counter++).toString();\n            message = {\n                topic: message_constants_1.TOPIC.PRESENCE,\n                action: message_constants_1.PRESENCE_ACTIONS.QUERY,\n                correlationId: queryId,\n                names: users\n            };\n            emitter = this.queryEmitter;\n            emitterAction = queryId;\n        }\n        else {\n            message = {\n                topic: message_constants_1.TOPIC.PRESENCE,\n                action: message_constants_1.PRESENCE_ACTIONS.QUERY_ALL\n            };\n            emitter = this.queryAllEmitter;\n            emitterAction = ONLY_EVENT;\n        }\n        if (this.services.connection.isConnected) {\n            this.sendQuery(message);\n        }\n        else if (this.services.connection.isInLimbo) {\n            this.limboQueue.push(message);\n        }\n        else {\n            this.services.timerRegistry.requestIdleCallback(() => {\n                emitter.emit(emitterAction, constants_1.EVENT.CLIENT_OFFLINE);\n            });\n        }\n        if (callback) {\n            emitter.once(emitterAction, callback);\n            return;\n        }\n        return new Promise((resolve, reject) => {\n            emitter.once(emitterAction, (error, results) => error ? reject(error) : resolve(results));\n        });\n    }\n    handle(message) {\n        if (message.isAck) {\n            this.services.timeoutRegistry.remove(message);\n            return;\n        }\n        if (message.action === message_constants_1.PRESENCE_ACTIONS.QUERY_ALL_RESPONSE) {\n            this.queryAllEmitter.emit(ONLY_EVENT, null, message.names);\n            this.services.timeoutRegistry.remove(message);\n            return;\n        }\n        if (message.action === message_constants_1.PRESENCE_ACTIONS.QUERY_RESPONSE) {\n            this.queryEmitter.emit(message.correlationId, null, message.parsedData);\n            this.services.timeoutRegistry.remove(message);\n            return;\n        }\n        if (message.action === message_constants_1.PRESENCE_ACTIONS.PRESENCE_JOIN) {\n            this.subscriptionEmitter.emit(message.name, message.name, true);\n            return;\n        }\n        if (message.action === message_constants_1.PRESENCE_ACTIONS.PRESENCE_JOIN_ALL) {\n            this.globalSubscriptionEmitter.emit(ONLY_EVENT, message.name, true);\n            return;\n        }\n        if (message.action === message_constants_1.PRESENCE_ACTIONS.PRESENCE_LEAVE) {\n            this.subscriptionEmitter.emit(message.name, message.name, false);\n            return;\n        }\n        if (message.action === message_constants_1.PRESENCE_ACTIONS.PRESENCE_LEAVE_ALL) {\n            this.globalSubscriptionEmitter.emit(ONLY_EVENT, message.name, false);\n            return;\n        }\n        if (message.isError) {\n            this.services.timeoutRegistry.remove(message);\n            if (message.originalAction === message_constants_1.PRESENCE_ACTIONS.QUERY) {\n                this.queryEmitter.emit(message.correlationId, message_constants_1.PRESENCE_ACTIONS[message.action]);\n            }\n            else if (message.originalAction === message_constants_1.PRESENCE_ACTIONS.QUERY_ALL) {\n                this.queryAllEmitter.emit(ONLY_EVENT, message_constants_1.PRESENCE_ACTIONS[message.action]);\n            }\n            else {\n                this.services.logger.error(message);\n            }\n            return;\n        }\n        this.services.logger.error(message, constants_1.EVENT.UNSOLICITED_MESSAGE);\n    }\n    sendQuery(message) {\n        this.services.connection.sendMessage(message);\n        this.services.timeoutRegistry.add({ message });\n    }\n    flush() {\n        if (!this.services.connection.isConnected) {\n            // will be handled by resubscribe\n            return;\n        }\n        const subUsers = Array.from(this.pendingSubscribes.keys());\n        if (subUsers.length > 0) {\n            this.bulkSubscription(message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE, subUsers);\n            this.pendingSubscribes.clear();\n        }\n        const unsubUsers = Array.from(this.pendingUnsubscribes.keys());\n        if (unsubUsers.length > 0) {\n            this.bulkSubscription(message_constants_1.PRESENCE_ACTIONS.UNSUBSCRIBE, unsubUsers);\n            this.pendingUnsubscribes.clear();\n        }\n        this.flushTimeout = null;\n    }\n    bulkSubscription(action, names) {\n        const correlationId = this.counter++;\n        const message = {\n            topic: message_constants_1.TOPIC.PRESENCE,\n            action,\n            correlationId: correlationId.toString(),\n            names\n        };\n        this.services.timeoutRegistry.add({ message });\n        this.services.connection.sendMessage(message);\n    }\n    subscribeToAllChanges() {\n        if (!this.services.connection.isConnected) {\n            return;\n        }\n        const message = { topic: message_constants_1.TOPIC.PRESENCE, action: message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE_ALL };\n        this.services.timeoutRegistry.add({ message });\n        this.services.connection.sendMessage(message);\n    }\n    unsubscribeToAllChanges() {\n        if (!this.services.connection.isConnected) {\n            return;\n        }\n        const message = { topic: message_constants_1.TOPIC.PRESENCE, action: message_constants_1.PRESENCE_ACTIONS.UNSUBSCRIBE_ALL };\n        this.services.timeoutRegistry.add({ message });\n        this.services.connection.sendMessage(message);\n    }\n    registerFlushTimeout() {\n        if (!this.flushTimeout) {\n            this.flushTimeout = this.services.timerRegistry.add({\n                duration: 0,\n                context: this,\n                callback: this.flush\n            });\n        }\n    }\n    onConnectionReestablished() {\n        const keys = this.subscriptionEmitter.eventNames();\n        if (keys.length > 0) {\n            this.bulkSubscription(message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE, keys);\n        }\n        const hasGlobalSubscription = this.globalSubscriptionEmitter.hasListeners(ONLY_EVENT);\n        if (hasGlobalSubscription) {\n            this.subscribeToAllChanges();\n        }\n        for (let i = 0; i < this.limboQueue.length; i++) {\n            this.sendQuery(this.limboQueue[i]);\n        }\n        this.limboQueue = [];\n    }\n    onExitLimbo() {\n        this.queryEmitter.eventNames().forEach(correlationId => {\n            this.queryEmitter.emit(correlationId, constants_1.EVENT.CLIENT_OFFLINE);\n        });\n        this.queryAllEmitter.emit(ONLY_EVENT, constants_1.EVENT.CLIENT_OFFLINE);\n        this.limboQueue = [];\n        this.queryAllEmitter.off();\n        this.queryEmitter.off();\n    }\n}\nexports.PresenceHandler = PresenceHandler;\n\n\n//# sourceURL=webpack://deepstream/./src/presence/presence-handler.ts?");

/***/ }),

/***/ "./src/record/anonymous-record.ts":
/*!****************************************!*\
  !*** ./src/record/anonymous-record.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils = __webpack_require__(/*! ../util/utils */ \"./src/util/utils.ts\");\nconst Emitter = __webpack_require__(/*! component-emitter2 */ \"./node_modules/component-emitter2/index.js\");\nclass AnonymousRecord extends Emitter {\n    constructor(getRecordCore) {\n        super();\n        this.record = null;\n        this.subscriptions = [];\n        this.getRecordCore = getRecordCore;\n    }\n    get name() {\n        if (!this.record) {\n            return '';\n        }\n        return this.record.name;\n    }\n    get isReady() {\n        if (!this.record) {\n            return false;\n        }\n        return this.record.isReady;\n    }\n    get version() {\n        if (!this.record) {\n            return -1;\n        }\n        return this.record.version;\n    }\n    whenReady(callback) {\n        if (this.record) {\n            return this.record.whenReady(this, callback);\n        }\n    }\n    setName(recordName, callback) {\n        if (this.name === recordName) {\n            return;\n        }\n        this.discard();\n        this.record = this.getRecordCore(recordName);\n        for (let i = 0; i < this.subscriptions.length; i++) {\n            this.record.subscribe(this.subscriptions[i]);\n        }\n        this.emit('nameChanged', recordName);\n        return this.record.whenReady(this, callback);\n    }\n    get(path) {\n        if (this.record) {\n            return this.record.get(path);\n        }\n    }\n    set(path, data, callback) {\n        if (this.record) {\n            return this.record.set(utils.normalizeSetArguments(arguments));\n        }\n    }\n    setWithAck(path, data, callback) {\n        if (this.record) {\n            return this.record.setWithAck(utils.normalizeSetArguments(arguments));\n        }\n    }\n    erase(path) {\n        if (this.record) {\n            return this.record.set(utils.normalizeSetArguments(arguments));\n        }\n    }\n    eraseWithAck(path, callback) {\n        if (this.record) {\n            return this.record.setWithAck(utils.normalizeSetArguments(arguments));\n        }\n    }\n    subscribe(path, callback, triggerNow) {\n        const parameters = utils.normalizeArguments(arguments);\n        this.subscriptions.push(parameters);\n        if (this.record) {\n            this.record.subscribe(parameters);\n        }\n    }\n    unsubscribe(path, callback) {\n        const parameters = utils.normalizeArguments(arguments);\n        this.subscriptions = this.subscriptions.filter(subscription => {\n            return (subscription.path !== parameters.path ||\n                subscription.callback !== parameters.callback);\n        });\n        if (this.record) {\n            this.record.unsubscribe(parameters);\n        }\n    }\n    discard() {\n        if (this.record) {\n            for (let i = 0; i < this.subscriptions.length; i++) {\n                this.record.unsubscribe(this.subscriptions[i]);\n            }\n            return this.record.discard();\n        }\n    }\n    delete(callback) {\n        if (this.record) {\n            return this.record.delete(callback);\n        }\n    }\n    setMergeStrategy(mergeStrategy) {\n        if (this.record) {\n            this.record.setMergeStrategy(mergeStrategy);\n        }\n    }\n}\nexports.AnonymousRecord = AnonymousRecord;\n\n\n//# sourceURL=webpack://deepstream/./src/record/anonymous-record.ts?");

/***/ }),

/***/ "./src/record/dirty-service.ts":
/*!*************************************!*\
  !*** ./src/record/dirty-service.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Emitter = __webpack_require__(/*! component-emitter2 */ \"./node_modules/component-emitter2/index.js\");\nconst DIRTY_SERVICE_LOADED = 'dirty-service-loaded';\nclass DirtyService {\n    constructor(storage, dirtyStorageName) {\n        this.storage = storage;\n        this.name = dirtyStorageName;\n        this.loaded = false;\n        this.emitter = new Emitter();\n        this.dirtyRecords = {};\n        this.load();\n    }\n    isDirty(recordName) {\n        return !!this.dirtyRecords[recordName];\n    }\n    setDirty(recordName, isDirty) {\n        this.updateDirtyRecords(recordName, isDirty);\n    }\n    whenLoaded(callback) {\n        if (this.loaded) {\n            callback();\n            return;\n        }\n        this.emitter.once(DIRTY_SERVICE_LOADED, () => {\n            callback();\n        });\n    }\n    getAll() {\n        return this.dirtyRecords;\n    }\n    load() {\n        if (this.loaded) {\n            return;\n        }\n        this.storage.get(this.name, (recordName, version, data) => {\n            this.dirtyRecords = version !== -1 ? data : {};\n            this.loaded = true;\n            this.emitter.emit(DIRTY_SERVICE_LOADED);\n        });\n    }\n    updateDirtyRecords(recordName, isDirty) {\n        if (isDirty) {\n            this.dirtyRecords[recordName] = true;\n        }\n        else {\n            delete this.dirtyRecords[recordName];\n        }\n        this.storage.set(this.name, 1, this.dirtyRecords, () => { });\n    }\n}\nexports.DirtyService = DirtyService;\n\n\n//# sourceURL=webpack://deepstream/./src/record/dirty-service.ts?");

/***/ }),

/***/ "./src/record/json-path.ts":
/*!*********************************!*\
  !*** ./src/record/json-path.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils = __webpack_require__(/*! ../util/utils */ \"./src/util/utils.ts\");\nconst SPLIT_REG_EXP = /[[\\]]/g;\n/**\n* Returns the value of the path or\n* undefined if the path can't be resolved\n*/\nfunction get(data, path, deepCopy) {\n    const tokens = tokenize(path);\n    let value = data;\n    for (let i = 0; i < tokens.length; i++) {\n        if (value === undefined) {\n            return undefined;\n        }\n        if (typeof value !== 'object') {\n            throw new Error('invalid data or path');\n        }\n        value = value[tokens[i]];\n    }\n    return deepCopy !== false ? utils.deepCopy(value) : value;\n}\nexports.get = get;\n/**\n * This class allows to set or get specific\n * values within a json data structure using\n * string-based paths\n */\nfunction setValue(root, path, value) {\n    if (path === null) {\n        return value;\n    }\n    const tokens = tokenize(path);\n    const rootCopy = utils.deepCopy(root);\n    const valueCopy = utils.deepCopy(value);\n    let node = rootCopy;\n    let i;\n    for (i = 0; i < tokens.length - 1; i++) {\n        const token = tokens[i];\n        if (node[token] !== undefined && node[token] !== null && typeof node[token] === 'object') {\n            node = node[token];\n        }\n        else if (typeof tokens[i + 1] === 'number') {\n            const array = new Array(tokens[i + 1]);\n            array.fill(null);\n            node = node[token] = array;\n        }\n        else {\n            node = node[token] = {};\n        }\n    }\n    if (value === undefined) {\n        delete node[tokens[i]];\n    }\n    else {\n        node[tokens[i]] = valueCopy;\n    }\n    return rootCopy;\n}\nexports.setValue = setValue;\n/**\n * Parses the path. Splits it into\n * keys for objects and indices for arrays.\n */\nfunction tokenize(path) {\n    if (path === null) {\n        return [];\n    }\n    const tokens = [];\n    const parts = path.split('.');\n    for (let i = 0; i < parts.length; i++) {\n        const part = parts[i].trim();\n        if (part.length === 0) {\n            continue;\n        }\n        const arrayIndexes = part.split(SPLIT_REG_EXP);\n        if (arrayIndexes.length === 0) {\n            // TODO\n            continue;\n        }\n        tokens.push(arrayIndexes[0]);\n        for (let j = 1; j < arrayIndexes.length; j++) {\n            if (arrayIndexes[j].length === 0) {\n                continue;\n            }\n            tokens.push(Number(arrayIndexes[j]));\n        }\n    }\n    return tokens;\n}\n\n\n//# sourceURL=webpack://deepstream/./src/record/json-path.ts?");

/***/ }),

/***/ "./src/record/list.ts":
/*!****************************!*\
  !*** ./src/record/list.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils = __webpack_require__(/*! ../util/utils */ \"./src/util/utils.ts\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nconst Emitter = __webpack_require__(/*! component-emitter2 */ \"./node_modules/component-emitter2/index.js\");\nclass List extends Emitter {\n    constructor(record) {\n        super();\n        this.record = record;\n        this.originalApplyUpdate = this.record.applyUpdate.bind(this.record);\n        this.record.applyUpdate = this.applyUpdate.bind(this);\n        this.wrappedFunctions = new Map();\n        this.hasAddListener = false;\n        this.hasRemoveListener = false;\n        this.hasMoveListener = false;\n    }\n    get name() {\n        return this.record.name;\n    }\n    get isReady() {\n        return this.record.isReady;\n    }\n    get version() {\n        return this.record.version;\n    }\n    whenReady(callback) {\n        return this.record.whenReady(this, callback);\n    }\n    /**\n     * Returns the array of list entries or an\n     * empty array if the list hasn't been populated yet.\n     */\n    getEntries() {\n        const entries = this.record.get();\n        if (!(entries instanceof Array)) {\n            return [];\n        }\n        return entries;\n    }\n    /**\n   * Returns true if the list is empty\n   */\n    isEmpty() {\n        return this.getEntries().length === 0;\n    }\n    /**\n* Updates the list with a new set of entries\n*/\n    setEntriesWithAck(entries, callback) {\n        if (!callback) {\n            return new Promise((resolve, reject) => {\n                this.setEntries(entries, (error) => {\n                    if (error) {\n                        reject(error);\n                    }\n                    else {\n                        resolve();\n                    }\n                });\n            });\n        }\n        this.setEntries(entries, callback);\n    }\n    /**\n    * Updates the list with a new set of entries\n    */\n    setEntries(entries, callback) {\n        const errorMsg = 'entries must be an array of record names';\n        let i;\n        if (!(entries instanceof Array)) {\n            throw new Error(errorMsg);\n        }\n        for (i = 0; i < entries.length; i++) {\n            if (typeof entries[i] !== 'string') {\n                throw new Error(errorMsg);\n            }\n        }\n        if (this.record.isReady === false) {\n            // ...\n        }\n        else {\n            this.beforeChange();\n            this.record.set({ data: entries, callback });\n            this.afterChange();\n        }\n    }\n    /**\n     * Removes an entry from the list\n     *\n     * @param {String} entry\n     * @param {Number} [index]\n     */\n    removeEntry(entry, index, callback) {\n        if (this.record.isReady === false) {\n            // ...\n            return;\n        }\n        const currentEntries = this.record.get();\n        const hasIndex = this.hasIndex(index);\n        const entries = [];\n        let i;\n        for (i = 0; i < currentEntries.length; i++) {\n            if (currentEntries[i] !== entry || (hasIndex && index !== i)) {\n                entries.push(currentEntries[i]);\n            }\n        }\n        this.beforeChange();\n        this.record.set({ data: entries, callback });\n        this.afterChange();\n    }\n    /**\n   * Adds an entry to the list\n   *\n   * @param {String} entry\n   * @param {Number} [index]\n   */\n    addEntry(entry, index, callback) {\n        if (typeof entry !== 'string') {\n            throw new Error('Entry must be a recordName');\n        }\n        if (this.record.isReady === false) {\n            // ..\n            return;\n        }\n        const hasIndex = this.hasIndex(index);\n        const entries = this.getEntries();\n        if (hasIndex) {\n            entries.splice(index, 0, entry);\n        }\n        else {\n            entries.push(entry);\n        }\n        this.beforeChange();\n        this.record.set({ data: entries, callback });\n        this.afterChange();\n    }\n    /**\n   * Proxies the underlying Record's subscribe method. Makes sure\n   * that no path is provided\n   */\n    subscribe(callback) {\n        const parameters = utils.normalizeArguments(arguments);\n        if (parameters.path) {\n            throw new Error('path is not supported for List.subscribe');\n        }\n        // Make sure the callback is invoked with an empty array for new records\n        const listCallback = function (scope, cb) {\n            cb(scope.getEntries());\n        }.bind(this, this, parameters.callback);\n        /**\n        * Adding a property onto a function directly is terrible practice,\n        * and we will change this as soon as we have a more seperate approach\n        * of creating lists that doesn't have records default state.\n        *\n        * The reason we are holding a referencing to wrapped array is so that\n        * on unsubscribe it can provide a reference to the actual method the\n        * record is subscribed too.\n        **/\n        this.wrappedFunctions.set(parameters.callback, listCallback);\n        parameters.callback = listCallback;\n        this.record.subscribe(parameters);\n    }\n    /**\n   * Proxies the underlying Record's unsubscribe method. Makes sure\n   * that no path is provided\n   */\n    unsubscribe(callback) {\n        const parameters = utils.normalizeArguments(arguments);\n        if (parameters.path) {\n            throw new Error('path is not supported for List.unsubscribe');\n        }\n        const listenCallback = this.wrappedFunctions.get(parameters.callback);\n        parameters.callback = listenCallback;\n        this.record.unsubscribe(parameters);\n        this.wrappedFunctions.delete(parameters.callback);\n    }\n    /**\n     * Proxies the underlying Record's _update method. Set's\n     * data to an empty array if no data is provided.\n     */\n    applyUpdate(message) {\n        if (!(message.parsedData instanceof Array)) {\n            message.parsedData = [];\n        }\n        this.beforeChange();\n        this.originalApplyUpdate(message);\n        this.afterChange();\n    }\n    /**\n     * Validates that the index provided is within the current set of entries.\n     */\n    hasIndex(index) {\n        let hasIndex = false;\n        const entries = this.getEntries();\n        if (index !== undefined) {\n            if (isNaN(index)) {\n                throw new Error('Index must be a number');\n            }\n            if (index !== entries.length && (index >= entries.length || index < 0)) {\n                throw new Error('Index must be within current entries');\n            }\n            hasIndex = true;\n        }\n        return hasIndex;\n    }\n    /**\n     * Establishes the current structure of the list, provided the client has attached any\n     * add / move / remove listener\n     *\n     * This will be called before any change to the list, regardsless if the change was triggered\n     * by an incoming message from the server or by the client\n     */\n    beforeChange() {\n        this.hasAddListener = this.listeners(constants_1.EVENT.ENTRY_ADDED_EVENT).length > 0;\n        this.hasRemoveListener = this.listeners(constants_1.EVENT.ENTRY_REMOVED_EVENT).length > 0;\n        this.hasMoveListener = this.listeners(constants_1.EVENT.ENTRY_MOVED_EVENT).length > 0;\n        if (this.hasAddListener || this.hasRemoveListener || this.hasMoveListener) {\n            this.beforeStructure = this.getStructure();\n        }\n        else {\n            this.beforeStructure = null;\n        }\n    }\n    /**\n     * Compares the structure of the list after a change to its previous structure and notifies\n     * any add / move / remove listener. Won't do anything if no listeners are attached.\n     */\n    afterChange() {\n        if (this.beforeStructure === null) {\n            return;\n        }\n        const after = this.getStructure();\n        const before = this.beforeStructure;\n        let entry;\n        let i;\n        if (this.hasRemoveListener) {\n            for (entry in before) {\n                for (i = 0; i < before[entry].length; i++) {\n                    if (after[entry] === undefined || after[entry][i] === undefined) {\n                        this.emit(constants_1.EVENT.ENTRY_REMOVED_EVENT, entry, before[entry][i]);\n                    }\n                }\n            }\n        }\n        if (this.hasAddListener || this.hasMoveListener) {\n            for (entry in after) {\n                if (before[entry] === undefined) {\n                    for (i = 0; i < after[entry].length; i++) {\n                        this.emit(constants_1.EVENT.ENTRY_ADDED_EVENT, entry, after[entry][i]);\n                    }\n                }\n                else {\n                    for (i = 0; i < after[entry].length; i++) {\n                        if (before[entry][i] !== after[entry][i]) {\n                            if (before[entry][i] === undefined) {\n                                this.emit(constants_1.EVENT.ENTRY_ADDED_EVENT, entry, after[entry][i]);\n                            }\n                            else {\n                                this.emit(constants_1.EVENT.ENTRY_MOVED_EVENT, entry, after[entry][i]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Iterates through the list and creates a map with the entry as a key\n     * and an array of its position(s) within the list as a value, e.g.\n     *\n     * {\n     *   'recordA': [ 0, 3 ],\n     *   'recordB': [ 1 ],\n     *   'recordC': [ 2 ]\n     * }\n     */\n    getStructure() {\n        const structure = {};\n        let i;\n        const entries = this.record.get();\n        for (i = 0; i < entries.length; i++) {\n            if (structure[entries[i]] === undefined) {\n                structure[entries[i]] = [i];\n            }\n            else {\n                structure[entries[i]].push(i);\n            }\n        }\n        return structure;\n    }\n}\nexports.List = List;\n\n\n//# sourceURL=webpack://deepstream/./src/record/list.ts?");

/***/ }),

/***/ "./src/record/merge-strategy-service.ts":
/*!**********************************************!*\
  !*** ./src/record/merge-strategy-service.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nclass MergeStrategyService {\n    constructor(services, defaultStrategy) {\n        this.services = services;\n        this.defaultStrategy = defaultStrategy;\n        this.strategiesByRecord = new Map();\n        this.strategiesByPattern = new Map();\n    }\n    setMergeStrategyByName(recordName, strategy) {\n        this.strategiesByRecord.set(recordName, strategy);\n    }\n    setMergeStrategyByPattern(pattern, strategy) {\n        this.strategiesByPattern.set(pattern, strategy);\n    }\n    merge(recordName, localVersion, localData, remoteVersion, remoteData, callback) {\n        const exactMergeStrategy = this.strategiesByRecord.get(recordName);\n        if (exactMergeStrategy) {\n            exactMergeStrategy(localData, localVersion, remoteData, remoteVersion, (error, data) => {\n                callback(error, recordName, data, remoteVersion, remoteData, localVersion, localData);\n            });\n            return;\n        }\n        for (const [pattern, patternMergeStrategy] of this.strategiesByPattern) {\n            if (pattern.test(recordName)) {\n                patternMergeStrategy(localData, localVersion, remoteData, remoteVersion, (error, data) => {\n                    callback(error, recordName, data, remoteVersion, remoteData, localVersion, localData);\n                });\n                return;\n            }\n        }\n        if (this.defaultStrategy) {\n            this.defaultStrategy(localData, localVersion, remoteData, remoteVersion, (error, data) => {\n                callback(error, recordName, data, remoteVersion, remoteData, localVersion, localData);\n            });\n        }\n        this.services.logger.error({ topic: message_constants_1.TOPIC.RECORD }, constants_1.EVENT.RECORD_VERSION_EXISTS, { remoteVersion, recordName });\n    }\n}\nexports.MergeStrategyService = MergeStrategyService;\n\n\n//# sourceURL=webpack://deepstream/./src/record/merge-strategy-service.ts?");

/***/ }),

/***/ "./src/record/merge-strategy.ts":
/*!**************************************!*\
  !*** ./src/record/merge-strategy.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n *  Choose the server's state over the client's\n**/\nexports.REMOTE_WINS = (localValue, localVersion, remoteValue, remoteVersion, callback) => {\n    callback(null, remoteValue);\n};\n/**\n *  Choose the local state over the server's\n**/\nexports.LOCAL_WINS = (localValue, localVersion, remoteValue, remoteVersion, callback) => {\n    callback(null, localValue);\n};\n\n\n//# sourceURL=webpack://deepstream/./src/record/merge-strategy.ts?");

/***/ }),

/***/ "./src/record/record-core.ts":
/*!***********************************!*\
  !*** ./src/record/record-core.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nconst json_path_1 = __webpack_require__(/*! ./json-path */ \"./src/record/json-path.ts\");\nconst Emitter = __webpack_require__(/*! component-emitter2 */ \"./node_modules/component-emitter2/index.js\");\nconst utils = __webpack_require__(/*! ../util/utils */ \"./src/util/utils.ts\");\nconst state_machine_1 = __webpack_require__(/*! ../util/state-machine */ \"./src/util/state-machine.ts\");\nclass RecordCore extends Emitter {\n    constructor(name, services, options, recordServices, whenComplete) {\n        super();\n        this.services = services;\n        this.options = options;\n        this.recordServices = recordServices;\n        this.emitter = new Emitter();\n        this.data = Object.create(null);\n        this.name = name;\n        this.whenComplete = whenComplete;\n        this.references = 1;\n        this.hasProvider = false;\n        this.pendingWrites = [];\n        this.isReady = false;\n        this.version = null;\n        this.responseTimeout = -1;\n        this.discardTimeout = -1;\n        this.deletedTimeout = -1;\n        this.deleteResponse = {};\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument name');\n        }\n        this.stateMachine = new state_machine_1.StateMachine(this.services.logger, {\n            init: 0 /* INITIAL */,\n            onStateChanged: (newState, oldState) => {\n                this.emitter.emit(constants_1.EVENT.RECORD_STATE_CHANGED, newState);\n            },\n            transitions: [\n                { name: message_constants_1.RECORD_ACTIONS.SUBSCRIBE, from: 0 /* INITIAL */, to: 1 /* SUBSCRIBING */, handler: this.onSubscribing.bind(this) },\n                { name: 0 /* LOAD */, from: 0 /* INITIAL */, to: 3 /* LOADING_OFFLINE */, handler: this.onOfflineLoading.bind(this) },\n                { name: 1 /* LOADED */, from: 3 /* LOADING_OFFLINE */, to: 4 /* READY */, handler: this.onReady.bind(this) },\n                { name: message_constants_1.RECORD_ACTIONS.READ_RESPONSE, from: 1 /* SUBSCRIBING */, to: 4 /* READY */, handler: this.onReady.bind(this) },\n                { name: 2 /* SUBSCRIBED */, from: 2 /* RESUBSCRIBING */, to: 4 /* READY */ },\n                { name: 3 /* RESUBSCRIBE */, from: 0 /* INITIAL */, to: 2 /* RESUBSCRIBING */, handler: this.onResubscribing.bind(this) },\n                { name: 3 /* RESUBSCRIBE */, from: 4 /* READY */, to: 2 /* RESUBSCRIBING */, handler: this.onResubscribing.bind(this) },\n                { name: 3 /* RESUBSCRIBE */, from: 6 /* UNSUBSCRIBING */, to: 2 /* RESUBSCRIBING */, handler: this.onResubscribing.bind(this) },\n                { name: 4 /* RESUBSCRIBED */, from: 2 /* RESUBSCRIBING */, to: 4 /* READY */ },\n                { name: 5 /* INVALID_VERSION */, from: 2 /* RESUBSCRIBING */, to: 5 /* MERGING */ },\n                { name: message_constants_1.RECORD_ACTIONS.DELETE, from: 4 /* READY */, to: 8 /* DELETING */ },\n                { name: message_constants_1.RECORD_ACTIONS.DELETED, from: 4 /* READY */, to: 9 /* DELETED */, handler: this.onDeleted.bind(this) },\n                { name: message_constants_1.RECORD_ACTIONS.DELETE_SUCCESS, from: 8 /* DELETING */, to: 9 /* DELETED */, handler: this.onDeleted.bind(this) },\n                { name: message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE, from: 4 /* READY */, to: 6 /* UNSUBSCRIBING */ },\n                { name: message_constants_1.RECORD_ACTIONS.SUBSCRIBE, from: 6 /* UNSUBSCRIBING */, to: 4 /* READY */ },\n                { name: message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE_ACK, from: 6 /* UNSUBSCRIBING */, to: 7 /* UNSUBSCRIBED */, handler: this.onUnsubscribed.bind(this) },\n                { name: 5 /* INVALID_VERSION */, from: 4 /* READY */, to: 5 /* MERGING */ },\n            ]\n        });\n        this.handleReadResponse = this.handleReadResponse.bind(this);\n        this.onRecordRecovered = this.onRecordRecovered.bind(this);\n        this.onConnectionReestablished = this.onConnectionReestablished.bind(this);\n        this.onConnectionLost = this.onConnectionLost.bind(this);\n        this.handleReadResponse = this.handleReadResponse.bind(this);\n        this.handleHeadResponse = this.handleHeadResponse.bind(this);\n        this.recordServices.dirtyService.whenLoaded(() => {\n            if (this.services.connection.isConnected) {\n                if (!this.recordServices.dirtyService.isDirty(this.name)) {\n                    this.stateMachine.transition(message_constants_1.RECORD_ACTIONS.SUBSCRIBE);\n                }\n                else {\n                    this.services.storage.get(this.name, (recordName, version, data) => {\n                        this.version = version;\n                        this.data = data;\n                        this.stateMachine.transition(3 /* RESUBSCRIBE */);\n                    });\n                }\n            }\n            else {\n                this.stateMachine.transition(0 /* LOAD */);\n            }\n            this.services.connection.onReestablished(this.onConnectionReestablished);\n            this.services.connection.onLost(this.onConnectionLost);\n        });\n    }\n    get recordState() {\n        return this.stateMachine.state;\n    }\n    set usages(usages) {\n        this.references = usages;\n        if (this.references === 1) {\n            this.services.timerRegistry.remove(this.discardTimeout);\n            this.stateMachine.transition(message_constants_1.RECORD_ACTIONS.SUBSCRIBE);\n        }\n    }\n    get usages() {\n        return this.references;\n    }\n    /**\n   * Convenience method, similar to promises. Executes callback\n   * whenever the record is ready, either immediatly or once the ready\n   * event is fired\n   * @param   {[Function]} callback Will be called when the record is ready\n   */\n    whenReady(context, callback) {\n        if (this.isReady === true) {\n            if (callback) {\n                callback(context);\n                return;\n            }\n            return Promise.resolve(context);\n        }\n        if (callback) {\n            this.once(constants_1.EVENT.RECORD_READY, () => callback(context));\n        }\n        else {\n            return new Promise((resolve, reject) => {\n                this.once(constants_1.EVENT.RECORD_READY, () => resolve(context));\n            });\n        }\n    }\n    /**\n   * Sets the value of either the entire dataset\n   * or of a specific path within the record\n   * and submits the changes to the server\n   *\n   * If the new data is equal to the current data, nothing will happen\n   *\n   * @param {[String|Object]} pathOrData Either a JSON path when called with\n   *                                     two arguments or the data itself\n   * @param {Object} data     The data that should be stored in the record\n   */\n    set({ path, data, callback }) {\n        if (!path && (data === null || typeof data !== 'object')) {\n            throw new Error('invalid arguments, scalar values cannot be set without path');\n        }\n        if (this.checkDestroyed('set')) {\n            return;\n        }\n        if (!this.isReady) {\n            this.pendingWrites.push({ path, data, callback });\n            return;\n        }\n        const oldValue = this.data;\n        const newValue = json_path_1.setValue(oldValue, path || null, data);\n        if (oldValue === newValue) {\n            if (callback) {\n                this.services.timerRegistry.requestIdleCallback(() => callback(null, this.name));\n            }\n            return;\n        }\n        this.applyChange(newValue);\n        if (this.services.connection.isConnected) {\n            this.sendUpdate(path, data, callback);\n        }\n        else {\n            if (callback) {\n                callback(constants_1.EVENT.CLIENT_OFFLINE, this.name);\n            }\n            this.saveUpdate();\n        }\n    }\n    /**\n     * Wrapper function around the record.set that returns a promise\n     * if no callback is supplied.\n     * @returns {Promise} if a callback is omitted a Promise is returned with the result of the write\n     */\n    setWithAck(args) {\n        if (args.callback) {\n            this.set(args);\n            return;\n        }\n        return new Promise((resolve, reject) => {\n            args.callback = error => error === null ? resolve() : reject(error);\n            this.set(args);\n        });\n    }\n    /**\n   * Returns a copy of either the entire dataset of the record\n   * or - if called with a path - the value of that path within\n   * the record's dataset.\n   *\n   * Returning a copy rather than the actual value helps to prevent\n   * the record getting out of sync due to unintentional changes to\n   * its data\n   */\n    get(path) {\n        return json_path_1.get(this.data, path || null, this.options.recordDeepCopy);\n    }\n    /**\n   * Subscribes to changes to the records dataset.\n   *\n   * Callback is the only mandatory argument.\n   *\n   * When called with a path, it will only subscribe to updates\n   * to that path, rather than the entire record\n   *\n   * If called with true for triggerNow, the callback will\n   * be called immediatly with the current value\n   */\n    subscribe(args) {\n        if (args.path !== undefined && (typeof args.path !== 'string' || args.path.length === 0)) {\n            throw new Error('invalid argument path');\n        }\n        if (typeof args.callback !== 'function') {\n            throw new Error('invalid argument callback');\n        }\n        if (this.checkDestroyed('subscribe')) {\n            return;\n        }\n        if (args.triggerNow) {\n            this.whenReady(null, () => {\n                this.emitter.on(args.path || '', args.callback);\n                args.callback(this.get(args.path));\n            });\n        }\n        else {\n            this.emitter.on(args.path || '', args.callback);\n        }\n    }\n    /**\n     * Removes a subscription that was previously made using record.subscribe()\n     *\n     * Can be called with a path to remove the callback for this specific\n     * path or only with a callback which removes it from the generic subscriptions\n     *\n     * Please Note: unsubscribe is a purely client side operation. If the app is no longer\n     * interested in receiving updates for this record from the server it needs to call\n     * discard instead\n     *\n     * @param   {String}           path  A JSON path\n     * @param   {Function}         callback     The callback method. Please note, if a bound\n     *                                          method was passed to subscribe, the same method\n     *                                          must be passed to unsubscribe as well.\n     */\n    unsubscribe(args) {\n        if (args.path !== undefined && (typeof args.path !== 'string' || args.path.length === 0)) {\n            throw new Error('invalid argument path');\n        }\n        if (args.callback !== undefined && typeof args.callback !== 'function') {\n            throw new Error('invalid argument callback');\n        }\n        if (this.checkDestroyed('unsubscribe')) {\n            return;\n        }\n        this.emitter.off(args.path || '', args.callback);\n    }\n    /**\n    * Removes all change listeners and notifies the server that the client is\n    * no longer interested in updates for this record\n    */\n    discard() {\n        if (this.checkDestroyed('discard')) {\n            return;\n        }\n        this.whenReady(null, () => {\n            this.references--;\n            if (this.references <= 0) {\n                this.discardTimeout = this.services.timerRegistry.add({\n                    duration: this.options.discardTimeout,\n                    callback: this.stateMachine.transition,\n                    context: this.stateMachine,\n                    data: message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE_ACK\n                });\n            }\n        });\n        this.stateMachine.transition(message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE);\n    }\n    /**\n     * Deletes the record on the server.\n     */\n    delete(callback) {\n        if (!this.services.connection.isConnected) {\n            // this.services.logger.warn({ topic: TOPIC.RECORD }, RA.DELETE, 'Deleting while offline is not supported')\n            if (callback) {\n                this.services.timerRegistry.requestIdleCallback(() => {\n                    callback('Deleting while offline is not supported');\n                });\n                return;\n            }\n            return Promise.reject('Deleting while offline is not supported');\n        }\n        if (this.checkDestroyed('delete')) {\n            return;\n        }\n        this.stateMachine.transition(message_constants_1.RECORD_ACTIONS.DELETE);\n        if (callback && typeof callback === 'function') {\n            this.deleteResponse = { callback };\n            this.sendDelete();\n        }\n        else {\n            return new Promise((resolve, reject) => {\n                this.deleteResponse = { resolve, reject };\n                this.sendDelete();\n            });\n        }\n    }\n    /**\n     * Set a merge strategy to resolve any merge conflicts that may occur due\n     * to offline work or write conflicts. The function will be called with the\n     * local record, the remote version/data and a callback to call once the merge has\n     * completed or if an error occurs ( which leaves it in an inconsistent state until\n     * the next update merge attempt ).\n     */\n    setMergeStrategy(mergeStrategy) {\n        this.recordServices.mergeStrategy.setMergeStrategyByName(this.name, mergeStrategy);\n    }\n    saveRecordToOffline() {\n        this.services.storage.set(this.name, this.version, this.data, () => { });\n    }\n    /**\n     * Transition States\n     */\n    onSubscribing() {\n        this.recordServices.readRegistry.register(this.name, this.handleReadResponse);\n        this.services.timeoutRegistry.add({\n            message: {\n                topic: message_constants_1.TOPIC.RECORD,\n                action: message_constants_1.RECORD_ACTIONS.SUBSCRIBE,\n                name: this.name,\n            }\n        });\n        this.responseTimeout = this.services.timeoutRegistry.add({\n            message: {\n                topic: message_constants_1.TOPIC.RECORD,\n                action: message_constants_1.RECORD_ACTIONS.READ_RESPONSE,\n                name: this.name\n            }\n        });\n        this.services.connection.sendMessage({\n            topic: message_constants_1.TOPIC.RECORD,\n            action: message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD,\n            name: this.name\n        });\n    }\n    onResubscribing() {\n        this.services.timerRegistry.remove(this.discardTimeout);\n        this.recordServices.headRegistry.register(this.name, this.handleHeadResponse);\n        this.services.timeoutRegistry.add({\n            message: {\n                topic: message_constants_1.TOPIC.RECORD,\n                action: message_constants_1.RECORD_ACTIONS.SUBSCRIBE,\n                name: this.name,\n            }\n        });\n        this.responseTimeout = this.services.timeoutRegistry.add({\n            message: {\n                topic: message_constants_1.TOPIC.RECORD,\n                action: message_constants_1.RECORD_ACTIONS.HEAD_RESPONSE,\n                name: this.name\n            }\n        });\n        this.services.connection.sendMessage({\n            topic: message_constants_1.TOPIC.RECORD,\n            action: message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD,\n            name: this.name\n        });\n    }\n    onOfflineLoading() {\n        this.services.storage.get(this.name, (recordName, version, data) => {\n            if (version === -1) {\n                this.data = {};\n                this.version = 1;\n                this.recordServices.dirtyService.setDirty(this.name, true);\n                this.services.storage.set(this.name, this.version, this.data, error => {\n                    this.stateMachine.transition(1 /* LOADED */);\n                });\n            }\n            else {\n                this.data = data;\n                this.version = version;\n                this.stateMachine.transition(1 /* LOADED */);\n            }\n        });\n    }\n    onReady() {\n        this.services.timeoutRegistry.clear(this.responseTimeout);\n        this.applyPendingWrites();\n        this.isReady = true;\n        this.emit(constants_1.EVENT.RECORD_READY);\n    }\n    applyPendingWrites() {\n        const writeCallbacks = [];\n        const oldData = this.data;\n        let newData = oldData;\n        for (let i = 0; i < this.pendingWrites.length; i++) {\n            const { callback, path, data } = this.pendingWrites[i];\n            if (callback) {\n                writeCallbacks.push(callback);\n            }\n            newData = json_path_1.setValue(newData, path || null, data);\n        }\n        this.pendingWrites = [];\n        this.applyChange(newData);\n        const runFns = (err) => {\n            for (let i = 0; i < writeCallbacks.length; i++) {\n                writeCallbacks[i](err, this.name);\n            }\n        };\n        if (utils.deepEquals(oldData, newData)) {\n            runFns(null);\n            return;\n        }\n        if (this.services.connection.isConnected) {\n            this.sendUpdate(null, newData, runFns);\n        }\n        else {\n            runFns(constants_1.EVENT.CLIENT_OFFLINE);\n            this.saveUpdate();\n        }\n    }\n    onUnsubscribed() {\n        if (this.services.connection.isConnected) {\n            const message = {\n                topic: message_constants_1.TOPIC.RECORD,\n                action: message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE,\n                name: this.name\n            };\n            this.discardTimeout = this.services.timeoutRegistry.add({ message });\n            this.services.connection.sendMessage(message);\n        }\n        this.emit(constants_1.EVENT.RECORD_DISCARDED);\n        this.destroy();\n    }\n    onDeleted() {\n        this.emit(constants_1.EVENT.RECORD_DELETED);\n        this.destroy();\n    }\n    handle(message) {\n        if (message.isAck) {\n            this.services.timeoutRegistry.remove(message);\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.PATCH || message.action === message_constants_1.RECORD_ACTIONS.UPDATE || message.action === message_constants_1.RECORD_ACTIONS.ERASE) {\n            this.applyUpdate(message);\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.DELETE_SUCCESS) {\n            this.services.timeoutRegistry.clear(this.deletedTimeout);\n            this.stateMachine.transition(message.action);\n            if (this.deleteResponse.callback) {\n                this.deleteResponse.callback(null);\n            }\n            else if (this.deleteResponse.resolve) {\n                this.deleteResponse.resolve();\n            }\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.DELETED) {\n            this.stateMachine.transition(message.action);\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.VERSION_EXISTS) {\n            // what kind of message is version exists?\n            // this.recoverRecord(message)\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED ||\n            message.action === message_constants_1.RECORD_ACTIONS.MESSAGE_PERMISSION_ERROR) {\n            if (message.originalAction === message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD ||\n                message.originalAction === message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD ||\n                message.originalAction === message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDREAD) {\n                const subscribeMsg = Object.assign({}, message, { originalAction: message_constants_1.RECORD_ACTIONS.SUBSCRIBE });\n                const actionMsg = Object.assign({}, message, { originalAction: message.originalAction === message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD ? message_constants_1.RECORD_ACTIONS.READ_RESPONSE : message_constants_1.RECORD_ACTIONS.HEAD_RESPONSE });\n                this.services.timeoutRegistry.remove(subscribeMsg);\n                this.services.timeoutRegistry.remove(actionMsg);\n            }\n            this.emit(constants_1.EVENT.RECORD_ERROR, message_constants_1.RECORD_ACTIONS[message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED], message_constants_1.RECORD_ACTIONS[message.originalAction]);\n            if (message.originalAction === message_constants_1.RECORD_ACTIONS.DELETE) {\n                if (this.deleteResponse.callback) {\n                    this.deleteResponse.callback(message_constants_1.RECORD_ACTIONS[message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED]);\n                }\n                else if (this.deleteResponse.reject) {\n                    this.deleteResponse.reject(message_constants_1.RECORD_ACTIONS[message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED]);\n                }\n            }\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_PROVIDER ||\n            message.action === message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_NO_PROVIDER) {\n            this.hasProvider = message.action === message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_PROVIDER;\n            this.emit(constants_1.EVENT.RECORD_HAS_PROVIDER_CHANGED, this.hasProvider);\n            return;\n        }\n    }\n    handleReadResponse(message) {\n        if (this.stateMachine.state === 5 /* MERGING */) {\n            this.recoverRecord(message.version, message.parsedData, message);\n            this.recordServices.dirtyService.setDirty(this.name, false);\n            return;\n        }\n        this.version = message.version;\n        this.applyChange(json_path_1.setValue(this.data, null, message.parsedData));\n        this.stateMachine.transition(message_constants_1.RECORD_ACTIONS.READ_RESPONSE);\n    }\n    handleHeadResponse(message) {\n        const remoteVersion = message.version;\n        if (this.recordServices.dirtyService.isDirty(this.name)) {\n            if (remoteVersion === -1 && this.version === 1) {\n                /**\n                 * Record created while offline\n                 */\n                this.stateMachine.transition(2 /* SUBSCRIBED */);\n                this.sendCreateUpdate(this.data);\n            }\n            else if (this.version === remoteVersion + 1) {\n                /**\n                 * record updated while offline\n                */\n                this.sendUpdate(null, this.data);\n                this.stateMachine.transition(4 /* RESUBSCRIBED */);\n            }\n            else {\n                this.stateMachine.transition(5 /* INVALID_VERSION */);\n                this.sendRead();\n                this.recordServices.readRegistry.register(this.name, this.handleReadResponse);\n            }\n        }\n        else {\n            if (remoteVersion < this.version) {\n                /**\n                 *  deleted and created again remotely\n                */\n            }\n            else if (this.version === remoteVersion) {\n                this.stateMachine.transition(4 /* RESUBSCRIBED */);\n            }\n            else {\n                this.stateMachine.transition(5 /* INVALID_VERSION */);\n                this.sendRead();\n                this.recordServices.readRegistry.register(this.name, this.handleReadResponse);\n            }\n        }\n    }\n    sendRead() {\n        this.services.connection.sendMessage({\n            topic: message_constants_1.TOPIC.RECORD,\n            action: message_constants_1.RECORD_ACTIONS.READ,\n            name: this.name\n        });\n    }\n    saveUpdate() {\n        if (!this.recordServices.dirtyService.isDirty(this.name)) {\n            this.version++;\n            this.recordServices.dirtyService.setDirty(this.name, true);\n        }\n        this.saveRecordToOffline();\n    }\n    sendUpdate(path = null, data, callback) {\n        if (this.recordServices.dirtyService.isDirty(this.name)) {\n            this.recordServices.dirtyService.setDirty(this.name, false);\n        }\n        else {\n            this.version++;\n        }\n        const message = {\n            topic: message_constants_1.TOPIC.RECORD,\n            version: this.version,\n            name: this.name\n        };\n        if (path) {\n            if (data === undefined) {\n                Object.assign(message, { action: message_constants_1.RECORD_ACTIONS.ERASE, path });\n            }\n            else {\n                Object.assign(message, { action: message_constants_1.RECORD_ACTIONS.PATCH, path, parsedData: data });\n            }\n        }\n        else {\n            Object.assign(message, { action: message_constants_1.RECORD_ACTIONS.UPDATE, parsedData: data });\n        }\n        if (callback) {\n            this.recordServices.writeAckService.send(message, callback);\n        }\n        else {\n            this.services.connection.sendMessage(message);\n        }\n    }\n    sendCreateUpdate(data) {\n        this.services.connection.sendMessage({\n            name: this.name,\n            topic: message_constants_1.TOPIC.RECORD,\n            action: message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE,\n            version: 1,\n            parsedData: data\n        });\n        this.recordServices.dirtyService.setDirty(this.name, false);\n    }\n    /**\n     * Applies incoming updates and patches to the record's dataset\n     */\n    applyUpdate(message) {\n        const version = message.version;\n        const data = message.parsedData;\n        if (this.version === null) {\n            this.version = version;\n        }\n        else if (this.version + 1 !== version) {\n            this.stateMachine.transition(5 /* INVALID_VERSION */);\n            if (message.action === message_constants_1.RECORD_ACTIONS.PATCH) {\n                /**\n                * Request a snapshot so that a merge can be done with the read reply which contains\n                * the full state of the record\n                **/\n                this.sendRead();\n            }\n            else {\n                this.recoverRecord(message.version, message.parsedData, message);\n            }\n            return;\n        }\n        this.version = version;\n        let newData;\n        if (message.action === message_constants_1.RECORD_ACTIONS.PATCH) {\n            newData = json_path_1.setValue(this.data, message.path, data);\n        }\n        else if (message.action === message_constants_1.RECORD_ACTIONS.ERASE) {\n            newData = json_path_1.setValue(this.data, message.path, undefined);\n        }\n        else {\n            newData = json_path_1.setValue(this.data, null, data);\n        }\n        this.applyChange(newData);\n    }\n    /**\n     * Compares the new values for every path with the previously stored ones and\n     * updates the subscribers if the value has changed\n     */\n    applyChange(newData) {\n        if (this.stateMachine.inEndState) {\n            return;\n        }\n        const oldData = this.data;\n        this.data = newData;\n        const paths = this.emitter.eventNames();\n        for (let i = 0; i < paths.length; i++) {\n            const newValue = json_path_1.get(newData, paths[i], false);\n            const oldValue = json_path_1.get(oldData, paths[i], false);\n            if (newValue !== oldValue) {\n                this.emitter.emit(paths[i], this.get(paths[i]));\n            }\n        }\n    }\n    /**\n     * If connected sends the delete message to server, otherwise\n     * we delete in local storage and transition to delete success.\n     */\n    sendDelete() {\n        this.whenReady(null, () => {\n            if (this.services.connection.isConnected) {\n                const message = {\n                    topic: message_constants_1.TOPIC.RECORD,\n                    action: message_constants_1.RECORD_ACTIONS.DELETE,\n                    name: this.name\n                };\n                this.deletedTimeout = this.services.timeoutRegistry.add({\n                    message,\n                    event: constants_1.EVENT.RECORD_DELETE_TIMEOUT,\n                    duration: this.options.recordDeleteTimeout\n                });\n                this.services.connection.sendMessage(message);\n            }\n            else {\n                this.services.storage.delete(this.name, () => {\n                    this.services.timerRegistry.requestIdleCallback(() => {\n                        this.stateMachine.transition(message_constants_1.RECORD_ACTIONS.DELETE_SUCCESS);\n                    });\n                });\n            }\n        });\n    }\n    /**\n     * Called when a merge conflict is detected by a VERSION_EXISTS error or if an update recieved\n     * is directly after the clients. If no merge strategy is configure it will emit a VERSION_EXISTS\n     * error and the record will remain in an inconsistent state.\n     *\n     * @param   {Number} remoteVersion The remote version number\n     * @param   {Object} remoteData The remote object data\n     * @param   {Object} message parsed and validated deepstream message\n     */\n    recoverRecord(remoteVersion, remoteData, message) {\n        this.recordServices.mergeStrategy.merge(this.name, this.version, this.get(), remoteVersion, remoteData, this.onRecordRecovered);\n    }\n    /**\n   * Callback once the record merge has completed. If successful it will set the\n   * record state, else emit and error and the record will remain in an\n   * inconsistent state until the next update.\n   */\n    onRecordRecovered(error, mergedData, remoteVersion, remoteData) {\n        if (error) {\n            this.services.logger.error({ topic: message_constants_1.TOPIC.RECORD }, constants_1.EVENT.RECORD_VERSION_EXISTS);\n        }\n        this.version = remoteVersion;\n        const oldValue = this.data;\n        if (utils.deepEquals(oldValue, remoteData)) {\n            return;\n        }\n        const newValue = json_path_1.setValue(oldValue, null, mergedData);\n        if (utils.deepEquals(mergedData, remoteData)) {\n            this.applyChange(mergedData);\n            // const callback = this.writeCallbacks.get(remoteVersion)\n            // if (callback !== undefined) {\n            //   callback(null)\n            //   this.writeCallbacks.delete(remoteVersion)\n            // }\n            // return\n        }\n        // this.sendUpdate(null, data, message.isWriteAck)\n        this.applyChange(newValue);\n    }\n    /**\n   * A quick check that's carried out by most methods that interact with the record\n   * to make sure it hasn't been destroyed yet - and to handle it gracefully if it has.\n   */\n    checkDestroyed(methodName) {\n        if (this.stateMachine.inEndState) {\n            this.services.logger.error({ topic: message_constants_1.TOPIC.RECORD }, constants_1.EVENT.RECORD_ALREADY_DESTROYED, { methodName });\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Destroys the record and nulls all\n     * its dependencies\n     */\n    destroy() {\n        this.services.timerRegistry.remove(this.deletedTimeout);\n        this.services.timerRegistry.remove(this.discardTimeout);\n        this.services.timerRegistry.remove(this.responseTimeout);\n        this.services.connection.removeOnReestablished(this.onConnectionReestablished);\n        this.services.connection.removeOnLost(this.onConnectionLost);\n        this.emitter.off();\n        this.isReady = false;\n        this.whenComplete(this.name);\n    }\n    onConnectionReestablished() {\n        this.stateMachine.transition(3 /* RESUBSCRIBE */);\n    }\n    onConnectionLost() {\n        this.saveRecordToOffline();\n    }\n}\nexports.RecordCore = RecordCore;\n\n\n//# sourceURL=webpack://deepstream/./src/record/record-core.ts?");

/***/ }),

/***/ "./src/record/record-handler.ts":
/*!**************************************!*\
  !*** ./src/record/record-handler.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils = __webpack_require__(/*! ../util/utils */ \"./src/util/utils.ts\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nconst utils_1 = __webpack_require__(/*! ../../binary-protocol/src/utils */ \"./binary-protocol/src/utils.ts\");\nconst record_core_1 = __webpack_require__(/*! ./record-core */ \"./src/record/record-core.ts\");\nconst record_1 = __webpack_require__(/*! ./record */ \"./src/record/record.ts\");\nconst anonymous_record_1 = __webpack_require__(/*! ./anonymous-record */ \"./src/record/anonymous-record.ts\");\nconst list_1 = __webpack_require__(/*! ./list */ \"./src/record/list.ts\");\nconst listener_1 = __webpack_require__(/*! ../util/listener */ \"./src/util/listener.ts\");\nconst single_notifier_1 = __webpack_require__(/*! ./single-notifier */ \"./src/record/single-notifier.ts\");\nconst write_ack_service_1 = __webpack_require__(/*! ./write-ack-service */ \"./src/record/write-ack-service.ts\");\nconst dirty_service_1 = __webpack_require__(/*! ./dirty-service */ \"./src/record/dirty-service.ts\");\nconst merge_strategy_service_1 = __webpack_require__(/*! ./merge-strategy-service */ \"./src/record/merge-strategy-service.ts\");\nclass RecordHandler {\n    constructor(services, options, recordServices, listener) {\n        this.services = services;\n        this.options = options;\n        this.listener = listener || new listener_1.Listener(message_constants_1.TOPIC.RECORD, this.services);\n        this.recordCores = new Map();\n        this.recordServices = recordServices || {\n            writeAckService: new write_ack_service_1.WriteAcknowledgementService(services),\n            readRegistry: new single_notifier_1.SingleNotifier(services, message_constants_1.RECORD_ACTIONS.READ, options.recordReadTimeout),\n            headRegistry: new single_notifier_1.SingleNotifier(services, message_constants_1.RECORD_ACTIONS.HEAD, options.recordReadTimeout),\n            dirtyService: new dirty_service_1.DirtyService(services.storage, options.dirtyStorageName),\n            mergeStrategy: new merge_strategy_service_1.MergeStrategyService(services, options.mergeStrategy)\n        };\n        this.dirtyService = this.recordServices.dirtyService;\n        this.sendUpdatedData = this.sendUpdatedData.bind(this);\n        this.onRecordUpdated = this.onRecordUpdated.bind(this);\n        this.onMergeCompleted = this.onMergeCompleted.bind(this);\n        this.getRecordCore = this.getRecordCore.bind(this);\n        this.services.connection.registerHandler(message_constants_1.TOPIC.RECORD, this.handle.bind(this));\n        this.services.connection.onReestablished(this.syncDirtyRecords.bind(this));\n        if (this.services.connection.isConnected) {\n            this.syncDirtyRecords();\n        }\n    }\n    setMergeStrategy(recordName, mergeStrategy) {\n        if (typeof mergeStrategy === 'function') {\n            this.recordServices.mergeStrategy.setMergeStrategyByName(recordName, mergeStrategy);\n        }\n        else {\n            throw new Error('Invalid merge strategy: Must be a Function');\n        }\n    }\n    setMergeStrategyRegExp(regexp, mergeStrategy) {\n        if (typeof mergeStrategy === 'function') {\n            this.recordServices.mergeStrategy.setMergeStrategyByPattern(regexp, mergeStrategy);\n        }\n        else {\n            throw new Error('Invalid merge strategy: Must be a Function');\n        }\n    }\n    /**\n   * Returns an existing record or creates a new one.\n   *\n   * @param   {String} name              the unique name of the record\n   */\n    getRecord(name) {\n        return new record_1.Record(this.getRecordCore(name));\n    }\n    /**\n     * Returns an existing List or creates a new one. A list is a specialised\n     * type of record that holds an array of recordNames.\n     *\n     * @param   {String} name       the unique name of the list\n     */\n    getList(name) {\n        return new list_1.List(this.getRecordCore(name));\n    }\n    /**\n     * Returns an anonymous record. A anonymous record is effectively\n     * a wrapper that mimicks the API of a record, but allows for the\n     * underlying record to be swapped without loosing subscriptions etc.\n     *\n     * This is particularly useful when selecting from a number of similarly\n     * structured records. E.g. a list of users that can be choosen from a list\n     *\n     * The only API difference to a normal record is an additional setName( name ) method.\n     */\n    getAnonymousRecord() {\n        return new anonymous_record_1.AnonymousRecord(this.getRecordCore);\n    }\n    /**\n     * Allows to listen for record subscriptions made by this or other clients. This\n     * is useful to create \"active\" data providers, e.g. providers that only provide\n     * data for a particular record if a user is actually interested in it\n     *\n     * @param   {String}   pattern  A combination of alpha numeric characters and wildcards( * )\n     * @param   {Function} callback\n     */\n    listen(pattern, callback) {\n        this.listener.listen(pattern, callback);\n    }\n    /**\n     * Removes a listener that was previously registered with listenForSubscriptions\n     *\n     * @param   {String}   pattern  A combination of alpha numeric characters and wildcards( * )\n     */\n    unlisten(pattern) {\n        this.listener.unlisten(pattern);\n    }\n    snapshot(name, callback) {\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument: name');\n        }\n        if (callback !== undefined && typeof callback !== 'function') {\n            throw new Error('invalid argument: callback');\n        }\n        const recordCore = this.recordCores.get(name);\n        if (recordCore) {\n            if (callback) {\n                recordCore.whenReady(null, () => {\n                    callback(null, recordCore.get());\n                });\n            }\n            else {\n                return new Promise((resolve, reject) => {\n                    recordCore.whenReady(null, () => {\n                        resolve(recordCore.get());\n                    });\n                });\n            }\n            return;\n        }\n        if (callback) {\n            this.recordServices.readRegistry.request(name, callback);\n        }\n        else {\n            return new Promise((resolve, reject) => {\n                this.recordServices.readRegistry.request(name, (error, data) => error ? reject(error) : resolve(data));\n            });\n        }\n    }\n    has(name, callback) {\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument: name');\n        }\n        if (callback !== undefined && typeof callback !== 'function') {\n            throw new Error('invalid argument: callback');\n        }\n        let cb;\n        if (!callback) {\n            return new Promise((resolve, reject) => {\n                cb = (error, version) => error ? reject(error) : resolve(version !== -1);\n                this.head(name, cb);\n            });\n        }\n        cb = (error, version) => error ? callback(error, null) : callback(null, version !== -1);\n        this.head(name, cb);\n    }\n    head(name, callback) {\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument: name');\n        }\n        if (callback !== undefined && typeof callback !== 'function') {\n            throw new Error('invalid argument: callback');\n        }\n        const recordCore = this.recordCores.get(name);\n        if (recordCore) {\n            if (callback) {\n                recordCore.whenReady(null, () => {\n                    callback(null, recordCore.version);\n                });\n            }\n            else {\n                return new Promise((resolve, reject) => {\n                    recordCore.whenReady(null, () => {\n                        resolve(recordCore.version);\n                    });\n                });\n            }\n            return;\n        }\n        if (callback) {\n            this.recordServices.headRegistry.request(name, callback);\n        }\n        else {\n            return new Promise((resolve, reject) => {\n                this.recordServices.headRegistry.request(name, (error, data) => error ? reject(error) : resolve(data));\n            });\n        }\n    }\n    setDataWithAck(recordName, ...rest) {\n        const args = utils.normalizeSetArguments(arguments, 1);\n        if (!args.callback) {\n            return new Promise((resolve, reject) => {\n                args.callback = error => error === null ? resolve() : reject(error);\n                this.sendSetData(recordName, -1, args);\n            });\n        }\n        this.sendSetData(recordName, -1, args);\n    }\n    setData(recordName) {\n        const args = utils.normalizeSetArguments(arguments, 1);\n        this.sendSetData(recordName, -1, args);\n    }\n    sendSetData(recordName, version, args) {\n        const { path, data, callback } = args;\n        if (!recordName || typeof recordName !== 'string' || recordName.length === 0) {\n            throw new Error('invalid argument: recordName must be an non empty string');\n        }\n        if (!path && (data === null || typeof data !== 'object')) {\n            throw new Error('invalid argument: data must be an object when no path is provided');\n        }\n        const recordCores = this.recordCores.get(recordName);\n        if (recordCores) {\n            recordCores.set({ path, data, callback });\n            return;\n        }\n        let action;\n        if (path) {\n            if (data === undefined) {\n                action = message_constants_1.RECORD_ACTIONS.ERASE;\n            }\n            else {\n                action = message_constants_1.RECORD_ACTIONS.CREATEANDPATCH;\n            }\n        }\n        else {\n            action = message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE;\n        }\n        const message = {\n            topic: message_constants_1.TOPIC.RECORD,\n            action,\n            name: recordName,\n            path,\n            version,\n            parsedData: data\n        };\n        if (callback) {\n            this.recordServices.writeAckService.send(message, callback);\n        }\n        else {\n            this.services.connection.sendMessage(message);\n        }\n    }\n    /**\n     * Will be called by the client for incoming messages on the RECORD topic\n     *\n     * @param   {Object} message parsed and validated deepstream message\n     */\n    handle(message) {\n        if (message.action === message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_FOR_PATTERN_FOUND ||\n            message.action === message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_FOR_PATTERN_REMOVED ||\n            message.action === message_constants_1.RECORD_ACTIONS.LISTEN ||\n            message.action === message_constants_1.RECORD_ACTIONS.UNLISTEN) {\n            this.listener.handle(message);\n            return;\n        }\n        if (utils_1.isWriteAck(message.action) || utils_1.isWriteAck(message.originalAction)) {\n            this.recordServices.writeAckService.recieve(message);\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.READ_RESPONSE || message.originalAction === message_constants_1.RECORD_ACTIONS.READ) {\n            if (message.isError) {\n                this.recordServices.readRegistry.recieve(message, message_constants_1.RECORD_ACTIONS[message.action]);\n            }\n            else {\n                this.recordServices.readRegistry.recieve(message, null, message.parsedData);\n            }\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.HEAD_RESPONSE ||\n            message.originalAction === message_constants_1.RECORD_ACTIONS.HEAD) {\n            if (message.isError) {\n                this.recordServices.headRegistry.recieve(message, message_constants_1.RECORD_ACTIONS[message.action]);\n            }\n            else {\n                this.recordServices.headRegistry.recieve(message, null, message.version);\n            }\n        }\n        const recordCore = this.recordCores.get(message.name);\n        if (recordCore) {\n            recordCore.handle(message);\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.VERSION_EXISTS) {\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_PROVIDER ||\n            message.action === message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_NO_PROVIDER) {\n            // record can receive a HAS_PROVIDER after discarding the record\n            return;\n        }\n        if (message.isError) {\n            this.services.logger.error(message);\n            return;\n        }\n        this.services.logger.error(message, constants_1.EVENT.UNSOLICITED_MESSAGE);\n    }\n    /**\n     * Callback for 'deleted' and 'discard' events from a record. Removes the record from\n     * the registry\n     */\n    removeRecord(recordName) {\n        this.recordCores.delete(recordName);\n    }\n    getRecordCore(recordName) {\n        let recordCore = this.recordCores.get(recordName);\n        if (!recordCore) {\n            recordCore = new record_core_1.RecordCore(recordName, this.services, this.options, this.recordServices, this.removeRecord.bind(this));\n            this.recordCores.set(recordName, recordCore);\n        }\n        else {\n            recordCore.usages++;\n        }\n        return recordCore;\n    }\n    syncDirtyRecords() {\n        this.dirtyService.whenLoaded(() => {\n            const dirtyRecords = this.dirtyService.getAll();\n            for (const recordName in dirtyRecords) {\n                const recordCore = this.recordCores.get(recordName);\n                if (recordCore && recordCore.usages > 0) {\n                    // if it isn't zero.. problem.\n                    continue;\n                }\n                this.services.storage.get(recordName, this.sendUpdatedData);\n            }\n        });\n    }\n    sendUpdatedData(recordName, version, data) {\n        this.sendSetData(recordName, version, { data, callback: this.onRecordUpdated });\n    }\n    onRecordUpdated(error, recordName) {\n        if (!error) {\n            this.dirtyService.setDirty(recordName, false);\n        }\n    }\n    /**\n    * Callback once the record merge has completed. If successful it will set the\n    * record state, else emit and error and the record will remain in an\n    * inconsistent state until the next update.\n    */\n    // private onMergeConflict (message: RecordWriteMessage): void {\n    //   this.services.storage.get(message.name, (recordName: string, version: number, data: any) => {\n    //     this.recordServices.mergeStrategy.merge(\n    //       message.name,\n    //       version,\n    //       data,\n    //       message.version,\n    //       message.parsedData,\n    //       this.onMergeCompleted\n    //     )\n    //   })\n    // }\n    onMergeCompleted(error, recordName, mergeData, remoteVersion, remoteData) {\n        this.sendSetData(recordName, remoteVersion + 1, { data: mergeData });\n    }\n}\nexports.RecordHandler = RecordHandler;\n\n\n//# sourceURL=webpack://deepstream/./src/record/record-handler.ts?");

/***/ }),

/***/ "./src/record/record.ts":
/*!******************************!*\
  !*** ./src/record/record.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils = __webpack_require__(/*! ../util/utils */ \"./src/util/utils.ts\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nconst Emitter = __webpack_require__(/*! component-emitter2 */ \"./node_modules/component-emitter2/index.js\");\nclass Record extends Emitter {\n    constructor(record) {\n        super();\n        this.record = record;\n        this.subscriptions = [];\n        this.record.on(constants_1.EVENT.RECORD_READY, this.emit.bind(this, constants_1.EVENT.RECORD_READY, this));\n        this.record.on(constants_1.EVENT.RECORD_DISCARDED, this.emit.bind(this, constants_1.EVENT.RECORD_DISCARDED));\n        this.record.on(constants_1.EVENT.RECORD_DELETED, this.emit.bind(this, constants_1.EVENT.RECORD_DELETED));\n        this.record.on(constants_1.EVENT.RECORD_ERROR, this.emit.bind(this, constants_1.EVENT.RECORD_ERROR));\n    }\n    get name() {\n        return this.record.name;\n    }\n    get isReady() {\n        return this.record.isReady;\n    }\n    get version() {\n        return this.record.version;\n    }\n    get hasProvider() {\n        return this.record.hasProvider;\n    }\n    whenReady(callback) {\n        return this.record.whenReady(this, callback);\n    }\n    get(path) {\n        return this.record.get(path);\n    }\n    set(path, data, callback) {\n        return this.record.set(utils.normalizeSetArguments(arguments));\n    }\n    setWithAck(path, data, callback) {\n        return this.record.setWithAck(utils.normalizeSetArguments(arguments));\n    }\n    /**\n     * Deletes a path from the record. Equivalent to doing `record.set(path, undefined)`\n     *\n     * @param {String} path The path to be deleted\n     */\n    erase(path) {\n        if (!path) {\n            throw new Error('unable to erase record data without path, consider using `delete`');\n        }\n        this.set(path, undefined);\n    }\n    eraseWithAck(path, callback) {\n        if (!path) {\n            throw new Error('unable to erase record data without path, consider using `delete`');\n        }\n        if (callback) {\n            this.setWithAck(path, undefined, callback);\n        }\n        else {\n            return this.setWithAck(path, undefined);\n        }\n    }\n    subscribe(path, callback, triggerNow) {\n        const parameters = utils.normalizeArguments(arguments);\n        this.subscriptions.push(parameters);\n        this.record.subscribe(parameters);\n    }\n    unsubscribe(path, callback) {\n        const parameters = utils.normalizeArguments(arguments);\n        this.subscriptions = this.subscriptions.filter(subscription => {\n            return (subscription.path !== parameters.path ||\n                subscription.callback !== parameters.callback);\n        });\n        this.record.unsubscribe(parameters);\n    }\n    discard() {\n        for (let i = 0; i < this.subscriptions.length; i++) {\n            this.record.unsubscribe(this.subscriptions[i]);\n        }\n        return this.record.discard();\n    }\n    delete(callback) {\n        return this.record.delete(callback);\n    }\n    setMergeStrategy(mergeStrategy) {\n        this.record.setMergeStrategy(mergeStrategy);\n    }\n}\nexports.Record = Record;\n\n\n//# sourceURL=webpack://deepstream/./src/record/record.ts?");

/***/ }),

/***/ "./src/record/single-notifier.ts":
/*!***************************************!*\
  !*** ./src/record/single-notifier.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\n/**\n * Provides a scaffold for subscriptionless requests to deepstream, such as the SNAPSHOT\n * and HAS functionality. The SingleNotifier multiplexes all the client requests so\n * that they can can be notified at once, and also includes reconnection funcionality\n * incase the connection drops.\n *\n * @param {Services} services          The deepstream client\n * @param {Options} options     Function to call to allow resubscribing\n *\n * @constructor\n */\nclass SingleNotifier {\n    constructor(services, action, timeoutDuration) {\n        this.services = services;\n        this.action = action;\n        this.requests = new Map();\n        this.internalRequests = new Map();\n        this.limboQueue = [];\n        this.services.connection.onLost(this.onConnectionLost.bind(this));\n        this.services.connection.onExitLimbo(this.onExitLimbo.bind(this));\n        this.services.connection.onReestablished(this.onConnectionReestablished.bind(this));\n    }\n    /**\n   * Add a request. If one has already been made it will skip the server request\n   * and multiplex the response\n   *\n   * @param {String} name An identifier for the request, e.g. a record name\n   * @param {Object} response An object with property `callback` or `resolve` and `reject`\n   *\n   * @public\n   * @returns {void}\n   */\n    request(name, callback) {\n        const message = {\n            topic: message_constants_1.TOPIC.RECORD,\n            action: this.action,\n            name\n        };\n        const req = this.requests.get(name);\n        if (req) {\n            req.push(callback);\n            return;\n        }\n        this.requests.set(name, [callback]);\n        if (this.services.connection.isConnected) {\n            this.services.connection.sendMessage(message);\n            this.services.timeoutRegistry.add({ message });\n        }\n        else if (this.services.connection.isInLimbo) {\n            this.limboQueue.push(message);\n        }\n        else {\n            callback(constants_1.EVENT.CLIENT_OFFLINE);\n        }\n    }\n    /**\n     * Adds a callback to a (possibly) inflight request that will be called\n     * on the response.\n     */\n    register(name, callback) {\n        const request = this.internalRequests.get(name);\n        if (!request) {\n            this.internalRequests.set(name, [callback]);\n        }\n        else {\n            request.push(callback);\n        }\n    }\n    recieve(message, error, data) {\n        this.services.timeoutRegistry.remove(message);\n        const name = message.name;\n        const responses = this.requests.get(name) || [];\n        const internalResponses = this.internalRequests.get(name) || [];\n        if (!responses && !internalResponses) {\n            return;\n        }\n        for (let i = 0; i < internalResponses.length; i++) {\n            internalResponses[i](message);\n        }\n        this.internalRequests.delete(name);\n        // todo we can clean this up and do cb = (error, data) => error ? reject(error) : resolve()\n        for (let i = 0; i < responses.length; i++) {\n            responses[i](error, data);\n        }\n        this.requests.delete(name);\n        return;\n    }\n    onConnectionLost() {\n        this.requests.forEach(responses => {\n            responses.forEach(response => response(constants_1.EVENT.CLIENT_OFFLINE));\n        });\n        this.requests.clear();\n    }\n    onExitLimbo() {\n        for (let i = 0; i < this.limboQueue.length; i++) {\n            const message = this.limboQueue[i];\n            const requests = this.requests.get(message.name);\n            if (requests) {\n                requests.forEach(cb => cb(constants_1.EVENT.CLIENT_OFFLINE));\n            }\n        }\n        this.requests.clear();\n        this.limboQueue = [];\n    }\n    onConnectionReestablished() {\n        for (let i = 0; i < this.limboQueue.length; i++) {\n            const message = this.limboQueue[i];\n            this.services.connection.sendMessage(message);\n            this.services.timeoutRegistry.add({ message });\n        }\n    }\n}\nexports.SingleNotifier = SingleNotifier;\n\n\n//# sourceURL=webpack://deepstream/./src/record/single-notifier.ts?");

/***/ }),

/***/ "./src/record/storage-service.ts":
/*!***************************************!*\
  !*** ./src/record/storage-service.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Storage {\n    constructor(options) {\n        // @ts-ignore\n        if (typeof localStorage === 'undefined' || localStorage === null) {\n            const LocalStorage = __webpack_require__(/*! node-localstorage */ \"./node_modules/node-localstorage/LocalStorage.js\").LocalStorage;\n            this.storage = new LocalStorage(options.nodeStoragePath, options.nodeStorageSize * 1024 * 1024);\n        }\n        else {\n            // @ts-ignore\n            this.storage = window.localStorage;\n        }\n    }\n    get(recordName, callback) {\n        const item = this.storage.getItem(recordName);\n        if (item) {\n            const doc = JSON.parse(item);\n            setTimeout(callback.bind(this, recordName, doc.version, doc.data), 0);\n            return;\n        }\n        setTimeout(callback.bind(this, recordName, -1, null), 0);\n    }\n    set(recordName, version, data, callback) {\n        this.storage.setItem(recordName, JSON.stringify({ recordName, version, data }));\n        setTimeout(callback, 0);\n    }\n    delete(recordName, callback) {\n        this.storage.removeItem(recordName);\n        setTimeout(callback, 0);\n    }\n}\nexports.Storage = Storage;\n\n\n//# sourceURL=webpack://deepstream/./src/record/storage-service.ts?");

/***/ }),

/***/ "./src/record/write-ack-service.ts":
/*!*****************************************!*\
  !*** ./src/record/write-ack-service.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nconst utils_1 = __webpack_require__(/*! ../../binary-protocol/src/utils */ \"./binary-protocol/src/utils.ts\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nclass WriteAcknowledgementService {\n    constructor(services) {\n        this.services = services;\n        this.responses = new Map();\n        this.count = 1;\n        this.services.connection.onLost(this.onConnectionLost.bind(this));\n    }\n    /**\n     * Send message with write ack callback.\n     */\n    send(message, callback) {\n        if (this.services.connection.isConnected === false) {\n            this.services.timerRegistry.requestIdleCallback(callback.bind(this, constants_1.EVENT.CLIENT_OFFLINE));\n            return;\n        }\n        const correlationId = this.count.toString();\n        this.responses.set(correlationId, callback);\n        this.services.connection.sendMessage(Object.assign({}, message, { correlationId, action: utils_1.ACTION_TO_WRITE_ACK[message.action] }));\n        this.count++;\n    }\n    recieve(message) {\n        const id = message.correlationId;\n        const response = this.responses.get(id);\n        if (!response ||\n            (message.action !== message_constants_1.RECORD_ACTIONS.WRITE_ACKNOWLEDGEMENT && !message.isError)) {\n            return;\n        }\n        message.isError\n            ? response(message_constants_1.RECORD_ACTIONS[message.action])\n            : response(null);\n        this.responses.delete(id);\n    }\n    onConnectionLost() {\n        this.responses.forEach(response => response(constants_1.EVENT.CLIENT_OFFLINE));\n        this.responses.clear();\n    }\n}\nexports.WriteAcknowledgementService = WriteAcknowledgementService;\n\n\n//# sourceURL=webpack://deepstream/./src/record/write-ack-service.ts?");

/***/ }),

/***/ "./src/rpc/rpc-handler.ts":
/*!********************************!*\
  !*** ./src/rpc/rpc-handler.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nconst rpc_1 = __webpack_require__(/*! ../rpc/rpc */ \"./src/rpc/rpc.ts\");\nconst rpc_response_1 = __webpack_require__(/*! ../rpc/rpc-response */ \"./src/rpc/rpc-response.ts\");\nconst utils_1 = __webpack_require__(/*! ../util/utils */ \"./src/util/utils.ts\");\nclass RPCHandler {\n    constructor(services, options) {\n        this.services = services;\n        this.options = options;\n        this.rpcs = new Map();\n        this.providers = new Map();\n        this.limboQueue = [];\n        this.services.connection.registerHandler(message_constants_1.TOPIC.RPC, this.handle.bind(this));\n        this.services.connection.onReestablished(this.onConnectionReestablished.bind(this));\n        this.services.connection.onExitLimbo(this.onExitLimbo.bind(this));\n        this.services.connection.onLost(this.onConnectionLost.bind(this));\n    }\n    /**\n     * Registers a callback function as a RPC provider. If another connected client calls\n     * client.rpc.make() the request will be routed to this method\n     *\n     * The callback will be invoked with two arguments:\n     *     {Mixed} data The data passed to the client.rpc.make function\n     *     {RpcResponse} rpcResponse An object with methods to response,\n     *                               acknowledge or reject the request\n     *\n     * Only one callback can be registered for a RPC at a time\n     *\n     * Please note: Deepstream tries to deliver data in its original format.\n     * Data passed to client.rpc.make as a String will arrive as a String,\n     * numbers or implicitly JSON serialized objects will arrive in their\n     * respective format as well\n     */\n    provide(name, callback) {\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument name');\n        }\n        if (this.providers.has(name)) {\n            throw new Error(`RPC ${name} already registered`);\n        }\n        if (typeof callback !== 'function') {\n            throw new Error('invalid argument callback');\n        }\n        this.providers.set(name, callback);\n        if (this.services.connection.isConnected) {\n            this.sendProvide(name);\n        }\n    }\n    /**\n     * Unregisters this client as a provider for a remote procedure call\n     */\n    unprovide(name) {\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument name');\n        }\n        if (!this.providers.has(name)) {\n            this.services.logger.warn({\n                topic: message_constants_1.TOPIC.RPC,\n                action: message_constants_1.RPC_ACTIONS.NOT_PROVIDED,\n                name\n            });\n            return;\n        }\n        this.providers.delete(name);\n        if (this.services.connection.isConnected) {\n            const message = { topic: message_constants_1.TOPIC.RPC, action: message_constants_1.RPC_ACTIONS.UNPROVIDE, name };\n            this.services.timeoutRegistry.add({ message });\n            this.services.connection.sendMessage(message);\n            return;\n        }\n    }\n    make(name, data, callback) {\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument name');\n        }\n        if (callback && typeof callback !== 'function') {\n            throw new Error('invalid argument callback');\n        }\n        const correlationId = utils_1.getUid();\n        if (this.services.connection.isConnected) {\n            if (callback) {\n                this.rpcs.set(correlationId, new rpc_1.RPC(name, correlationId, data, callback, this.options, this.services));\n                return;\n            }\n            return new Promise((resolve, reject) => {\n                this.rpcs.set(correlationId, new rpc_1.RPC(name, correlationId, data, (error, result) => error ? reject(error) : resolve(result), this.options, this.services));\n            });\n        }\n        else if (this.services.connection.isInLimbo) {\n            if (callback) {\n                this.limboQueue.push({ correlationId, name, data, callback });\n            }\n            else {\n                return new Promise((resolve, reject) => {\n                    this.limboQueue.push({ correlationId, name, data, callback: (error, result) => error ? reject(error) : resolve(result) });\n                });\n            }\n        }\n        else {\n            if (callback) {\n                callback(constants_1.EVENT.CLIENT_OFFLINE);\n            }\n            else {\n                return Promise.reject(constants_1.EVENT.CLIENT_OFFLINE);\n            }\n        }\n    }\n    /**\n     * Handles incoming rpc REQUEST messages. Instantiates a new response object\n     * and invokes the provider callback or rejects the request if no rpc provider\n     * is present (which shouldn't really happen, but might be the result of a race condition\n     * if this client sends a unprovide message whilst an incoming request is already in flight)\n     */\n    respondToRpc(message) {\n        const provider = this.providers.get(message.name);\n        if (provider) {\n            provider(message.parsedData, new rpc_response_1.RPCResponse(message, this.options, this.services));\n        }\n        else {\n            this.services.connection.sendMessage({\n                topic: message_constants_1.TOPIC.RPC,\n                action: message_constants_1.RPC_ACTIONS.REJECT,\n                name: message.name,\n                correlationId: message.correlationId\n            });\n        }\n    }\n    /**\n     * Distributes incoming messages from the server\n     * based on their action\n     */\n    handle(message) {\n        // RPC Requests\n        if (message.action === message_constants_1.RPC_ACTIONS.REQUEST) {\n            this.respondToRpc(message);\n            return;\n        }\n        // RPC subscription Acks\n        if (message.isAck) {\n            this.services.timeoutRegistry.remove(message);\n            return;\n        }\n        // handle auth/denied subscription errors\n        if (message.action === message_constants_1.RPC_ACTIONS.MESSAGE_PERMISSION_ERROR || message.action === message_constants_1.RPC_ACTIONS.MESSAGE_DENIED) {\n            if (message.originalAction === message_constants_1.RPC_ACTIONS.PROVIDE || message.originalAction === message_constants_1.RPC_ACTIONS.UNPROVIDE) {\n                this.services.timeoutRegistry.remove(message);\n                this.providers.delete(message.name);\n                this.services.logger.error(message);\n                return;\n            }\n            if (message.originalAction === message_constants_1.RPC_ACTIONS.REQUEST) {\n                const invalidRPC = this.getRPC(message);\n                if (invalidRPC) {\n                    invalidRPC.error(message_constants_1.RPC_ACTIONS[message.action]);\n                    this.rpcs.delete(message.correlationId);\n                    return;\n                }\n            }\n        }\n        // RPC Responses\n        const rpc = this.getRPC(message);\n        if (rpc) {\n            if (message.action === message_constants_1.RPC_ACTIONS.ACCEPT) {\n                rpc.accept();\n                return;\n            }\n            if (message.action === message_constants_1.RPC_ACTIONS.RESPONSE) {\n                rpc.respond(message.parsedData);\n            }\n            else if (message.action === message_constants_1.RPC_ACTIONS.REQUEST_ERROR) {\n                rpc.error(message.parsedData);\n            }\n            else if (message.action === message_constants_1.RPC_ACTIONS.RESPONSE_TIMEOUT ||\n                message.action === message_constants_1.RPC_ACTIONS.NO_RPC_PROVIDER) {\n                rpc.error(message_constants_1.RPC_ACTIONS[message.action]);\n            }\n            this.rpcs.delete(message.correlationId);\n        }\n    }\n    getRPC(message) {\n        const rpc = this.rpcs.get(message.correlationId);\n        if (rpc === undefined) {\n            this.services.logger.error(message, constants_1.EVENT.UNKNOWN_CORRELATION_ID);\n        }\n        return rpc;\n    }\n    sendProvide(name) {\n        const message = {\n            topic: message_constants_1.TOPIC.RPC,\n            action: message_constants_1.RPC_ACTIONS.PROVIDE,\n            name\n        };\n        this.services.timeoutRegistry.add({ message });\n        this.services.connection.sendMessage(message);\n    }\n    onConnectionReestablished() {\n        for (const [name] of this.providers) {\n            this.sendProvide(name);\n        }\n        for (let i = 0; i < this.limboQueue.length; i++) {\n            const { correlationId, name, data, callback } = this.limboQueue[i];\n            this.rpcs.set(correlationId, new rpc_1.RPC(name, correlationId, data, callback, this.options, this.services));\n        }\n        this.limboQueue = [];\n    }\n    onExitLimbo() {\n        for (let i = 0; i < this.limboQueue.length; i++) {\n            this.limboQueue[i].callback(constants_1.EVENT.CLIENT_OFFLINE);\n        }\n        this.limboQueue = [];\n    }\n    onConnectionLost() {\n        this.rpcs.forEach(rpc => {\n            rpc.error(constants_1.EVENT.CLIENT_OFFLINE);\n        });\n        this.rpcs.clear();\n    }\n}\nexports.RPCHandler = RPCHandler;\n\n\n//# sourceURL=webpack://deepstream/./src/rpc/rpc-handler.ts?");

/***/ }),

/***/ "./src/rpc/rpc-response.ts":
/*!*********************************!*\
  !*** ./src/rpc/rpc-response.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\n/**\n * This class represents a single remote procedure\n * call made from the client to the server. It's main function\n * is to encapsulate the logic around timeouts and to convert the\n * incoming response data\n */\nclass RPCResponse {\n    constructor(message, options, services) {\n        this.name = message.name;\n        this.correlationId = message.correlationId;\n        this.services = services;\n        this.isAccepted = false;\n        this.isComplete = false;\n        this.autoAccept = true;\n        this.services.timerRegistry.requestIdleCallback(this.performAutoAck.bind(this));\n    }\n    /**\n     * Acknowledges the receipt of the request. This\n     * will happen implicitly unless the request callback\n     * explicitly sets autoAck to false\n     */\n    accept() {\n        if (this.isAccepted === false) {\n            this.services.connection.sendMessage({\n                topic: message_constants_1.TOPIC.RPC,\n                action: message_constants_1.RPC_ACTIONS.ACCEPT,\n                name: this.name,\n                correlationId: this.correlationId\n            });\n            this.isAccepted = true;\n        }\n    }\n    /**\n     * Reject the request. This might be necessary if the client\n     * is already processing a large number of requests. If deepstream\n     * receives a rejection message it will try to route the request to\n     * another provider - or return a NO_RPC_PROVIDER error if there are no\n     * providers left\n     */\n    reject() {\n        if (this.isComplete === true) {\n            throw new Error(`Rpc ${this.name} already completed`);\n        }\n        this.autoAccept = false;\n        this.isComplete = true;\n        this.isAccepted = true;\n        this.services.connection.sendMessage({\n            topic: message_constants_1.TOPIC.RPC,\n            action: message_constants_1.RPC_ACTIONS.REJECT,\n            name: this.name,\n            correlationId: this.correlationId\n        });\n    }\n    /**\n     * Notifies the server that an error has occured while trying to process the request.\n     * This will complete the rpc.\n     */\n    error(error) {\n        if (this.isComplete === true) {\n            throw new Error(`Rpc ${this.name} already completed`);\n        }\n        this.autoAccept = false;\n        this.isComplete = true;\n        this.isAccepted = true;\n        this.services.connection.sendMessage({\n            topic: message_constants_1.TOPIC.RPC,\n            action: message_constants_1.RPC_ACTIONS.REQUEST_ERROR,\n            name: this.name,\n            correlationId: this.correlationId,\n            parsedData: error\n        });\n    }\n    /**\n     * Completes the request by sending the response data\n     * to the server. If data is an array or object it will\n     * automatically be serialised.\n     * If autoAck is disabled and the response is sent before\n     * the ack message the request will still be completed and the\n     * ack message ignored\n     */\n    send(data) {\n        if (this.isComplete === true) {\n            throw new Error(`Rpc ${this.name} already completed`);\n        }\n        this.accept();\n        this.services.connection.sendMessage({\n            topic: message_constants_1.TOPIC.RPC,\n            action: message_constants_1.RPC_ACTIONS.RESPONSE,\n            name: this.name,\n            correlationId: this.correlationId,\n            parsedData: data\n        });\n        this.isComplete = true;\n    }\n    /**\n     * Callback for the autoAck timeout. Executes ack\n     * if autoAck is not disabled\n     */\n    performAutoAck() {\n        if (this.autoAccept === true) {\n            this.accept();\n        }\n    }\n}\nexports.RPCResponse = RPCResponse;\n\n\n//# sourceURL=webpack://deepstream/./src/rpc/rpc-response.ts?");

/***/ }),

/***/ "./src/rpc/rpc.ts":
/*!************************!*\
  !*** ./src/rpc/rpc.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\n/**\n * This class represents a single remote procedure\n * call made from the client to the server. It's main function\n * is to encapsulate the logic around timeouts and to convert the\n * incoming response data\n */\nclass RPC {\n    constructor(name, correlationId, data, response, options, services) {\n        this.options = options;\n        this.services = services;\n        this.name = name;\n        this.correlationId = correlationId;\n        this.response = response;\n        this.onTimeout = this.onTimeout.bind(this);\n        const message = {\n            topic: message_constants_1.TOPIC.RPC,\n            action: message_constants_1.RPC_ACTIONS.REQUEST,\n            correlationId,\n            name,\n            parsedData: data\n        };\n        this.acceptTimeout = this.services.timeoutRegistry.add({\n            message: {\n                topic: message_constants_1.TOPIC.RPC,\n                action: message_constants_1.RPC_ACTIONS.ACCEPT,\n                name: this.name,\n                correlationId: this.correlationId\n            },\n            event: message_constants_1.RPC_ACTIONS.ACCEPT_TIMEOUT,\n            duration: this.options.rpcAcceptTimeout,\n            callback: this.onTimeout.bind(this)\n        });\n        this.responseTimeout = this.services.timeoutRegistry.add({\n            message: {\n                topic: message_constants_1.TOPIC.RPC,\n                action: message_constants_1.RPC_ACTIONS.REQUEST,\n                name: this.name,\n                correlationId: this.correlationId\n            },\n            event: message_constants_1.RPC_ACTIONS.RESPONSE_TIMEOUT,\n            duration: this.options.rpcResponseTimeout,\n            callback: this.onTimeout\n        });\n        this.services.connection.sendMessage(message);\n    }\n    /**\n     * Called once an ack message is received from the server\n     */\n    accept() {\n        this.services.timeoutRegistry.clear(this.acceptTimeout);\n    }\n    /**\n     * Called once a response message is received from the server.\n     */\n    respond(data) {\n        this.response(null, data);\n        this.complete();\n    }\n    /**\n     * Called once an error is received from the server.\n     */\n    error(data) {\n        this.response(data);\n        this.complete();\n    }\n    /**\n     * Callback for error messages received from the server. Once\n     * an error is received the request is considered completed. Even\n     * if a response arrives later on it will be ignored / cause an\n     * UNSOLICITED_MESSAGE error\n     */\n    onTimeout(event, message) {\n        this.response(message_constants_1.RPC_ACTIONS[event]);\n        this.complete();\n    }\n    /**\n     * Called after either an error or a response\n     * was received\n    */\n    complete() {\n        this.services.timeoutRegistry.clear(this.acceptTimeout);\n        this.services.timeoutRegistry.clear(this.responseTimeout);\n    }\n}\nexports.RPC = RPC;\n\n\n//# sourceURL=webpack://deepstream/./src/rpc/rpc.ts?");

/***/ }),

/***/ "./src/util/listener.ts":
/*!******************************!*\
  !*** ./src/util/listener.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nconst constants_1 = __webpack_require__(/*! ../../src/constants */ \"./src/constants.ts\");\nclass Listener {\n    constructor(topic, services) {\n        this.topic = topic;\n        this.services = services;\n        this.listeners = new Map();\n        this.stopCallbacks = new Map();\n        if (topic === message_constants_1.TOPIC.RECORD) {\n            this.actions = message_constants_1.RECORD_ACTIONS;\n        }\n        else if (topic === message_constants_1.TOPIC.EVENT) {\n            this.actions = message_constants_1.EVENT_ACTIONS;\n        }\n        this.services.connection.onLost(this.onConnectionLost.bind(this));\n        this.services.connection.onReestablished(this.onConnectionReestablished.bind(this));\n    }\n    listen(pattern, callback) {\n        if (typeof pattern !== 'string' || pattern.length === 0) {\n            throw new Error('invalid argument pattern');\n        }\n        if (typeof callback !== 'function') {\n            throw new Error('invalid argument callback');\n        }\n        if (this.listeners.has(pattern)) {\n            this.services.logger.warn({\n                topic: this.topic,\n                action: constants_1.EVENT.LISTENER_EXISTS,\n                name: pattern\n            });\n            return;\n        }\n        this.listeners.set(pattern, callback);\n        this.sendListen(pattern);\n    }\n    unlisten(pattern) {\n        if (typeof pattern !== 'string' || pattern.length === 0) {\n            throw new Error('invalid argument pattern');\n        }\n        if (!this.listeners.has(pattern)) {\n            this.services.logger.warn({\n                topic: this.topic,\n                action: constants_1.EVENT.NOT_LISTENING,\n                name: pattern\n            });\n            return;\n        }\n        this.listeners.delete(pattern);\n        this.sendUnlisten(pattern);\n    }\n    /*\n   * Accepting a listener request informs deepstream that the current provider is willing to\n   * provide the record or event matching the subscriptionName . This will establish the current\n   * provider as the only publisher for the actual subscription with the deepstream cluster.\n   * Either accept or reject needs to be called by the listener\n   */\n    accept(pattern, subscription) {\n        this.services.connection.sendMessage({\n            topic: this.topic,\n            action: this.actions.LISTEN_ACCEPT,\n            name: pattern,\n            subscription\n        });\n    }\n    /*\n    * Rejecting a listener request informs deepstream that the current provider is not willing\n    * to provide the record or event matching the subscriptionName . This will result in deepstream\n    * requesting another provider to do so instead. If no other provider accepts or exists, the\n    * resource will remain unprovided.\n    * Either accept or reject needs to be called by the listener\n    */\n    reject(pattern, subscription) {\n        this.services.connection.sendMessage({\n            topic: this.topic,\n            action: this.actions.LISTEN_REJECT,\n            name: pattern,\n            subscription\n        });\n    }\n    stop(subscription, callback) {\n        this.stopCallbacks.set(subscription, callback);\n    }\n    handle(message) {\n        if (message.isAck) {\n            this.services.timeoutRegistry.remove(message);\n            return;\n        }\n        if (message.action === this.actions.SUBSCRIPTION_FOR_PATTERN_FOUND) {\n            const listener = this.listeners.get(message.name);\n            if (listener) {\n                listener(message.subscription, {\n                    accept: this.accept.bind(this, message.name, message.subscription),\n                    reject: this.reject.bind(this, message.name, message.subscription),\n                    onStop: this.stop.bind(this, message.subscription)\n                });\n            }\n            return;\n        }\n        if (message.action === this.actions.SUBSCRIPTION_FOR_PATTERN_REMOVED) {\n            const stopCallback = this.stopCallbacks.get(message.subscription);\n            if (stopCallback) {\n                stopCallback(message.subscription);\n                this.stopCallbacks.delete(message.subscription);\n            }\n            return;\n        }\n        this.services.logger.error(message, constants_1.EVENT.UNSOLICITED_MESSAGE);\n    }\n    onConnectionLost() {\n        this.stopCallbacks.forEach((callback, subscription) => {\n            callback(subscription);\n        });\n        this.stopCallbacks.clear();\n    }\n    onConnectionReestablished() {\n        this.listeners.forEach((callback, pattern) => {\n            this.sendListen(pattern);\n        });\n    }\n    /*\n    * Sends a C.ACTIONS.LISTEN to deepstream.\n    */\n    sendListen(pattern) {\n        const message = {\n            topic: this.topic,\n            action: this.actions.LISTEN,\n            name: pattern\n        };\n        this.services.timeoutRegistry.add({ message });\n        this.services.connection.sendMessage(message);\n    }\n    sendUnlisten(pattern) {\n        const message = {\n            topic: this.topic,\n            action: this.actions.UNLISTEN,\n            name: pattern\n        };\n        this.services.timeoutRegistry.add({ message });\n        this.services.connection.sendMessage(message);\n    }\n}\nexports.Listener = Listener;\n\n\n//# sourceURL=webpack://deepstream/./src/util/listener.ts?");

/***/ }),

/***/ "./src/util/logger.ts":
/*!****************************!*\
  !*** ./src/util/logger.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nfunction isEvent(action) {\n    return constants_1.EVENT[action] !== undefined;\n}\nclass Logger {\n    constructor(emitter) {\n        this.emitter = emitter;\n    }\n    warn(message, event, meta) {\n        // tslint:disable-next-line:no-console\n        let warnMessage = `Warning: ${message_constants_1.TOPIC[message.topic]}`;\n        const action = message.action;\n        if (action) {\n            warnMessage += ` (${message_constants_1.ACTIONS[message.topic][action]})`;\n        }\n        if (event) {\n            warnMessage += `: ${constants_1.EVENT[event]}`;\n        }\n        if (meta) {\n            warnMessage += `  ${typeof meta === 'string' ? meta : JSON.stringify(meta)}`;\n        }\n        console.warn(warnMessage);\n    }\n    error(message, event, meta) {\n        // tslint:disable-next-line:no-console\n        if (isEvent(event)) {\n            if (event === constants_1.EVENT.IS_CLOSED) {\n                this.emitter.emit('error', meta, constants_1.EVENT[event], message_constants_1.TOPIC[message_constants_1.TOPIC.CONNECTION]);\n            }\n            else if (event === constants_1.EVENT.CONNECTION_ERROR) {\n                this.emitter.emit('error', meta, constants_1.EVENT[event], message_constants_1.TOPIC[message_constants_1.TOPIC.CONNECTION]);\n            }\n        }\n        else {\n            const action = event ? event : message.action;\n            this.emitter.emit('error', meta, message_constants_1.ACTIONS[message.topic][action], message_constants_1.TOPIC[message.topic]);\n        }\n    }\n}\nexports.Logger = Logger;\n\n\n//# sourceURL=webpack://deepstream/./src/util/logger.ts?");

/***/ }),

/***/ "./src/util/state-machine.ts":
/*!***********************************!*\
  !*** ./src/util/state-machine.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass StateMachine {\n    constructor(logger, stateMachine) {\n        this.inEndState = false;\n        this.transitions = stateMachine.transitions;\n        this.state = stateMachine.init;\n        this.stateMachine = stateMachine;\n    }\n    /**\n     * Try to perform a state change\n     */\n    transition(transitionName) {\n        let transition;\n        for (let i = 0; i < this.transitions.length; i++) {\n            transition = this.transitions[i];\n            if (transitionName === transition.name && (this.state === transition.from || transition.from === undefined)) {\n                const oldState = this.state;\n                this.state = transition.to;\n                if (this.stateMachine.onStateChanged) {\n                    this.stateMachine.onStateChanged(this.state, oldState);\n                }\n                if (transition.handler) {\n                    transition.handler();\n                }\n                return;\n            }\n        }\n        const details = JSON.stringify({ transition: transitionName, state: this.state });\n        throw new Error(`Invalid state transition: ${details}`);\n    }\n}\nexports.StateMachine = StateMachine;\n\n\n//# sourceURL=webpack://deepstream/./src/util/state-machine.ts?");

/***/ }),

/***/ "./src/util/timeout-registry.ts":
/*!**************************************!*\
  !*** ./src/util/timeout-registry.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nconst utils_1 = __webpack_require__(/*! ../../binary-protocol/src/utils */ \"./binary-protocol/src/utils.ts\");\nconst EventEmitter = __webpack_require__(/*! component-emitter2 */ \"./node_modules/component-emitter2/index.js\");\n/**\n * Subscriptions to events are in a pending state until deepstream acknowledges\n * them. This is a pattern that's used by numerour classes. This registry aims\n * to centralise the functionality necessary to keep track of subscriptions and\n * their respective timeouts.\n */\nclass TimeoutRegistry extends EventEmitter {\n    constructor(services, options) {\n        super();\n        this.options = options;\n        this.services = services;\n        this.register = new Map();\n    }\n    /**\n     * Add an entry\n     */\n    add(timeout) {\n        if (timeout.duration === undefined) {\n            timeout.duration = this.options.subscriptionTimeout;\n        }\n        if (timeout.event === undefined) {\n            timeout.event = constants_1.EVENT.ACK_TIMEOUT;\n        }\n        /*\n        if (timeout.duration < 1) {\n          should we throw an error?\n          return -1\n        }\n        */\n        if (!this.services.connection.isConnected) {\n            return -1;\n        }\n        this.remove(timeout.message);\n        const internalTimeout = Object.assign({}, {\n            timerId: -1,\n            uniqueName: this.getUniqueName(timeout.message),\n            event: timeout.event\n        }, { timeout });\n        internalTimeout.timerId = this.services.timerRegistry.add({\n            context: this,\n            callback: this.onTimeout,\n            duration: timeout.duration,\n            data: internalTimeout\n        });\n        this.register.set(internalTimeout.timerId, internalTimeout);\n        return internalTimeout.timerId;\n    }\n    /**\n     * Remove an entry\n     */\n    remove(message) {\n        let requestMsg;\n        const action = utils_1.RESPONSE_TO_REQUEST[message.topic][message.action];\n        if (!action) {\n            requestMsg = message;\n        }\n        else {\n            requestMsg = Object.assign({}, message, { action });\n        }\n        const uniqueName = this.getUniqueName(requestMsg);\n        for (const [timerId, timeout] of this.register) {\n            if (timeout.uniqueName === uniqueName) {\n                this.services.timerRegistry.remove(timerId);\n                this.register.delete(timerId);\n            }\n        }\n    }\n    /**\n     * Processes an incoming ACK-message and removes the corresponding subscription\n     */\n    clear(timerId) {\n        this.services.timerRegistry.remove(timerId);\n        this.register.delete(timerId);\n    }\n    /**\n     * Will be invoked if the timeout has occured before the ack message was received\n     */\n    onTimeout(internalTimeout) {\n        this.register.delete(internalTimeout.timerId);\n        const timeout = internalTimeout.timeout;\n        if (timeout.callback) {\n            timeout.callback(timeout.event, timeout.message);\n        }\n        else {\n            this.services.logger.warn(timeout.message, timeout.event);\n        }\n    }\n    /**\n     * Returns a unique name from the timeout\n     */\n    getUniqueName(message) {\n        const action = message.originalAction || message.action;\n        let name = `${message.topic}${action}_`;\n        if (message.correlationId) {\n            name += message.correlationId;\n        }\n        else if (message.name) {\n            name += message.name;\n        }\n        return name;\n    }\n    /**\n     * Remote all timeouts when connection disconnects\n     */\n    onConnectionLost() {\n        for (const [timerId] of this.register) {\n            // @ts-ignore\n            clearTimeout(timerId);\n            this.register.delete(timerId);\n        }\n    }\n}\nexports.TimeoutRegistry = TimeoutRegistry;\n\n\n//# sourceURL=webpack://deepstream/./src/util/timeout-registry.ts?");

/***/ }),

/***/ "./src/util/timer-registry.ts":
/*!************************************!*\
  !*** ./src/util/timer-registry.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass TimerRegistry {\n    add(timeout) {\n        return setTimeout(timeout.callback.bind(timeout.context, timeout.data), timeout.duration);\n    }\n    remove(timerId) {\n        // @ts-ignore\n        clearTimeout(timerId);\n        return true;\n    }\n    requestIdleCallback(callback) {\n        process.nextTick(callback);\n    }\n}\nexports.TimerRegistry = TimerRegistry;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './../../node_modules/process/browser.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))))\n\n//# sourceURL=webpack://deepstream/./src/util/timer-registry.ts?");

/***/ }),

/***/ "./src/util/utils.ts":
/*!***************************!*\
  !*** ./src/util/utils.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst URL = __webpack_require__(/*! url */ \"./node_modules/url/url.js\");\n/**\n * A regular expression that matches whitespace on either side, but\n * not in the center of a string\n */\nconst TRIM_REGULAR_EXPRESSION = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n/**\n * Removes whitespace from the beginning and end of a string\n */\nexports.trim = function (inputString) {\n    if (inputString.trim) {\n        return inputString.trim();\n    }\n    return inputString.replace(TRIM_REGULAR_EXPRESSION, '');\n};\n/**\n * Compares two objects for deep (recoursive) equality\n *\n * This used to be a significantly more complex custom implementation,\n * but JSON.stringify has gotten so fast that it now outperforms the custom\n * way by a factor of 1.5 to 3.\n *\n * In IE11 / Edge the custom implementation is still slightly faster, but for\n * consistencies sake and the upsides of leaving edge-case handling to the native\n * browser / node implementation we'll go for JSON.stringify from here on.\n *\n * Please find performance test results here\n *\n * http://jsperf.com/deep-equals-code-vs-json\n */\nexports.deepEquals = (objA, objB) => {\n    if (objA === objB) {\n        return true;\n    }\n    else if (typeof objA !== 'object' || typeof objB !== 'object') {\n        return false;\n    }\n    return JSON.stringify(objA) === JSON.stringify(objB);\n};\n/**\n * Similar to deepEquals above, tests have shown that JSON stringify outperforms any attempt of\n * a code based implementation by 50% - 100% whilst also handling edge-cases and keeping\n * implementation complexity low.\n *\n * If ES6/7 ever decides to implement deep copying natively (what happened to Object.clone?\n * that was briefly a thing...), let's switch it for the native implementation. For now though,\n * even Object.assign({}, obj) only provides a shallow copy.\n *\n * Please find performance test results backing these statements here:\n *\n * http://jsperf.com/object-deep-copy-assign\n */\nexports.deepCopy = (obj) => {\n    if (typeof obj === 'object') {\n        return JSON.parse(JSON.stringify(obj));\n    }\n    return obj;\n};\n/**\n * Copy the top level of items, but do not copy its items recourisvely. This\n * is much quicker than deepCopy does not guarantee the object items are new/unique.\n * Mainly used to change the reference to the actual object itself, but not its children.\n */\nexports.shallowCopy = (obj) => {\n    if (Array.isArray(obj)) {\n        return obj.slice(0);\n    }\n    else if (typeof obj === 'object') {\n        const copy = Object.create(null);\n        const props = Object.keys(obj);\n        for (let i = 0; i < props.length; i++) {\n            copy[props[i]] = obj[props[i]];\n        }\n        return copy;\n    }\n    return obj;\n};\n/**\n * Used to see if a protocol is specified within the url\n * @type {RegExp}\n */\nconst hasUrlProtocol = /^wss:|^ws:|^\\/\\//;\n/**\n * Used to see if the protocol contains any unsupported protocols\n * @type {RegExp}\n */\nconst unsupportedProtocol = /^http:|^https:/;\n/**\n * Take the url passed when creating the client and ensure the correct\n * protocol is provided\n * @param  {String} url Url passed in by client\n * @return {String} Url with supported protocol\n */\nexports.parseUrl = (initialURl, defaultPath) => {\n    let url = initialURl;\n    if (unsupportedProtocol.test(url)) {\n        throw new Error('Only ws and wss are supported');\n    }\n    if (!hasUrlProtocol.test(url)) {\n        url = `ws://${url}`;\n    }\n    else if (url.indexOf('//') === 0) {\n        url = `ws:${url}`;\n    }\n    const serverUrl = URL.parse(url);\n    if (!serverUrl.host) {\n        throw new Error('invalid url, missing host');\n    }\n    serverUrl.protocol = serverUrl.protocol ? serverUrl.protocol : 'ws:';\n    serverUrl.pathname = serverUrl.pathname ? serverUrl.pathname : defaultPath;\n    return URL.format(serverUrl);\n};\n/**\n* Returns a random string. The first block of characters\n* is a timestamp, in order to allow databases to optimize for semi-\n* sequentuel numberings\n*/\nexports.getUid = () => {\n    const timestamp = (new Date()).getTime().toString(36);\n    const randomString = (Math.random() * 10000000000000000).toString(36).replace('.', '');\n    return `${timestamp}-${randomString}`;\n};\n/**\n * Creates a map based on the types of the provided arguments\n */\nexports.normalizeSetArguments = (args, startIndex = 0) => {\n    let result;\n    const isRootData = (data) => data !== undefined && typeof data === 'object';\n    const isNestedData = (data) => typeof data !== 'function';\n    const isPath = (path) => path !== undefined && typeof path === 'string';\n    const isCallback = (callback) => typeof callback === 'function';\n    if (args.length === startIndex + 1) {\n        result = {\n            path: undefined,\n            data: isRootData(args[startIndex]) ? args[startIndex] : undefined,\n            callback: undefined\n        };\n    }\n    if (args.length === startIndex + 2) {\n        result = { path: undefined, data: undefined, callback: undefined };\n        if (!isCallback(args[startIndex]) && isNestedData(args[startIndex])) {\n            result.path = isPath(args[startIndex]) ? args[startIndex] : undefined;\n        }\n        if (isPath(args[startIndex])) {\n            result.data = isNestedData(args[startIndex + 1]) ? args[startIndex + 1] : undefined;\n        }\n        else {\n            result.data = isRootData(args[startIndex]) ? args[startIndex] : undefined;\n        }\n        if (!isPath(args[startIndex])) {\n            result.callback = isCallback(args[startIndex + 1]) ? args[startIndex + 1] : false;\n        }\n    }\n    if (args.length === startIndex + 3) {\n        result = {\n            path: isPath(args[startIndex]) ? args[startIndex] : undefined,\n            data: isNestedData(args[startIndex + 1]) ? args[startIndex + 1] : undefined,\n            callback: isCallback(args[startIndex + 2]) ? args[startIndex + 2] : undefined\n        };\n    }\n    if (result) {\n        if (result.path !== undefined && result.path.length === 0 ||\n            (result.path === undefined && !result.data)) {\n            throw Error('Invalid set path argument');\n        }\n        if (result.data === undefined && result.path === undefined) {\n            throw Error('Invalid set data argument');\n        }\n        if (result.callback !== undefined && result.callback === false ||\n            result.callback === undefined && args.length === startIndex + 3) {\n            throw Error('Invalid set callback argument');\n        }\n        return result;\n    }\n    throw Error('Invalid set arguments');\n};\n/**\n * Creates a map based on the types of the provided arguments\n */\nexports.normalizeArguments = (args) => {\n    // If arguments is already a map of normalized parameters\n    // (e.g. when called by AnonymousRecord), just return it.\n    if (args.length === 1 && typeof args[0] === 'object') {\n        return args[0];\n    }\n    const result = Object.create(null);\n    for (let i = 0; i < args.length; i++) {\n        if (typeof args[i] === 'string') {\n            result.path = args[i];\n        }\n        else if (typeof args[i] === 'function') {\n            result.callback = args[i];\n        }\n        else if (typeof args[i] === 'boolean') {\n            result.triggerNow = args[i];\n        }\n    }\n    return result;\n};\n\n\n//# sourceURL=webpack://deepstream/./src/util/utils.ts?");

/***/ }),

/***/ 0:
/*!*********************************!*\
  !*** multi ./src/deepstream.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/deepstream.ts */\"./src/deepstream.ts\");\n\n\n//# sourceURL=webpack://deepstream/multi_./src/deepstream.ts?");

/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack://deepstream/util_(ignored)?");

/***/ }),

/***/ 2:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack://deepstream/util_(ignored)?");

/***/ })

/******/ });
});